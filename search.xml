<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS</title>
    <url>/2021/02/07/CSS/</url>
    <content><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近看了两本书《CSS揭秘》和《CSS权威指南》恶补一下CSS（自己真是菜到天际），记录一些有意思的问题</p>
<span id="more"></span>

<h3 id="1-CSS高度由什么决定？"><a href="#1-CSS高度由什么决定？" class="headerlink" title="1. CSS高度由什么决定？"></a>1. CSS高度由什么决定？</h3><h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4><p>一个块级元素div的高度一般是与自身的<strong>CSS样式</strong>和<strong>内部元素的高度总和</strong>有关</p>
<ul>
<li><code>div</code>设置了height后，整个盒模型的高度基本确定，其内部元素再高也无法改变<code>div</code>的高度</li>
<li>当<code>div</code>不设置height时，其高度和内部文档流元素高度的总和有关</li>
</ul>
<h5 id="块级元素不设置高度，内有块级元素时"><a href="#块级元素不设置高度，内有块级元素时" class="headerlink" title="块级元素不设置高度，内有块级元素时"></a>块级元素不设置高度，内有块级元素时</h5><p>会被子元素的height、padding、border撑起来</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    *&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.parent</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">outline</span>: <span class="number">5px</span> solid red;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.child</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>:<span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">5px</span> solid green;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如图，父级元素不设高度，高度为子元素height+border</p>
<div style="display: flex; justify-content: center; align-items: center;">
    <img src="C:\Users\H\AppData\Roaming\Typora\typora-user-images\image-20211120195130235.png"
        alt="image-20211120195130235" style="zoom:50%;" />
    <img src="C:\Users\H\AppData\Roaming\Typora\typora-user-images\image-20211120195056819.png"
        alt="image-20211120195056819" style="zoom:50%;" />
</div>



<h5 id="子元素设置margin时"><a href="#子元素设置margin时" class="headerlink" title="子元素设置margin时"></a>子元素设置margin时</h5><p>父元素高度无法被子元素垂直方向上margin撑开</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    * &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">outline</span>: <span class="number">5px</span> solid red;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">5px</span> solid green;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div style="display: flex; justify-content: center; align-items: center;">
    <img src="C:\Users\H\AppData\Roaming\Typora\typora-user-images\image-20211120202203417.png"
        alt="image-20211120202203417" style="zoom:50%;" />
    <img src="C:\Users\H\AppData\Roaming\Typora\typora-user-images\image-20211120202344779.png"
        alt="image-20211120202344779" style="zoom:50%;" />
</div>

<p><strong>解决方案：父元素设置border&#x2F;padding&#x2F;overflow：hidden</strong></p>
<p><strong>总结：父元素高度能被子元素的height、border、padding撑开，如果父元元素在垂直方向上有<code>border</code>,<code>padding</code>（只要在逻辑上存在，不论大小）以及<code>overflow:hidden</code>，都能被子元素的<code>margin</code>撑开，否则只能撑开父元素的宽度</strong></p>
<h3 id="2-CSS宽度由什么决定？"><a href="#2-CSS宽度由什么决定？" class="headerlink" title="2. CSS宽度由什么决定？"></a>2. CSS宽度由什么决定？</h3><h4 id="行内-行内块元素"><a href="#行内-行内块元素" class="headerlink" title="行内&#x2F;行内块元素"></a>行内&#x2F;行内块元素</h4><p>行内元素&#x2F;行内块的宽度是由它的内容决定的，行内元素不能设置宽高</p>
<h4 id="块级元素-1"><a href="#块级元素-1" class="headerlink" title="块级元素"></a>块级元素</h4><p>一个块级元素宽度当不设置样式时默认为父级元素的100%<strong>（这个100%是自适应的，并不相当于width：100%）</strong></p>
<h3 id="3-为什么margin-top-padding-top设置百分比基于父元素的宽度计算的？"><a href="#3-为什么margin-top-padding-top设置百分比基于父元素的宽度计算的？" class="headerlink" title="3. 为什么margin-top&#x2F;padding-top设置百分比基于父元素的宽度计算的？"></a>3. 为什么margin-top&#x2F;padding-top设置百分比基于父元素的宽度计算的？</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">5px</span> solid red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="C:\Users\H\AppData\Roaming\Typora\typora-user-images\image-20211120194334386.png" alt="image-20211120194334386" style="zoom:50%;" />

<p>这里利用margin-top：50%将子元素挤到最下方贴底，然而这里的百分比是相对于父级宽度计算的。</p>
<p>CSS权威指南中的解释：若是相对于父元素的高度计算会形成死循环。<br><em><strong>“我们认为，正常流中的大多数元素都会足够高以包含其后代元素（包括外边距），如果一个元素的上下外边距是父元素的height的百分数，就可能导致一个无限循环，父元素的height会增加，以适应后代元素上下外边距的增加，而相应的，上下外边距因为父元素height的增加也会增加，形成无限循环。”</strong></em></p>
<p><strong>本质上是因为css中高度是可以自适应的，基于父级高度的百分比计算会导致无限循环的问题</strong>。</p>
<h3 id="4-flex：1"><a href="#4-flex：1" class="headerlink" title="4. flex：1"></a>4. flex：1</h3><p><code>flex：x</code> 相当于 <code>flex-grow: x，flex-shrink：1，flex-basis：0%；</code></p>
<p><code> flex-grow: 定义项目的放大比例,0为不放大</code></p>
<p><code>flex-shrink: 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 </code></p>
<p><code>flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。   </code></p>
<figure class="highlight plaintext"><figcaption><span>``` 的含义是分配**主轴**方向上的剩余空间！</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">所以对于竖直的两栏布局，只需要改变一下主轴方向即可</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">        width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    .f-box &#123;</span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">        border: 5px solid gray;</span><br><span class="line">        height: 100%;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .top &#123;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .bot &#123;</span><br><span class="line">        flex: 1;</span><br><span class="line">        background-color:blue;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;f-box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;bot&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>



<h3 id="5-display：none，visibility：hidden，opacity：0-的区别"><a href="#5-display：none，visibility：hidden，opacity：0-的区别" class="headerlink" title="5. display：none，visibility：hidden，opacity：0  的区别"></a>5. <code>display：none，visibility：hidden，opacity：0</code>  的区别</h3><h4 id="display-none"><a href="#display-none" class="headerlink" title="display: none;"></a>display: none;</h4><ol>
<li>DOM 结构：浏览器不会渲染 display 属性为 none 的元素，不占据空间；</li>
<li><strong>事件监听：无法进行 DOM 事件监听；</strong></li>
<li>性能：动态改变此属性时会引起重排，性能较差；</li>
<li>继承：不会被子元素继承，毕竟子类也不会被渲染；</li>
<li>transition：transition 不支持 display。</li>
</ol>
<h4 id="visibility-hidden"><a href="#visibility-hidden" class="headerlink" title="visibility: hidden;"></a>visibility: hidden;</h4><ol>
<li>DOM 结构：元素被隐藏，但是会被渲染不会消失，占据空间；</li>
<li><strong>事件监听：无法进行 DOM 事件监听；</strong></li>
<li>性 能：动态改变此属性时会引起重绘，性能较高；</li>
<li>继 承：会被子元素继承，子元素可以通过设置 visibility: visible; 来取消隐藏；</li>
<li>transition：visibility 会立即显示，隐藏时会延时</li>
</ol>
<h4 id="opacity-0"><a href="#opacity-0" class="headerlink" title="opacity: 0;"></a>opacity: 0;</h4><ol>
<li>DOM 结构：透明度为 100%，元素隐藏，占据空间；</li>
<li><strong>事件监听：可以进行 DOM 事件监听；</strong></li>
<li>性 能：提升为合成层，不会触发重绘，性能较高；</li>
<li>继 承：会被子元素继承,且，子元素并不能通过 opacity: 1 来取消隐藏；</li>
<li>transition：opacity 可以延时显示和隐藏</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/2021/09/20/HTTP/</url>
    <content><![CDATA[<h2 id="HTTP-有哪些常见状态码"><a href="#HTTP-有哪些常见状态码" class="headerlink" title="HTTP 有哪些常见状态码"></a>HTTP 有哪些常见状态码</h2><h3 id="2xx（成功状态码）"><a href="#2xx（成功状态码）" class="headerlink" title="2xx（成功状态码）"></a>2xx（成功状态码）</h3><h4 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h4><blockquote>
<p>请求成功，服务器已成功处理了客户端的请求，并返回了请求的内容。</p>
</blockquote>
<h3 id="3xx（重定向状态码）"><a href="#3xx（重定向状态码）" class="headerlink" title="3xx（重定向状态码）"></a>3xx（重定向状态码）</h3><h4 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h4><blockquote>
<p>被请求的资源已永久移动到新位置，服务器返回这个状态码时，会在响应头的 Location 字段给出资源的新 URL。搜索引擎会更新其索引中的链接。</p>
</blockquote>
<p>应用场景：如果一个网站更改了页面的 URL 结构，希望将旧的 URL 永久重定向到新的 URL</p>
<h4 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h4><blockquote>
<p>表示请求的资源临时移动到了新位置。与 301 不同的是，搜索引擎不会更新索引中的链接</p>
</blockquote>
<h4 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h4><blockquote>
<p>说明无需再次传输请求的内容，也就是说可以使用缓存的内容</p>
</blockquote>
<span id="more"></span>

<h3 id="4xx（客户端错误状态码）"><a href="#4xx（客户端错误状态码）" class="headerlink" title="4xx（客户端错误状态码）"></a>4xx（客户端错误状态码）</h3><h4 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h4><blockquote>
<p>客户端请求的语法错误，服务器无法理解。</p>
</blockquote>
<p>应用场景：例如，客户端发送的请求格式不符合 HTTP 协议规范，或者请求参数有误，像在 URL 中传递了错误格式的参数</p>
<h4 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h4><blockquote>
<p>请求要求用户的身份认证。对于需要登录才能访问的资源，如果用户未提供有效的认证信息，就会返回这个状态码。</p>
</blockquote>
<h4 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h4><blockquote>
<p>服务器理解请求客户端的请求，但是拒绝执行此请求。这通常是因为服务器端的权限设置，导致用户虽然经过身份认证，但仍然没有足够的权限访问该资源。</p>
</blockquote>
<h4 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h4><blockquote>
<p>服务器找不到请求的资源。这是在网络浏览中最常见的状态码之一。</p>
</blockquote>
<h3 id="5xx（服务器错误状态码）"><a href="#5xx（服务器错误状态码）" class="headerlink" title="5xx（服务器错误状态码）"></a>5xx（服务器错误状态码）</h3><h4 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h4><blockquote>
<p>服务器内部错误，无法完成请求。这是一个比较笼统的服务器端错误状态码。</p>
</blockquote>
<p>应用场景：当服务器端的代码出现异常（如程序崩溃、数据库连接错误等），导致无法正常处理请求时，就会返回 500 Internal Server Error。</p>
<h4 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h4><blockquote>
<p>作为网关或者代理服务器，从上游服务器接收到无效的响应。</p>
</blockquote>
<p>应用场景：在一个复杂的网络架构中，当代理服务器或网关无法从后端服务器获取正确的响应时，例如后端服务器出现故障或者响应格式错误，就会返回 502 Bad Gateway 状态码。</p>
<h4 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h4><blockquote>
<p>服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</p>
</blockquote>
<p>应用场景：在网站流量过高导致服务器过载，或者服务器正在进行维护操作时，会返回 503 Service Unavailable 状态码。</p>
<h4 id="504-Geteway-Timeout"><a href="#504-Geteway-Timeout" class="headerlink" title="504 Geteway Timeout"></a>504 Geteway Timeout</h4><blockquote>
<p>一般表现为应用层服务 (upstream) 超时，如查库操作耗时十分钟，超过了 Nginx 配置的超时时间</p>
</blockquote>
<hr>
<h2 id="HTTP-状态码-502-和-504-有什么区别"><a href="#HTTP-状态码-502-和-504-有什么区别" class="headerlink" title="HTTP 状态码 502 和 504 有什么区别"></a>HTTP 状态码 502 和 504 有什么区别</h2><p>这两种异常状态码都与网关 Gateway 有关，首先明确两个概念</p>
<ul>
<li>Proxy (Gateway)，反向代理层或者网关层。在公司级应用中一般使用 Nginx 扮演这个角色</li>
<li>Application (upstream serrver)，应用层服务，作为 Proxy 层的上游服务。在公司中一般为各种语言编写的服务器应用，如 Go&#x2F;Java&#x2F;Python&#x2F;PHP&#x2F;Node 等</li>
</ul>
<p>此时关于 502 与 504 的区别就很显而易见</p>
<ul>
<li><code>502 Bad Gateway</code>。一般表现为你自己写的应用层服务(Java&#x2F;Go&#x2F;PHP)挂了，网关层无法接收到响应</li>
<li><code>504 Gateway Timeout</code>。一般表现为应用层服务 (upstream) 超时，如查库操作耗时十分钟，超过了 Nginx 配置的超时时间</li>
</ul>
<hr>
<h2 id="HTTP1-1、HTTP2、HTTP3"><a href="#HTTP1-1、HTTP2、HTTP3" class="headerlink" title="HTTP1.1、HTTP2、HTTP3"></a>HTTP1.1、HTTP2、HTTP3</h2><p><a href="https://juejin.cn/post/6844903667569541133#%E5%B8%A7-Frame">https://juejin.cn/post/6844903667569541133#帧-Frame</a></p>
<ul>
<li>题目：<a href="https://q.shanyue.tech/fe/http/86">http2 与 http1.1 有什么改进</a></li>
<li>题目：<a href="https://q.shanyue.tech/fe/http/275">http2 中的首部压缩的实现原理是什么</a></li>
<li>题目：<a href="https://q.shanyue.tech/fe/http/670">http2 中 Stream 与 Frame 是什么关系</a></li>
</ul>
<h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><h4 id="HTTP1-1存在的问题"><a href="#HTTP1-1存在的问题" class="headerlink" title="HTTP1.1存在的问题"></a>HTTP1.1存在的问题</h4><ul>
<li>收到上一个http请求的响应之后才能发送下一个http请求</li>
<li>tcp链接数限制：对同一个域名，只能建立6-8个tcp链接</li>
<li>建立每个tcp链接都需要经过dns解析，三次握手，tls握手，慢启动（开始时只发送较少数据）这些过程</li>
<li>队头阻塞：前一个请求挂了，后面请求无法发送</li>
<li>首部没有压缩，重复内容发送多次（cookie）</li>
</ul>
<h4 id="为什么HTTP1-1无法并发的发送多个请求？（同时发多个，同时收多个）"><a href="#为什么HTTP1-1无法并发的发送多个请求？（同时发多个，同时收多个）" class="headerlink" title="为什么HTTP1.1无法并发的发送多个请求？（同时发多个，同时收多个）"></a>为什么HTTP1.1无法并发的发送多个请求？（同时发多个，同时收多个）</h4><p>因为http1.1是基于文本的协议，比如客户端向服务器发送了两个请求 <code>GET /query?q=A</code> 和 <code>GET /query?q=B</code>，服务器返回了两个结果，客户端是没有办法根据响应结果来判断响应对应于哪一个请求的，而http2基于二进制分帧实现多路复用，数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，<strong>因为根据帧首部的流标识可以重新组装。</strong></p>
<h4 id="HTTP-1-1-中的-keep-alive-有什么作用"><a href="#HTTP-1-1-中的-keep-alive-有什么作用" class="headerlink" title="HTTP 1.1 中的 keep-alive 有什么作用"></a>HTTP 1.1 中的 keep-alive 有什么作用</h4><blockquote>
<p>在 <code>http 1.1</code> 中，在响应头中设置 <code>keep-alive</code> 可以在一个 TCP 连接上发送多个 http 请求</p>
</blockquote>
<ol>
<li>避免了重开 TCP 连接的开销</li>
<li>避免了刷新时重新建立 SSL 连接的开销</li>
<li>避免了QPS过大时，服务器的连接数过大</li>
</ol>
<p>在服务器端使用响应头开启 <code>keep-alive</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br><span class="line">Keep-Alive: <span class="built_in">timeout</span>=5, max=1000</span><br></pre></td></tr></table></figure>

<h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><p>关于 <code>http2</code> 可以阅读谷歌 <code>web.dev</code> 的文档 <a href="https://web.dev/performance-http2/">Introduction to HTTP&#x2F;2</a></p>
<p>关于 HTTP2 有以下改进</p>
<h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><ul>
<li>帧和流：把请求和响应分成一个个二进制帧（首部帧，数据帧），一个完整的请求和响应是一个流每一个帧都有一个stream id，标识每一个帧属于哪个流</li>
<li>复用同一个tcp链接，并发的发送一个个二进制帧，在接收方再进行重组</li>
<li>同一域名只需要一个tcp链接</li>
</ul>
<h4 id="多路复用-Stream-Frame"><a href="#多路复用-Stream-Frame" class="headerlink" title="多路复用 (Stream&#x2F;Frame)"></a>多路复用 (Stream&#x2F;Frame)</h4><ul>
<li>并发的发送一个个二进制帧</li>
</ul>
<h4 id="头部压缩-HPack"><a href="#头部压缩-HPack" class="headerlink" title="头部压缩: (HPack)"></a>头部压缩: (HPack)</h4><ul>
<li>头部压缩算法压缩首部内容</li>
<li>客户端浏览器都保存一张HPACK表，</li>
</ul>
<h4 id="服务端推送-Server-Push"><a href="#服务端推送-Server-Push" class="headerlink" title="服务端推送: (Server Push)"></a>服务端推送: (Server Push)</h4><ul>
<li>不同于http1.1解析完html才请求资源，服务端提前返回这些资源文件</li>
</ul>
<h4 id="HTTP2中可以弃用哪些针对HTTP1-1的优化点"><a href="#HTTP2中可以弃用哪些针对HTTP1-1的优化点" class="headerlink" title="HTTP2中可以弃用哪些针对HTTP1.1的优化点"></a>HTTP2中可以弃用哪些针对HTTP1.1的优化点</h4><p>合并文件、内联资源、雪碧图、域名分片对于 HTTP&#x2F;2 来说是不必要的，使用 h2 尽可能将资源细粒化，文件分解地尽可能散，不用担心请求数多</p>
<h3 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h3><p>HTTP3解决的问题：</p>
<ul>
<li>HTTP2虽然实现了多路复用，但仍基于TCP，一个TCP包丢失，整个链接上的所有流都被阻塞，直到该包被重新传输</li>
<li>tcp和tls握手时延问题</li>
</ul>
<h3 id="HTTP-Proxy原理"><a href="#HTTP-Proxy原理" class="headerlink" title="HTTP Proxy原理"></a>HTTP Proxy原理</h3><blockquote>
<p>webpack-dev-server 中proxy原理，以及如何解决跨域<br>本质上是因为服务端不存在跨域的问题，跨域是浏览器的限制</p>
</blockquote>
<p><strong>Proxy的原理</strong>：<br>代理服务器会自动提取请求数据包中的HTTP请求数据发送给服务端，并服务端的HTTP响应数据转发给发送请求的客户端，HTTP代理服务器使用的端口通常是8080。</p>
<ul>
<li>对于Web客户端来说，代理扮演的服务器角色，接收请求（Request），返回响应（Response）。</li>
<li>对于Web服务器来说，代理扮演的客户端角色，发送请求（Request），接收响应（Response）。</li>
</ul>
<hr>
<h2 id="简单请求和非简单请求"><a href="#简单请求和非简单请求" class="headerlink" title="简单请求和非简单请求"></a>简单请求和非简单请求</h2><h3 id="什么情况下会发送-OPTIONS-请求"><a href="#什么情况下会发送-OPTIONS-请求" class="headerlink" title="什么情况下会发送 OPTIONS 请求"></a>什么情况下会发送 OPTIONS 请求</h3><p><strong>当一个请求跨域且不是简单请求时就会发送 <code>OPTIONS</code> 请求</strong></p>
<p>满足以下条件就是一个简单请求:</p>
<ol>
<li><code>Method</code>: 请求的方法是 <code>GET</code>、<code>POST</code> 及 <code>HEAD</code></li>
<li><code>Header</code>: 请求头是 <code>Content-Type</code>、<code>Accept-Language</code>、<code>Content-Language</code> 等</li>
<li><code>Content-Type</code>: 请求类型是 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code> 或 <code>text/plain</code></li>
</ol>
<p>而在项目中常见的 <code>Content-Type: application/json</code> 及 <code>Authorization: &lt;token&gt;</code> 为典型的<strong>非简单请求</strong>，在发送请求时往往会带上 <code>Options</code></p>
<blockquote>
<p>更详细内容请参考 CORS - MDN</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>Http</tag>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP缓存</title>
    <url>/2021/09/18/HTTP%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="HTTP缓存机制"><a href="#HTTP缓存机制" class="headerlink" title="HTTP缓存机制"></a>HTTP缓存机制</h2><h3 id="HTTP缓存过程"><a href="#HTTP缓存过程" class="headerlink" title="HTTP缓存过程"></a>HTTP缓存过程</h3><blockquote>
<p>第一次发送请求 - 服务器响应，响应标头带上Cache-Control、Expires、ETag、Last-Modified<br>第二次发送请求 - 先根据Cache-Control、Expires判断强缓存是否失效，如果失效，If-None-Match中的上一次ETag和If-Modified-Since中的上一次Last-Modified来判断是否变更，如果没有变更，返回304让浏览器使用本地缓存</p>
</blockquote>
<p><img src="/../assets/HTTP%E7%BC%93%E5%AD%98%E8%BF%87%E7%A8%8B.png" alt="image-20210808204737157"></p>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><blockquote>
<p>Cache-Control 是 HTTP&#x2F;1.1 中新增的属性，在请求头和响应头中都可以使用，常用的属性值如有：</p>
</blockquote>
<ul>
<li>max-age：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效</li>
<li>no-cache：不使用强缓存，需要与服务器验证缓存是否新鲜</li>
<li>no-store：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源</li>
<li>private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应</li>
<li>public：响应可以被中间代理、CDN 等缓存</li>
<li>must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证</li>
</ul>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><blockquote>
<p>Expires 的值是一个 HTTP 日期，在浏览器发起请求时，会根据系统时间和 Expires 的值进行比较，如果系统时间超过了 Expires 的值，缓存失效。</p>
</blockquote>
<p>由于和系统时间进行比较，所以当系统时间和服务器时间不一致的时候，会有缓存有效期不准的问题。Expires 的优先级在三个 Header 属性中是最低的。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><blockquote>
<p>当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。</p>
</blockquote>
<h4 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag&#x2F;If-None-Match"></a>ETag&#x2F;If-None-Match</h4><blockquote>
<p>ETag&#x2F;If-None-Match 的值是一串 hash 码，代表的是一个资源的标识符，当服务端的文件变化的时候，它的 hash码会随之改变</p>
</blockquote>
<h4 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified&#x2F;If-Modified-Since"></a>Last-Modified&#x2F;If-Modified-Since</h4><blockquote>
<p>Last-Modified&#x2F;If-Modified-Since 的值代表的是文件的最后修改时间</p>
</blockquote>
<h4 id="如何实现ETag？"><a href="#如何实现ETag？" class="headerlink" title="如何实现ETag？"></a>如何实现ETag？</h4><p>Nginx中ETag是如何实现的： 上次修改时间 + content-length</p>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><blockquote>
<p>题目：<a href="https://q.shanyue.tech/fe/http/193">简述你们前端项目中资源的缓存配置策略</a><br>  题目：<a href="https://q.shanyue.tech/fe/http/600">现代前端应用应如何配置 HTTP 缓存机制</a><br>  关于 http 缓存配置的最佳实践为以下两条：</p>
</blockquote>
<ul>
<li>文件路径中带有 hash 值：一年的强缓存。因为该文件的内容发生变化时，会生成一个带有新的 hash 值的 URL。前端将会发起一个新的 URL 的请求。配置响应头 <code>Cache-Control: public,max-age=31536000,immutable</code></li>
<li>文件路径中不带有 hash 值：协商缓存。大部分为 public 下文件。配置响应头 <code>Cache-Control: no-cache</code> 与 <code>etag/last-modified </code></li>
</ul>
<p>但是当处理永久缓存时，切记不可打包为一个大的 bundle.js，此时一行业务代码的改变，将导致整个项目的永久缓存失效，此时需要按代码更新频率分为多个 chunk 进行打包，可细粒度控制缓存。</p>
<p><img src="/../assets/HTTP%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.png" alt="HTTP缓存策略"></p>
<ol>
<li><strong>webpack-runtime</strong>: 应用中的 webpack 的版本比较稳定，分离出来，保证长久的永久缓存</li>
<li><strong>react&#x2F;react-dom</strong>: react 的版本更新频次也较低</li>
<li><strong>vendor</strong>: 常用的第三方模块打包在一起，如 lodash，classnames 基本上每个页面都会引用到，但是它们的更新频率会更高一些。另外对低频次使用的第三方模块不要打进来</li>
<li><strong>pageA</strong>: A 页面，当 A 页面的组件发生变更后，它的缓存将会失效</li>
<li><strong>pageB</strong>: B 页面</li>
<li><strong>echarts</strong>: 不常用且过大的第三方模块单独打包</li>
<li><strong>mathjax</strong>: 不常用且过大的第三方模块单独打包</li>
<li><strong>jspdf</strong>: 不常用且过大的第三方模块单独打包</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + Next + GitHub Page搭建个人博客</title>
    <url>/2024/09/21/Hexo%20+%20Next%20+%20GitHub%20Page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="Hexo介绍"><a href="#Hexo介绍" class="headerlink" title="Hexo介绍"></a>Hexo介绍</h3><p>Hexo是一款基于Node.js的开源静态博客框架，用于快速、简单且高效地搭建静态博客网站。本质上是一个静态网站生成器，新增文章只需要编辑md文件，通过运行命令再生成像html的静态文件。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全局安装hexo脚手架</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一blog项目</span></span><br><span class="line">hexo init blog</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入项目</span></span><br><span class="line">cd blog</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装依赖包</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">右键 Git Bush，用户项目自动化部署</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h3 id="项目预览"><a href="#项目预览" class="headerlink" title="项目预览"></a>项目预览</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清理旧的静态文件</span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成静态文件</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行预览项目</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<h3 id="Hexo配置文件详解（-config-yml）"><a href="#Hexo配置文件详解（-config-yml）" class="headerlink" title="Hexo配置文件详解（_config.yml）"></a>Hexo配置文件详解（_config.yml）</h3><h3 id="Hexo插件"><a href="#Hexo插件" class="headerlink" title="Hexo插件"></a>Hexo插件</h3><h4 id="文章排序、显隐插件"><a href="#文章排序、显隐插件" class="headerlink" title="文章排序、显隐插件"></a>文章排序、显隐插件</h4><p>插件：<strong>hexo-generator-index-custom</strong><br>详细见：<a href="https://github.com/im0o/hexo-generator-index-custom">https://github.com/im0o/hexo-generator-index-custom</a></p>
<h4 id="搜索插件"><a href="#搜索插件" class="headerlink" title="搜索插件"></a>搜索插件</h4><h3 id="Next主题样式"><a href="#Next主题样式" class="headerlink" title="Next主题样式"></a>Next主题样式</h3><blockquote>
<p>官方文档：<a href="https://theme-next.js.org/docs/getting-started/configuration.html">https://theme-next.js.org/docs/getting-started/configuration.html</a></p>
</blockquote>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/next-theme/theme-next-docs</span><br><span class="line">cd theme-next-docs</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol>
<li>Hexo版本&gt;&#x3D;5.0</li>
<li>在Hexo项目根目录下创建Next配置文件，命名为_config.next.yml</li>
<li>首次创建Next配置文件时，可以直接复制theme-next-docs目录下的next默认配置文化<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Installed through npm</span></span><br><span class="line">cp node_modules/hexo-theme-next/_config.yml _config.next.yml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Installed through Git</span></span><br><span class="line">cp themes/next/_config.yml _config.next.yml</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="站点中的icon替换"><a href="#站点中的icon替换" class="headerlink" title="站点中的icon替换"></a>站点中的icon替换</h4><blockquote>
<p>Next默认引了fontawsome样式，大部分直接替换即可 <a href="https://fontawesome.dashgame.com/">https://fontawesome.dashgame.com/</a></p>
</blockquote>
<h3 id="站点托管"><a href="#站点托管" class="headerlink" title="站点托管"></a>站点托管</h3><h4 id="腾讯云静态资源托管"><a href="#腾讯云静态资源托管" class="headerlink" title="腾讯云静态资源托管"></a>腾讯云静态资源托管</h4>]]></content>
      <categories>
        <category>Chore</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Hooks</title>
    <url>/2021/10/12/Hooks/</url>
    <content><![CDATA[<h3 id="hooks的作用"><a href="#hooks的作用" class="headerlink" title="hooks的作用"></a>hooks的作用</h3><p><strong>钩子（hook）就是 React 函数组件的副效应解决方案，用来为函数组件引入副效应。</strong> 函数组件的主体只应该用来返回组件的 HTML 代码，所有的其他操作（副效应）都必须通过钩子引入。</p>
<p>由于副效应非常多，所以钩子有许多种。React 为许多常见的操作（副效应），都提供了专用的钩子。</p>
<ul>
<li><code>useState()</code>：保存状态</li>
<li><code>useContext()</code>：保存上下文</li>
<li><code>useRef()</code>：保存引用</li>
<li>……</li>
</ul>
<p>上面这些钩子，都是引入某种特定的副效应，而 <strong><code>useEffect()</code>是通用的副效应钩子</strong> 。找不到对应的钩子时，就可以用它。其实，从名字也可以看出来，它跟副效应（side effect）直接相关。</p>
<span id="more"></span>

<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p><code>useEffect()</code>本身是一个函数，由 React 框架提供，在函数组件内部调用即可。</p>
<p>例如：</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;加载完成&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面例子中，<code>useEffect()</code>的参数是一个函数，它就是所要完成的副效应（改变网页标题）。组件加载以后，React 就会执行这个函数。</p>
<p><code>useEffect()</code>的作用就是指定一个副效应函数，组件每渲染一次，该函数就执行一次。<strong>组件首次在网页 DOM 加载后，副效应函数也会执行。</strong></p>
<h4 id="useEffect指定依赖项"><a href="#useEffect指定依赖项" class="headerlink" title="useEffect指定依赖项"></a>useEffect指定依赖项</h4><p>有时候，我们不希望<code>useEffect()</code>每次渲染都执行，这时可以使用它的第二个参数，使用一个数组指定副效应函数的依赖项，只有依赖项发生变化，才会执行。</p>
<p>如果上例改为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;加载完成&#x27;</span>;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>便只会在组件首次挂载时执行函数，相当于class component中的componentDidMount</p>
<h4 id="useEffect-的用途"><a href="#useEffect-的用途" class="headerlink" title="useEffect() 的用途"></a>useEffect() 的用途</h4><p>只要是副效应，都可以使用<code>useEffect()</code>引入。它的常见用途有下面几种。</p>
<ul>
<li>获取数据（data fetching）</li>
<li>事件监听或订阅（setting up a subscription）</li>
<li>改变 DOM（changing the DOM）</li>
<li>输出日志（logging）</li>
</ul>
<h4 id="useEffect返回值"><a href="#useEffect返回值" class="headerlink" title="useEffect返回值"></a>useEffect返回值</h4><p>副效应是随着组件加载而发生的，那么组件卸载时，可能需要清理这些副效应。</p>
<p><code>useEffect()</code>允许返回一个函数，在组件卸载时，执行该函数，清理副效应。如果不需要清理副效应，<code>useEffect()</code>就不用返回任何值。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = props.<span class="property">source</span>.<span class="title function_">subscribe</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    subscription.<span class="title function_">unsubscribe</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [props.<span class="property">source</span>]);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面例子中，<code>useEffect()</code>在组件加载时订阅了一个事件，并且返回一个清理函数，在组件卸载时取消订阅。</p>
<p><strong>实际使用中，由于副效应函数默认是每次渲染都会执行，所以清理函数不仅会在组件卸载时执行一次，每次副效应函数重新执行之前，也会执行一次，用来清理上一次渲染的副效应。</strong></p>
<h4 id="useEffect常见问题"><a href="#useEffect常见问题" class="headerlink" title="useEffect常见问题"></a>useEffect常见问题</h4><p><strong>使用useEffect应该在依赖的变量中指明定义的函数会用到哪些state或者props</strong></p>
<p>effect 可能会使用一些频繁变化的值。可能会忽略依赖列表中 state，但这通常会引起 Bug：<span name = "233"> </span></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">      <span class="title function_">setCount</span>(count + <span class="number">1</span>); <span class="comment">// 这个 effect 依赖于 `count` state    </span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, []); <span class="comment">// 🔴 Bug: `count` 没有被指定为依赖</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入空的依赖数组 <code>[]</code>，意味着该 hook 只在组件挂载时运行一次，并非重新渲染时。但如此会有问题，在 <code>setInterval</code> 的回调中，<code>count</code> 的值不会发生变化。因为当 effect 执行时，<strong>react会创建一个闭包，并将 <code>count</code> 的值被保存在该闭包当中，且初值为 <code>0</code>。每隔一秒，回调就会执行 <code>setCount(0 + 1)</code>，因此，<code>count</code> 永远不会超过 1。</strong></p>
<p>指定 <code>[count]</code> 作为依赖列表就能修复这个 Bug，但会导致每次改变发生时定时器都被重置。事实上，每个 <code>setInterval</code> 在被清除前都会调用一次（等于说直接使用 <code>setTimeout</code>就行了）。要解决这个问题，可以使用类似setState函数式更新的操作，不依赖外部count变量，它允许我们指定 state 该如何改变而不用引用state或者props</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>); <span class="comment">// ✅ 在这不依赖于外部的 `count` 变量    &#125;, 1000);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, []); <span class="comment">// ✅ 我们的 effect 不使用组件作用域中的任何变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="useLayoutEffect-vs-useEffect"><a href="#useLayoutEffect-vs-useEffect" class="headerlink" title="useLayoutEffect vs useEffect"></a>useLayoutEffect vs useEffect</h4><blockquote>
<p>useLayoutEffect 和 useEffect 的传参一致，但有以下区别</p>
</blockquote>
<ol>
<li><p><strong>执行时机不同</strong><br>useLayoutEffect 的入参函数会在 react 更新 DOM 树后同步调用（<strong>其实就是dom树更新，浏览器重绘前会执行useLayoutEffect里的函数，此时比如去拿 style 或者 dom 尺寸，都是游览器即将渲染的那一次的尺寸，而不是现在页面上展示的尺寸</strong>），useEffect 为异步调用（useEffect 则肯定是在游览器渲染完后才执行），所以应该尽可能使用标准的 <code>useEffect</code> 以避免阻塞视觉更新</p>
</li>
<li><p><strong>useLayoutEffect 在 development 模式下 SSR 会有警告⚠️</strong></p>
</li>
</ol>
<p>通常情况下 useLayoutEffect 会用在做动效和记录 layout 的一些特殊场景（比如防止渲染闪烁，在渲染前再给你个机会去改 DOM）。一般不需要使用 useLayoutEffect。</p>
<p>React 组件是一个树形结构，且每个节点都是懒计算的（类似于 Thunk 的概念）。当一个节点不需要重新计算（重绘）时，他的子树都不会计算（重绘）。<strong>所以我们做性能优化的目标，就是在尽量离根节点近的位置，拦截不必要的节点重算，从而减少重绘的计算量。</strong></p>
<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p>当需要存放一个数据，需要无论在哪里都取到最新状态时，需要使用 useRef，<strong>ref 是一种可变数据。</strong><br>如上文提到的代码段中，因为存在闭包问题，count永远会为1，log永远为0；<br>可以引入<code>useRef</code>解决这个问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> currentCount = <span class="title function_">useRef</span>(count);</span><br><span class="line">  <span class="comment">// 这里在每一次组件重新渲染后更新ref的值</span></span><br><span class="line">  currentCount.<span class="property">current</span> = count;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(currentCount.<span class="property">current</span>)</span><br><span class="line">      <span class="title function_">setCount</span>(currentCount.<span class="property">current</span> + <span class="number">1</span>); <span class="comment">// 这个 effect 依赖于 `count` state    </span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, []); <span class="comment">// 🔴 Bug: `count` 没有被指定为依赖</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useRef、useState如何决策用哪种来维护状态"><a href="#useRef、useState如何决策用哪种来维护状态" class="headerlink" title="useRef、useState如何决策用哪种来维护状态"></a>useRef、useState如何决策用哪种来维护状态</h3><p>useRef 生成的可变对象，因为使用起来就跟普通对象一样，赋值时候 React 是无法感知到值变更的，所以也不会触发组件重绘。利用其与 useState 的区别，我们一般这样区分使用：</p>
<ul>
<li>维护与 UI 相关的状态，使用 useState</li>
</ul>
<blockquote>
<p>确保更改时刷新 UI</p>
</blockquote>
<ul>
<li>值更新不需要触发重绘时，使用 useRef</li>
<li>不需要变更的数据、函数，使用 useState</li>
</ul>
<blockquote>
<p>比如，需要声明一个不可变的值时，可以这样：</p>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [immutable] = <span class="title function_">useState</span>(someState);</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>不返回变更入口函数。useRef 虽然可以借助 TypeScript 达到语法检测上的 immutable，但实际还是 mutable 的。</p>
</blockquote>
<h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><h4 id="context简介："><a href="#context简介：" class="headerlink" title="context简介："></a>context简介：</h4><p><code>React.createContext</code> 新建context</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(defaultValue);</span><br></pre></td></tr></table></figure>

<p>创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 <code>Provider</code> 中读取到当前的 context 值。</p>
<p><strong>只有</strong>当组件所处的树中没有匹配到 Provider 时，其 <code>defaultValue</code> 参数才会生效。此默认值有助于在不使用 Provider 包装组件的情况下对组件进行测试。<strong>注意：将 <code>undefined</code> 传递给 Provider 的 value 时，消费组件的 <code>defaultValue</code> 不会生效。</strong></p>
<p><code>Context.Provider</code></p>
<p>每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。</p>
<h4 id="useContext使用"><a href="#useContext使用" class="headerlink" title="useContext使用"></a>useContext使用</h4><p>接收一个 context 对象（<code>React.createContext</code> 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code> prop 决定。</p>
<p>当组件上层最近的 <code>&lt;MyContext.Provider&gt;</code> 更新时，该 Hook 会触发重渲染，并使用最新传递给 <code>MyContext</code> provider 的 context <code>value</code> 值。即使祖先使用 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo"><code>React.memo</code></a> 或 <a href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate</code></a>，也会在组件本身使用 <code>useContext</code> 时重新渲染。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ThemeContext</span>, themes &#125; <span class="keyword">from</span> <span class="string">&quot;./utils/index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [theme, setTheme] = <span class="title function_">useState</span>(themes.<span class="property">light</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">value</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">theme</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">toggle:</span> () =&gt;</span></span></span><br><span class="line"><span class="language-xml">                    setTheme(</span></span><br><span class="line"><span class="language-xml">                        theme === themes.light ? themes.dark : themes.light</span></span><br><span class="line"><span class="language-xml">                    ),</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Toolbar</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Toolbar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ThemedButton</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ThemedButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">background:</span> <span class="attr">context.theme.background</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">color:</span> <span class="attr">context.theme.foreground</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onClick</span>=<span class="string">&#123;context.toggle&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span></span></span><br><span class="line"><span class="language-xml">            I am styled by theme context!</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p>useMemo 主要有两个作用：</p>
<ol>
<li>缓存一些耗时计算，通过声明计算结果的依赖是否变更，来重用上次计算结果</li>
<li>保证引用不变，针对下游使用 React.memo 的组件进行性能优化（useCallback 也有一样的作用）</li>
</ol>
<p>比如，计算耗时的 fibonacci 数列，就可以用 useMemo 来优化在 n 不变的情况下，二次渲染的性能</p>
<p><code>useMemo(() =&gt; &#123;  return fibonacci(props.n) &#125;, [props.n]); </code></p>
<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>useCallback 是简化版的 useMemo，方便缓存函数引用。下面的代码是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoCallback = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// DO SOMETHING</span></span><br><span class="line">&#125;, [...deps]);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoCallback = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// DO SOMETHING</span></span><br><span class="line">&#125;, [...deps]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在没有遇到性能问题时，不要使用 useCallback 和 useMemo，性能优化先交给框架处理解决。手工的微优化在没有对框架和业务场景有深入了解时，可能出现性能劣化。</p>
</blockquote>
<blockquote>
<p><a href="https://bytedance.feishu.cn/docs/doccnKcSsW0lazRObCmw3GlGkmd">致命的 useCallback&#x2F;useMemo（翻译）</a> </p>
</blockquote>
<blockquote>
<p><a href="https://bytedance.feishu.cn/docs/doccn9SDGhQJ6mM58BxjfRJFs3d">useCallback hell问题总结</a> </p>
</blockquote>
<blockquote>
<p>关于如何减少 useCallback 看 <strong><a href="https://bytedance.feishu.cn/docs/doccnmgIb5KcV3F0zeE47o6PvCh#KQKJ2M">第二天</a></strong></p>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Hooks</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Https</title>
    <url>/2021/09/13/Https/</url>
    <content><![CDATA[<h3 id="为什么需要加密？"><a href="#为什么需要加密？" class="headerlink" title="为什么需要加密？"></a><strong>为什么需要加密？</strong></h3><p>因为http的内容是明文传输的，明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了。劫持者还可以篡改传输的信息且不被双方察觉，这就是“中间人攻击”。</p>
<h3 id="用对称加密可行吗？"><a href="#用对称加密可行吗？" class="headerlink" title="用对称加密可行吗？"></a><strong>用对称加密可行吗？</strong></h3><p>对称加密最大的问题就是密钥的传输，而密钥的传输又需要加密（反复套娃），故而单纯的对称加密是无法解决问题的。</p>
<span id="more"></span>


<h3 id="用非对称加密可行吗？"><a href="#用非对称加密可行吗？" class="headerlink" title="用非对称加密可行吗？"></a>用非对称加密可行吗？</h3><p>鉴于非对称加密的机制，我们可能会有这种思路：服务器先把公钥以明文方式传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，这条数据的安全似乎可以保障了！<strong>因为只有服务器有相应的私钥能解开公钥加密的数据</strong>。</p>
<p>然而反过来<strong>由服务器到浏览器的这条路怎么保障安全？</strong>如果服务器用它的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而这个公钥是一开始通过明文传输给浏览器的，若这个公钥被中间人劫持到了，那他也能用该公钥解密服务器传来的信息了。所以<strong>目前似乎只能保证由浏览器向服务器传输数据的安全性</strong></p>
<h3 id="那用两组公钥私钥，是否就能保证双向传输都安全了？"><a href="#那用两组公钥私钥，是否就能保证双向传输都安全了？" class="headerlink" title="那用两组公钥私钥，是否就能保证双向传输都安全了？"></a>那用两组公钥私钥，是否就能保证双向传输都安全了？</h3><ol>
<li>某网站服务器拥有公钥A与对应的私钥A’；浏览器拥有公钥B与对应的私钥B’。</li>
<li>浏览器把公钥B明文传输给服务器。</li>
<li>服务器把公钥A明文给传输浏览器。</li>
<li>之后浏览器向服务器传输的内容都用公钥A加密，服务器收到后用私钥A’解密。由于只有服务器拥有私钥A’，所以能保证这条数据的安全。</li>
<li>同理，服务器向浏览器传输的内容都用公钥B加密，浏览器收到后用私钥B’解密。同上也可以保证这条数据的安全。</li>
</ol>
<p>然而这又引出了一个新的问题，非对称加密非常耗时，如何解决？（见RSA算法）而且这种方法真的安全了吗？</p>
<h3 id="非对称加密-对称加密"><a href="#非对称加密-对称加密" class="headerlink" title="非对称加密 + 对称加密"></a>非对称加密 + 对称加密</h3><ol>
<li>某网站拥有用于非对称加密的公钥A、私钥A’。</li>
<li>浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。</li>
<li>浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。</li>
<li>服务器拿到后用私钥A’解密得到密钥X。</li>
<li>这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。</li>
</ol>
<p>这基本上就是https采用的方案了，但仍然还是有漏洞。</p>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>中间人攻击（MITMA，man in the middle attack）<br>中间人攻击是一种网络攻击类型 ，应用与LAN局域网中。这种攻击的方式是 hacker 置身于两个通信 paties 之间，窃取数据。</p>
<p>中间人攻击允许黑客截获双方之间的数据，它可能是服务器和客户端或客户端到客户端或服务器到服务器。</p>
<p><img src="/../assets/image-20210513212400962.png" alt="image-20210513212400962"></p>
<p>如果在数据传输过程中，中间人劫持到了数据，此时他的确无法得到浏览器生成的密钥X，这个密钥本身被公钥A加密了，只有服务器才有私钥A’解开它，然而中间人却完全不需要拿到私钥A’就能干坏事了。请看：</p>
<ol>
<li>某网站有用于非对称加密的公钥A、私钥A’。</li>
<li>浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。</li>
<li><strong>中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）</strong>。</li>
<li>浏览器生成一个用于对称加密的密钥X，用<strong>公钥B</strong>（浏览器无法得知公钥被替换了）加密后传给服务器。</li>
<li><strong>中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器</strong>。</li>
<li>服务器拿到后用私钥A’解密得到密钥X。</li>
</ol>
<p>这样在双方都不会发现异常的情况下，中间人掉包了服务器传来的公钥，进而得到了密钥X。<strong>根本原因是浏览器无法确认收到的公钥是不是网站自己的，</strong>因为公钥本身是明文传输的，难道还得对公钥的传输进行加密？这似乎变成鸡生蛋、蛋生鸡的问题了。解法是什么？</p>
<h3 id="如何证明浏览器收到的公钥一定是该网站的公钥？"><a href="#如何证明浏览器收到的公钥一定是该网站的公钥？" class="headerlink" title="如何证明浏览器收到的公钥一定是该网站的公钥？"></a><strong>如何证明浏览器收到的公钥一定是该网站的公钥？</strong></h3><p>网站是否有个‘身份证’来证明自己的公钥合法？这个‘身份证’又由谁来颁发？</p>
<p><strong>CA机构</strong>，它是如今互联网世界正常运作的前提，而CA机构颁发的“身份证”就是<strong>数字证书</strong>。</p>
<h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a><strong>数字证书</strong></h4><p>网站在使用HTTPS前，需要向<strong>CA机构</strong>申领一份<strong>数字证书</strong>，数字证书里含有证书持有者信息、域名、公钥信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，证书就如身份证，证明“该公钥对应该网站”。</p>
<p>而这里又有一个显而易见的问题，“<strong>证书本身的传输过程中，如何防止被篡改”</strong>？即如何证明证书本身的真实性？身份证运用了一些防伪技术，而数字证书怎么防伪呢？</p>
<h3 id="如何放防止数字证书被篡改？"><a href="#如何放防止数字证书被篡改？" class="headerlink" title="如何放防止数字证书被篡改？"></a><strong>如何放防止数字证书被篡改？</strong></h3><p>我们把证书原本的内容生成一份“签名”，比对证书内容和签名是否一致就能判别是否被篡改。这就是数字证书的“防伪技术”，这里的“签名”就叫<code>数字签名</code>：</p>
<p>数字签名的制作过程：</p>
<ol>
<li>CA机构拥有非对称加密的私钥和公钥。</li>
<li>CA机构对证书明文数据T进行hash。</li>
<li>对hash后的值用私钥加密，得到数字签名S。</li>
</ol>
<p>明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。<br>那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）</p>
<p>浏览器验证过程：</p>
<ol>
<li>拿到证书，得到明文T，签名S。</li>
<li>用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。</li>
<li>用证书里指明的hash算法对明文T进行hash得到T’。</li>
<li>显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。所以此时比较S’是否等于T’，等于则表明证书可信。</li>
</ol>
<p><img src="/../assets/image-20210513214044731.png" alt="image-20210513214044731"></p>
<h3 id="中间人有可能篡改该证书吗？"><a href="#中间人有可能篡改该证书吗？" class="headerlink" title="中间人有可能篡改该证书吗？"></a><strong>中间人有可能篡改该证书吗？</strong></h3><p>假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信</p>
<h3 id="中间人有可能把证书掉包吗？"><a href="#中间人有可能把证书掉包吗？" class="headerlink" title="中间人有可能把证书掉包吗？"></a><strong>中间人有可能把证书掉包吗？</strong></h3><p>假设有另一个网站B也拿到了CA机构认证的证书，它想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了。</p>
<p>其实这并不会发生，因为证书一定是无法被篡改的，所以网站B掉包的一定也是正规的证书，而证书黎里包含了网站的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。</p>
<h3 id="为什么制作数字签名时需要hash一次？"><a href="#为什么制作数字签名时需要hash一次？" class="headerlink" title="为什么制作数字签名时需要hash一次？"></a><strong>为什么制作数字签名时需要hash一次？</strong></h3><p>最显然的是性能问题，非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加解密就快很多。</p>
<h3 id="怎么证明CA机构的公钥是可信的？"><a href="#怎么证明CA机构的公钥是可信的？" class="headerlink" title="怎么证明CA机构的公钥是可信的？"></a><strong>怎么证明CA机构的公钥是可信的？</strong></h3><p>“浏览器保有它的公钥”，这是个什么保有法？怎么证明这个公钥是否可信？</p>
<p>让我们回想一下数字证书到底是干啥的？没错，为了证明某公钥是可信的，即“该公钥是否对应该网站”，那CA机构的公钥是否也可以用数字证书来证明？没错，操作系统、浏览器本身会预装一些它们信任的根证书，如果其中会有CA机构的根证书，这样就可以拿到它对应的可信公钥了。</p>
<p>实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做<code>信任链</code>或<code>数字证书链</code>。也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。</p>
<p>另外，不知你们是否遇到过网站访问不了、提示需安装证书的情况？这里安装的就是根证书。说明浏览器不认给这个网站颁发证书的机构，那么你就得手动下载安装该机构的根证书（风险自己承担XD）。安装后，你就有了它的公钥，就可以用它验证服务器发来的证书是否可信了。</p>
<h3 id="每次进行HTTPS请求时都必须在SSL-TLS层进行握手传输密钥吗？"><a href="#每次进行HTTPS请求时都必须在SSL-TLS层进行握手传输密钥吗？" class="headerlink" title="每次进行HTTPS请求时都必须在SSL&#x2F;TLS层进行握手传输密钥吗？"></a><strong>每次进行HTTPS请求时都</strong>必须<strong>在SSL&#x2F;TLS层进行握手传输密钥吗？</strong></h3><p>显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？</p>
<p>服务器会为每个浏览器（或客户端软件）维护一个session ID，在TLS握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>TLS建立连接的整个过程（SSL、TLS握手有一些区别，不同版本间也有区别，不过大致过程就是这样）：</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title>IPad配置开发环境</title>
    <url>/2024/11/12/IPad%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Chore</category>
      </categories>
      <tags>
        <tag>编程环境</tag>
        <tag>IPad</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript API</title>
    <url>/2024/12/30/JS%20API/</url>
    <content><![CDATA[<h2 id="InterSectionObserver"><a href="#InterSectionObserver" class="headerlink" title="InterSectionObserver"></a>InterSectionObserver</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 IntersectionObserver 实例</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span><br><span class="line">  entries.<span class="title function_">forEach</span>(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">      <span class="comment">// 目标元素进入视口时的操作</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;entry.target.id&#125;</span> 进入视口`</span>);</span><br><span class="line">      <span class="comment">// 例如在这里可以加载图片或触发其他动画效果</span></span><br><span class="line">      entry.<span class="property">target</span>.<span class="property">src</span> = <span class="string">&#x27;your_image.jpg&#x27;</span>;</span><br><span class="line">      <span class="comment">// 停止观察该元素（可选）</span></span><br><span class="line">      observer.<span class="title function_">unobserve</span>(entry.<span class="property">target</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择要观察的目标元素</span></span><br><span class="line"><span class="keyword">const</span> targetElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;your_element_id&#x27;</span>);</span><br><span class="line"><span class="comment">// 开始观察目标元素</span></span><br><span class="line">observer.<span class="title function_">observe</span>(targetElement);</span><br></pre></td></tr></table></figure>


<h2 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 MutationObserver 实例</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">(<span class="params">mutationsList</span>) =&gt;</span> &#123;</span><br><span class="line">  mutationsList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">mutation</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mutation.<span class="property">type</span> === <span class="string">&#x27;childList&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 子节点列表发生变化时的操作</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子节点列表发生变化&#x27;</span>);</span><br><span class="line">      <span class="comment">// 可以在这里对新增或删除的子节点进行进一步处理</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutation.<span class="property">type</span> === <span class="string">&#x27;attributes&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 属性发生变化时的操作</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`属性 <span class="subst">$&#123;mutation.attributeName&#125;</span> 发生变化`</span>);</span><br><span class="line">      <span class="comment">// 根据属性变化进行相应的样式更新或逻辑处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择要观察的目标节点</span></span><br><span class="line"><span class="keyword">const</span> targetNode = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;your_target_node_id&#x27;</span>);</span><br><span class="line"><span class="comment">// 配置观察选项</span></span><br><span class="line"><span class="keyword">const</span> config = &#123; <span class="attr">attributes</span>: <span class="literal">true</span>, <span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="comment">// 开始观察目标节点</span></span><br><span class="line">observer.<span class="title function_">observe</span>(targetNode, config);</span><br></pre></td></tr></table></figure>

<h2 id="PerformanceObserver"><a href="#PerformanceObserver" class="headerlink" title="PerformanceObserver"></a>PerformanceObserver</h2><h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><h3 id="requestAnimationFrame的概念"><a href="#requestAnimationFrame的概念" class="headerlink" title="requestAnimationFrame的概念"></a>requestAnimationFrame的概念</h3><p>通俗点讲就是该API能以浏览器的显示频率来作为其动画动作的频率，比如浏览器每10ms刷新一次，动画回调也每10ms调用一次，这样就不会存在过度绘制的问题，动画不会掉帧，自然流畅。</p>
<h3 id="requestAnimationFrame的作用"><a href="#requestAnimationFrame的作用" class="headerlink" title="requestAnimationFrame的作用"></a>requestAnimationFrame的作用</h3><h3 id="requestAnimationFrame的优势"><a href="#requestAnimationFrame的优势" class="headerlink" title="requestAnimationFrame的优势"></a>requestAnimationFrame的优势</h3><h3 id="requestAnimationFrame的优势应用场景"><a href="#requestAnimationFrame的优势应用场景" class="headerlink" title="requestAnimationFrame的优势应用场景"></a>requestAnimationFrame的优势应用场景</h3><h2 id="requestIdleCallback"><a href="#requestIdleCallback" class="headerlink" title="requestIdleCallback"></a>requestIdleCallback</h2>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSrcipt原型</title>
    <url>/2021/02/17/JavaScript%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<p>首先，要明确几个点：</p>
<ol>
<li><p>在JS里，万物皆对象。方法（Function）是对象，方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。<br>即：对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。</p>
</li>
<li><p>方法(Function)<br>方法这个特殊的对象，除了和其他对象一样有上述_proto_属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。</p>
</li>
</ol>
<p>好啦，知道了这两个基本点，我们来看看上面这副图。</p>
<ol>
<li><p>构造函数Foo()<br>构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。</p>
</li>
<li><p>原型对象Foo.prototype<br>Foo.prototype保存着实例共享的方法，有一个指针constructor指回构造函数。</p>
</li>
<li><p>实例<br>f1和f2是Foo这个对象的两个实例，这两个对象也有属性__proto__，指向构造函数的原型对象，这样子就可以像上面1所说的访问原型对象的所有方法啦。</p>
<p><img src="/../assets/Snipaste_2021-08-08_20-48-18.png" alt="image-20210808204737157"></p>
</li>
</ol>
<span id="more"></span>

<p>另外：<br>构造函数Foo()除了是方法，也是对象啊，它也有__proto__属性，指向谁呢？<br>指向它的构造函数的原型对象呗。函数的构造函数不就是Function嘛，因此这里的__proto__指向了Function.prototype。<br>其实除了Foo()，Function(), Object()也是一样的道理。</p>
<p>原型对象也是对象啊，它的__proto__属性，又指向谁呢？<br>同理，指向它的构造函数的原型对象呗。这里是Object.prototype.</p>
<p>最后，Object.prototype的__proto__属性指向null（原型链的终点）</p>
<p>总结：</p>
<ol>
<li>对象有属性__proto__,指向该对象的构造函数的原型对象。</li>
<li>方法除了有属性__proto__,还有属性prototype，prototype指向该方法的原型对象。</li>
<li>标准化获取对象的构造函数的原型：不要用obj.__proto__，用Object.getPrototypeof(obj)。</li>
</ol>
<h2 id="原型对象中的constructor"><a href="#原型对象中的constructor" class="headerlink" title="原型对象中的constructor"></a>原型对象中的constructor</h2><p>看一段代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript垃圾回收</title>
    <url>/2021/02/18/JavaStript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="javascript垃圾回收主要分成两种方法："><a href="#javascript垃圾回收主要分成两种方法：" class="headerlink" title="javascript垃圾回收主要分成两种方法："></a>javascript垃圾回收主要分成两种方法：</h3><h3 id="1-引用计数"><a href="#1-引用计数" class="headerlink" title="1. 引用计数"></a>1. 引用计数</h3><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><p>垃圾回收算法主要依赖于引用的概念。</p>
</li>
<li><p>在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。</p>
</li>
<li><p>例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。</p>
</li>
<li><p>在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域。</p>
</li>
</ul>
<h3 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="headerlink" title="引用计数垃圾收集"></a>引用计数垃圾收集</h3><p>这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span></span><br><span class="line"><span class="comment">// 很显然，没有一个可以被垃圾收集</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = o; <span class="comment">// o2变量是第二个对“这个对象”的引用</span></span><br><span class="line"></span><br><span class="line">o = <span class="number">1</span>;      <span class="comment">// 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oa = o2.<span class="property">a</span>; <span class="comment">// 引用“这个对象”的a属性</span></span><br><span class="line">               <span class="comment">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span></span><br><span class="line"></span><br><span class="line">o2 = <span class="string">&quot;yo&quot;</span>; <span class="comment">// 虽然最初的对象现在已经是零引用了，可以被垃圾回收了</span></span><br><span class="line">           <span class="comment">// 但是它的属性a的对象还在被oa引用，所以还不能回收</span></span><br><span class="line"></span><br><span class="line">oa = <span class="literal">null</span>; <span class="comment">// a属性的那个对象现在也是零引用了</span></span><br><span class="line">           <span class="comment">// 它可以被垃圾回收了</span></span><br></pre></td></tr></table></figure>



<h3 id="2-标记清除"><a href="#2-标记清除" class="headerlink" title="2. 标记清除"></a>2. 标记清除</h3><p>JavaScript 中最常用的垃圾收集方式是标记清除。它的具体工作步骤如下：</p>
<ol>
<li>给存储在内存中的所有变量加上标记（当然可以使用任何标记方式）</li>
<li>去掉当前执行环境中的变量，以及被执行环境中的变量引用的变量的标记</li>
<li>第二步结束后仍被标记的变量将被视为准备删除的变量，因为此时的执行环境中的变量已经无法访问到这些变量了。</li>
<li>完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</li>
</ol>
<p>对于如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="number">4</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test1</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">test2</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设执行到test2()时，垃圾回收开始执行</p>
<p>对于此时，内存情况为</p>
<p><img src="/../assets/image-20210412150846546.png" alt="image-20210412150846546"></p>
<p>开始第一步，将内存中的所有变量加上标记</p>
<p><img src="/../assets/image-20210412151850990.png" alt="image-20210412151850990"></p>
<p>去掉当前执行环境中的变量，以及被执行环境中的变量引用的变量的标记。简单分析一下，此时执行环境中可以访问的变量有 d ,然后我们通过作用域链可以访问到全局变量对象，因此 a 和 b 我们也是可以访问到的</p>
<p><img src="/../assets/image-20210412152201055.png" alt="image-20210412152201055"></p>
<p>此时只有 c 变量还保留有标记，说明 c 变量通过此时的环境已经访问不到了，所以 c 变量需要被清除掉来释放内存。</p>
<p>最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p>
<p><img src="/../assets/image-20210412152245827.png" alt="image-20210412152245827"></p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li>标记清除法的第一个问题就是效率不高，因为在标记清除-阶段，整个程序将会等待，所有如果程序出现卡顿的情况你，那么就有可能是收集垃圾的情况。</li>
<li>标记清除法的第二个问题是，从上面的例子我们可以看出，在清除之后内存空间不是连续的，即出现了内存碎片。如果后面需要一个比较大的连续的内存空间时，那将不能满足要求。而标记-整理方法可以有效地解决这个问题。与标记清除法相比，标记阶段没有什么不同，只是标记结束后，标记-整理方法会将活着的对象向内存的一边移动，最后清理掉边界的内存。不过可以想象，这种做法的效率没有标记-清除高。</li>
</ol>
<p>对比一下官方文档的解释:</p>
<div><i>标记清除这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象

<h4 id="这里的‘根’指的应该是上下文对象"><a href="#这里的‘根’指的应该是上下文对象" class="headerlink" title="这里的‘根’指的应该是上下文对象"></a>这里的‘根’指的应该是上下文对象</h4><p>因为通过当前的执行上下文对象可以访问到当前环境中的变量，也可以通过作用域链去访问到其他上下文中的活动对象，从而可以判断得到所有可以获得的对象和所有不能获得的对象</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript手写题</title>
    <url>/2021/03/02/Javascript%E6%89%8B%E5%86%99%E9%A2%98/</url>
    <content><![CDATA[<h4 id="数组去重方法"><a href="#数组去重方法" class="headerlink" title="数组去重方法"></a>数组去重方法</h4><h4 id="对象拷贝方法"><a href="#对象拷贝方法" class="headerlink" title="对象拷贝方法"></a>对象拷贝方法</h4><h4 id="数组交集、并集、差集"><a href="#数组交集、并集、差集" class="headerlink" title="数组交集、并集、差集"></a>数组交集、并集、差集</h4><h4 id="数组扁平"><a href="#数组扁平" class="headerlink" title="数组扁平"></a>数组扁平</h4><h4 id="实现一个new"><a href="#实现一个new" class="headerlink" title="实现一个new"></a>实现一个new</h4><p><strong>new的具体步骤</strong></p>
<ol>
<li>内存中创建一个新对象</li>
<li>新建对象的 _ <em>proto</em> _指向构造函数的prototype</li>
<li>调用构造函数，函数的this指向新创建的对象</li>
<li>执行构造函数内部的代码（给新对象添加属性）</li>
<li><strong>如果构造函数返回非空对象，则返回该对象，否则，返回新创建的对象</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">age, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 修改obj.__proto__ = fn.prototype，如果直接obj = &#123;&#125;会出现没有对象标识的问题（对象标识为Object），还会使得方法没有被创建</span></span><br><span class="line">    <span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(fn.<span class="property"><span class="keyword">prototype</span></span>)  <span class="comment">//fn.prototype代表 用当前对象的原型去创建</span></span><br><span class="line">    <span class="comment">//现在obj就代表Dog了,但是参数和this指向没有修改</span></span><br><span class="line">    <span class="keyword">const</span> rel = fn.<span class="title function_">apply</span>(obj,args)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       正常规定,如何fn返回的是null或undefined(也就是不返回内容),我们返回的是obj,否则返回rel</span></span><br><span class="line"><span class="comment">       因为比如下面这个构造函数</span></span><br><span class="line"><span class="comment">       function Person(name, age) &#123;</span></span><br><span class="line"><span class="comment">            this.name = name;</span></span><br><span class="line"><span class="comment">            this.age = age;</span></span><br><span class="line"><span class="comment">            return &#123;</span></span><br><span class="line"><span class="comment">                a: 1,</span></span><br><span class="line"><span class="comment">                b: 2,</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        const p = new Person(&#x27;h&#x27;, &#x27;y&#x27;);</span></span><br><span class="line"><span class="comment">        这里new会优先为构造函数的返回值</span></span><br><span class="line"><span class="comment">        所以p的值为&#123;a: 1,b: 2&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> rel <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? rel : obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title function_">myNew</span>(<span class="title class_">Person</span>, <span class="number">19</span>, <span class="string">&#x27;hyz&#x27;</span>);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="实现一个Object-create"><a href="#实现一个Object-create" class="headerlink" title="实现一个Object.create"></a>实现一个Object.create</h4><p>Object.create(proto)创建一个空对象，proto为空对象的”<em><strong>proto</strong></em>“</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// Object.create(null) 返回一个__proto__指向空的干净对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 非对象非null，抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> <span class="title class_">Object</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="虾皮笔试题"><a href="#虾皮笔试题" class="headerlink" title="虾皮笔试题"></a>虾皮笔试题</h4><p>十分有水平的一道题，综合了new原理，原型链+instanceof原理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;ee&#x27;</span>,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// Person 的 prototype 已经改变，而 person1.__proto__ 指向一开始的 Person.prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person1 instanceof Person: &#x27;</span>, person1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>) <span class="comment">// 为啥是false</span></span><br><span class="line"><span class="comment">// 所有的对象都继承自 Object，除了 null 或者你把最顶层的 prototype 也给改了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person1 instanceof Object: &#x27;</span>, person1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">// 为啥是true</span></span><br><span class="line"><span class="comment">// person1 本身没有 constructor, 会沿着原型链找，</span></span><br><span class="line"><span class="comment">// person1.constructor === person1.__proto__.constructor</span></span><br><span class="line"><span class="comment">// 而上面也说了 person1.__proto__ 并没有因为 Person.prototype 改变而改变</span></span><br><span class="line"><span class="comment">// 这里需要注意的是：</span></span><br><span class="line"><span class="comment">// Person 本身就是 constructor</span></span><br><span class="line"><span class="comment">// 初始情况下</span></span><br><span class="line"><span class="comment">// Person.prototype =&gt; Person.prototype</span></span><br><span class="line"><span class="comment">// Person.prototype.constructor =&gt; Person</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person1.constructor == Person: &#x27;</span>, person1.<span class="property">constructor</span> == <span class="title class_">Person</span>) <span class="comment">// 为啥是true</span></span><br><span class="line"><span class="comment">// 上面是 true, 下面就好说了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person1.constructor == Object: &#x27;</span>, person1.<span class="property">constructor</span> == <span class="title class_">Object</span>) <span class="comment">// 为啥是false</span></span><br></pre></td></tr></table></figure>

<h4 id="实现消息订阅"><a href="#实现消息订阅" class="headerlink" title="实现消息订阅"></a>实现消息订阅</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventCenter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Map&lt;string, Array&lt;Function&gt;</span>&#125; <span class="variable">handlers</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">handlers=<span class="keyword">new</span> <span class="built_in">Map</span>()</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handlers</span> = handlers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; <span class="variable">handler</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">type</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="title function_">addEventListener</span>(<span class="params">type, newHandler</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> hanlder = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">has</span>(type);</span><br><span class="line">        <span class="keyword">if</span> (hanlder) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">set</span>(type, [...<span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">get</span>(type), newHandler]) </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">set</span>(type, [newHandler]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">type</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">params</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="title function_">dispatchEvent</span>(<span class="params">type, params=[]</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> handler = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">get</span>(type);</span><br><span class="line">        handler &amp;&amp; handler.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">callback</span>(...params);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; type </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; delHandler </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">removeEventListener</span>(<span class="params">type, delHandler</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">has</span>(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Errow</span>(<span class="string">&quot;Unable to delete&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delHanlder) &#123;</span><br><span class="line">            <span class="keyword">const</span> oldHandlers = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">get</span>(type);</span><br><span class="line">            <span class="keyword">const</span> ind = oldHandlers.<span class="title function_">indexOf</span>(delHandler);</span><br><span class="line">            <span class="keyword">if</span> (ind === -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Errow</span>(<span class="string">&quot;Unable to delete&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            oldHandlers.<span class="title function_">splice</span>(ind, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">delete</span>(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现一个JSONP"><a href="#实现一个JSONP" class="headerlink" title="实现一个JSONP"></a>实现一个JSONP</h4><p>前端部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">url, options</span>) &#123;</span><br><span class="line">    <span class="comment">// 超时处理</span></span><br><span class="line">    <span class="keyword">const</span> &#123; timeout &#125; = options;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 防止函数名冲突</span></span><br><span class="line">        <span class="keyword">let</span> funcName = <span class="string">`jsonp<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">let</span> time = <span class="literal">null</span>, scriptNode;</span><br><span class="line">        <span class="comment">// 定义callback</span></span><br><span class="line">        <span class="variable language_">window</span>[funcName] = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(time);</span><br><span class="line">            <span class="title function_">resolve</span>(data);</span><br><span class="line">            <span class="comment">// 很重要的性能优化点</span></span><br><span class="line">            <span class="comment">// 清除本次请求产生的回调函数和script标签</span></span><br><span class="line">            <span class="keyword">delete</span> <span class="variable language_">window</span>[funcName];</span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(scriptNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建script标签</span></span><br><span class="line">        scriptNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        <span class="comment">// 给script标签添加src属性</span></span><br><span class="line">        scriptNode.<span class="property">src</span> = <span class="string">`<span class="subst">$&#123;url&#125;</span>?callback=<span class="subst">$&#123;funcName&#125;</span>`</span>;</span><br><span class="line">        <span class="comment">// 发出请求</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(scriptNode);</span><br><span class="line">        time = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;network err, timeout&#x27;</span>)</span><br><span class="line">        &#125;, timeout)</span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        scriptNode.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">jsonp</span>(<span class="string">&#x27;http://localhost:9090/api&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">callBack</span>: <span class="string">&#x27;res1&#x27;</span>,</span><br><span class="line">    <span class="comment">// 超时处理</span></span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">// 请求成功</span></span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;jsonp-&gt;&#x27;</span>, res);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 请求失败</span></span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;network err!&quot;</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>后端部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后端</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// /api?callback=onResponse</span></span><br><span class="line">  <span class="comment">// 解析前端请求url中的callback名</span></span><br><span class="line">  <span class="keyword">if</span>(req.<span class="property">url</span>.<span class="title function_">includes</span>(<span class="string">&#x27;/api&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> myurl = url.<span class="title function_">parse</span>(req.<span class="property">url</span>);</span><br><span class="line">    <span class="keyword">let</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(myurl.<span class="property">query</span>)</span><br><span class="line">    <span class="keyword">let</span> posts = [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;php&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> mathodName = params.<span class="title function_">get</span>(<span class="string">&#x27;callback&#x27;</span>);</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">`<span class="subst">$&#123;mathodName&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(posts)&#125;</span>)`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">listen</span>(<span class="number">9090</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">9090</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript执行上下文</title>
    <url>/2021/02/17/Javascript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><h4 id="在看js垃圾回收时遇到相关问题，感觉自己对上下文对象理解的还是不够透彻（实在是太菜了）这就回来恶补。"><a href="#在看js垃圾回收时遇到相关问题，感觉自己对上下文对象理解的还是不够透彻（实在是太菜了）这就回来恶补。" class="headerlink" title="在看js垃圾回收时遇到相关问题，感觉自己对上下文对象理解的还是不够透彻（实在是太菜了）这就回来恶补。"></a>在看js垃圾回收时遇到相关问题，感觉自己对上下文对象理解的还是不够透彻（实在是太菜了）这就回来恶补。</h4><h4 id="执行上下文（Execution-Context）"><a href="#执行上下文（Execution-Context）" class="headerlink" title="执行上下文（Execution Context）"></a>执行上下文（Execution Context）</h4><ul>
<li><p><strong>执行上下文可以理解为当前代码的运行环境。</strong>在 JavaScript 中，运行环境主要包含了<strong>全局环境</strong>和<strong>函数环境</strong>。</p>
</li>
<li><p>在 JavaScript 代码运行过程中，最先进入的是全局环境，而在函数被调用时则进入相应的函数环境。全局环境和函数环境所对应的执行上下文我们分别称为<strong>全局上下文</strong>和<strong>函数上下文</strong>。</p>
</li>
<li><p>在一个 JavaScript 文件中，经常会有多个函数被调用，也就是说在 JavaScript 代码运行过程中很可能会产生多个执行上下文，那么如何去管理这多个执行上下文呢？</p>
</li>
<li><p>执行上下文是以栈（一种 LIFO 的数据结构）的方式被存放起来的，我们称之为<strong>执行上下文栈（Execution Context Stack）</strong>。</p>
</li>
<li><p><strong>在 JavaScript 代码开始执行时，首先进入全局环境，此时全局上下文被创建并入栈，之后当调用函数时则进入相应的函数环境，此时相应函数上下文被创建并入栈，当处于栈顶的执行上下文代码执行完毕后，则会将其出栈。</strong></p>
</li>
<li><p>所以在执行上下文栈中，栈底永远是全局上下文，而栈顶则是当前正在执行的函数上下文。</p>
</li>
</ul>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn1&#x27;</span>)</span><br><span class="line">  <span class="title function_">fn2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>();</span><br></pre></td></tr></table></figure>

<p>对于如上代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 伪代码 以数组来表示执行上下文栈 ECStack=[] */</span></span><br><span class="line"><span class="comment">// 代码执行时最先进入全局环境，全局上下文被创建并入栈</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(global_EC);</span><br><span class="line"><span class="comment">// fn1 被调用，fn1 函数上下文被创建并入栈</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(fn1_EC);</span><br><span class="line"><span class="comment">// fn1 中调用 fn2，fn2 函数上下文被创建并入栈</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(fn2_EC);</span><br><span class="line"><span class="comment">// fn2 执行完毕，fn2 函数上下文出栈</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br><span class="line"><span class="comment">// fn1 执行完毕，fn1 函数上下文出栈</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br><span class="line"><span class="comment">// 代码执行完毕，全局上下文出栈</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/../assets%5Cimage-20210414214146564.png" alt="image-20210414214146564"></p>
<p>在一个执行上下文中，最重要的三个属性分别是<strong>变量对象（Variable Object）</strong>、<strong>作用域链（Scope Chain）</strong>和 <strong>this 指向</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">EC</span> = &#123;</span><br><span class="line">  <span class="variable constant_">VO</span>,</span><br><span class="line">  <span class="variable constant_">SC</span>,</span><br><span class="line">  <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个执行上下文的生命周期分为<strong>创建</strong>和<strong>执行</strong>阶段。创建阶段主要工作是<strong>生成变量对象</strong>、<strong>建立作用域链</strong>和<strong>确定 this 指向</strong>。而执行阶段主要工作是变量赋值以及执行其它代码等。</p>
<h4 id="变量对象（Variable-Object）"><a href="#变量对象（Variable-Object）" class="headerlink" title="变量对象（Variable Object）"></a>变量对象（Variable Object）</h4><p>生成变量有三个过程：</p>
<p><strong>1. 检索当前上下文中的函数参数</strong>。该过程生成 Arguments 对象（函数参数），并建立以形参变量名为属性名，形参变量值为属性值的属性；</p>
<p><strong>2. 检索当前上下文中的函数声明</strong>。该过程建立以函数名为属性名，函数所在内存地址引用为属性值的属性；</p>
<p><strong>3. 检索当前上下文中的变量声明</strong>。该过程建立以变量名为属性名，undefined 为属性值的属性（如果变量名跟已声明的形参变量名或函数名相同，则<strong>该变量声明</strong>不会干扰已经存在的这类属性）。</p>
<p>伪代码表示变量对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">VO</span> = &#123;</span><br><span class="line">  <span class="title class_">Arguments</span>: &#123;&#125;, </span><br><span class="line">  <span class="title class_">ParamVariable</span>: 具体值,  <span class="comment">//形参变量</span></span><br><span class="line">  <span class="title class_">Function</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">function</span> <span class="attr">reference</span>&gt;</span>,</span></span><br><span class="line"><span class="language-xml">  Variable:undefined</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>当执行上下文进入执行阶段后，变量对象会变为<strong>活动对象（Active Object）</strong>。此时原先声明的变量会被赋值。</p>
<p><strong>变量对象和活动对象都是指同一个对象，只是处于执行上下文的不同阶段</strong>。</p>
<p>我们可以通过以下伪代码来表示活动对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">AO</span> = &#123;</span><br><span class="line">  <span class="title class_">Arguments</span>: &#123;&#125;,</span><br><span class="line">  <span class="title class_">ParamVariable</span>: 具体值,  <span class="comment">//形参变量</span></span><br><span class="line">  <span class="title class_">Function</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">function</span> <span class="attr">reference</span>&gt;</span>,</span></span><br><span class="line"><span class="language-xml">  Variable:具体值</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>实际例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>当 fn1 函数被调用时，fn1 执行上下文被创建（创建阶段）并入栈，其变量对象如下所示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn1_EC = &#123;</span><br><span class="line">  <span class="variable constant_">VO</span> = &#123;</span><br><span class="line">    <span class="title class_">Arguments</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">length</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">a</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">fn2</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">function</span> <span class="attr">fn2</span> <span class="attr">reference</span>&gt;</span>,</span></span><br><span class="line"><span class="language-xml">    c:undefined</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>执行阶段：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn1_EC = &#123;</span><br><span class="line">  <span class="variable constant_">AO</span> = &#123;</span><br><span class="line">    <span class="title class_">Arguments</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">length</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">a</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">fn2</span>: &lt;function fn2 reference&gt;,</span><br><span class="line">    c:&lt;function express c reference&gt;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于全局上下文来说，由于其不会有参数传递，所以在生成变量对象的过程中只有检索当前上下文中的函数声明和检索当前上下文中的变量声明两个步骤。</p>
<p>在浏览器环境中，全局上下文中的变量对象（全局对象）即我们熟悉的 window 对象，通过该对象可以使用其预定义的变量和函数，在全局环境中所声明的变量和函数，也会成为全局对象的属性。</p>
<h5 id="函数提升和变量提升"><a href="#函数提升和变量提升" class="headerlink" title="函数提升和变量提升"></a>函数提升和变量提升</h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">0</span>); <span class="comment">// fn</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局上下文的创建阶段</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">VO</span> = &#123;</span><br><span class="line">  <span class="title class_">Arguments</span>: &#123;&#125;, </span><br><span class="line">  <span class="title class_">ParamVariable</span>: 具体值,  <span class="comment">//形参变量</span></span><br><span class="line">  <span class="title class_">Function</span>: <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn&#x27;</span>)&#125;</span><br><span class="line">  <span class="title class_">Variable</span>: a = <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>个人理解：每执行一行，AO都会更新一次（给变量赋值），比如执行到<code>console.log(a) // undefined</code>此时由于AO中的a还未更新，所以输出undefined</p>
<p>所以实际执行过程：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">undefined</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">0</span>); <span class="comment">// fn</span></span><br><span class="line">a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h4 id="作用域链（Scope-Chain）"><a href="#作用域链（Scope-Chain）" class="headerlink" title="作用域链（Scope Chain）"></a>作用域链（Scope Chain）</h4><ul>
<li><p><strong>作用域链是指由当前上下文和上层上下文的一系列变量对象组成的层级链</strong>。它保证了当前执行环境对符合访问权限的变量和函数的有序访问。</p>
</li>
<li><p>我们已经知道，执行上下文分为创建和执行两个阶段，在执行上下文的执行阶段，当需要查找某个变量或函数时，会在当前上下文的变量对象（活动对象）中进行查找，若是没有找到，则会沿着上层上下文的变量对象进行查找，直到全局上下文中的变量对象（全局对象）。</p>
</li>
<li><p>那么当前上下文是如何有序地去查找它所需要的变量或函数的呢？答案就是依靠当前上下文中的作用域链，其包含了当前上下文和上层上下文中的变量对象，以便其一层一层地去查找其所需要的变量和函数。</p>
</li>
<li><p>执行上下文中的作用域链又是怎么建立的呢？我们都知道，JavaScript 中主要包含了全局作用域和函数作用域，而<strong>函数作用域是在函数被声明的时候确定的</strong>。</p>
</li>
<li><p>每一个函数都会包含一个 [[scope]] 内部属性，在函数被声明的时候，该函数的 [[scope]] 属性会保存其上层上下文的变量对象，形成包含上层上下文变量对象的层级链。**[[scope]] 属性的值是在函数被声明的时候确定的**。</p>
</li>
<li><p>当函数被调用的时候，其执行上下文会被创建并入栈。<strong>在创建阶段生成其变量对象后，会将该变量对象添加到作用域链的顶端并将 [[scope]] 添加进该作用域链中</strong>。而在执行阶段，变量对象会变为活动对象，其相应属性会被赋值。</p>
</li>
<li><p>所以，作用域链是由当前上下文变量对象及上层上下文变量对象组成的</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">SC</span> = <span class="variable constant_">AO</span> + [[scope]]</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fn2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>();</span><br></pre></td></tr></table></figure>

<p>在 fn1 函数上下文中，fn2 函数被声明，所以</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn2.[[scope]]=[fn1_EC.<span class="property">VO</span>, globalObj]</span><br></pre></td></tr></table></figure>

<p>当 fn2 被调用的时候，其执行上下文被创建并入栈，此时会将生成的变量对象添加进作用域链的顶端，并且将 [[scope]] 添加进作用域链</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn2_EC.<span class="property">SC</span>=[fn2_EC.<span class="property">VO</span>].<span class="title function_">concat</span>(fn2.[[scope]])</span><br><span class="line">=&gt;</span><br><span class="line">fn2_EC.<span class="property">SC</span>=[fn2_EC.<span class="property">VO</span>, fn1_EC.<span class="property">VO</span>, globalObj]</span><br></pre></td></tr></table></figure>



<h4 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h4><p><strong>this 的指向，是在函数被调用的时候确定的。</strong>也就是执行上下文被创建时确定的。</p>
<p>关于 this 的指向，其实最主要的是三种场景，分别是<strong>全局上下文中 this</strong>、<strong>函数中 this</strong> 和<strong>构造函数中 this</strong>。</p>
<h6 id="全局上下文中-this"><a href="#全局上下文中-this" class="headerlink" title="全局上下文中 this"></a>全局上下文中 this</h6><p>在全局上下文中，this 指代全局对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在浏览器环境中，全局对象是 window 对象：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>); <span class="comment">// true</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">b</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h6 id="函数中-this"><a href="#函数中-this" class="headerlink" title="函数中 this"></a>函数中 this</h6><p>函数中的 this 指向是怎样一种情况呢？</p>
<p><strong>如果被调用的函数，被某一个对象所拥有，那么其内部的 this 指向该对象；如果该函数被独立调用，那么其内部的 this 指向 undefined（非严格模式下指向 window）。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">fn</span>: fn</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">fn</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h6 id="构造函数中-this"><a href="#构造函数中-this" class="headerlink" title="构造函数中 this"></a>构造函数中 this</h6><p>要清楚构造函数中 this 的指向，则必须先了解通过 new 操作符调用构造函数时所经历的阶段。</p>
<p>通过 new 操作符调用构造函数时所经历的阶段如下：</p>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的 this 指向这个新对象；</li>
<li>执行构造函数内部代码；</li>
<li>返回这个新对象。</li>
</ol>
<p>所以从上述流程可知，<strong>对于构造函数来说，其内部 this 指向新创建的对象实例</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ttsy = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;ttsy&#x27;</span>, <span class="number">24</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ttsy.<span class="property">name</span>);  <span class="comment">// ttsy</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ttsy.<span class="property">age</span>);  <span class="comment">// 24</span></span><br></pre></td></tr></table></figure>

<h5 id="需要注意的是，在-ES6-中箭头函数中，this-是在函数声明的时候确定的-箭头函数不绑定this，会捕获上下文的this"><a href="#需要注意的是，在-ES6-中箭头函数中，this-是在函数声明的时候确定的-箭头函数不绑定this，会捕获上下文的this" class="headerlink" title="需要注意的是，在 ES6 中箭头函数中，this 是在函数声明的时候确定的(箭头函数不绑定this，会捕获上下文的this)"></a>需要注意的是，在 ES6 中箭头函数中，this 是在函数声明的时候确定的(箭头函数不绑定this，会捕获上下文的this)</h5>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSrcipt知识点</title>
    <url>/2021/02/17/Javascript%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h4 id="1-script标签中async和defer的区别"><a href="#1-script标签中async和defer的区别" class="headerlink" title="1. script标签中async和defer的区别"></a>1. script标签中async和defer的区别</h4><p><img src="/../assets/Snipaste_2021-12-13_03-23-58.png" alt="image-20211025190555184"></p>
<ul>
<li>普通script标签：下载和执行都会阻塞Dom渲染</li>
<li>defer：立即进行异步下载，等到HTML完全解析完后开始执行，有多个defer的标签时，会按照顺序下载执行</li>
<li>async：立即进行异步下载，下载完后会立即执行同时阻塞Dom渲染，因为是下载完立即执行，不能保证多个加载时的先后顺序。</li>
</ul>
<span id="more"></span>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Jira项目</title>
    <url>/2022/03/02/Jira%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h4 id="代码自动格式化工具：prettier"><a href="#代码自动格式化工具：prettier" class="headerlink" title="代码自动格式化工具：prettier"></a>代码自动格式化工具：prettier</h4><p>配置过程：<a href="https://prettier.io/docs/en/precommit.html">https://prettier.io/docs/en/precommit.html</a></p>
<p><code>yarn add --dev --exact prettier</code></p>
<p>新建<code>.prettierrc.json，.prettierignore</code>文件</p>
<p>设置git commit预提交钩子</p>
<p><code>npx mrm@2 lint-staged </code></p>
<h4 id="规范git-commit工具：commitlint"><a href="#规范git-commit工具：commitlint" class="headerlink" title="规范git commit工具：commitlint"></a>规范git commit工具：commitlint</h4><p>配置过程：<a href="https://github.com/conventional-changelog/commitlint">https://github.com/conventional-changelog/commitlint</a></p>
<p><code>yarn add --save-dev @commitlint/config-conventional @commitlint/cli</code></p>
<p>新建 commitlint.config.js文件，引入规则module.exports &#x3D; {extends: [‘@commitlint&#x2F;config-conventional’]}</p>
<span id="more"></span>

<h4 id="常见MOCK方案"><a href="#常见MOCK方案" class="headerlink" title="常见MOCK方案"></a>常见MOCK方案</h4><h5 id="1-代码侵入（直接在代码中写死Mock数据，或请求本地的JSON文件"><a href="#1-代码侵入（直接在代码中写死Mock数据，或请求本地的JSON文件" class="headerlink" title="1. 代码侵入（直接在代码中写死Mock数据，或请求本地的JSON文件"></a>1. 代码侵入（直接在代码中写死Mock数据，或请求本地的JSON文件</h5><p>​	优点：无</p>
<p>​	缺点：与真实server环境的切换比较麻烦（需要修改请求地址），一切需要侵入代码切换环境的行为都是不好的</p>
<h5 id="2-请求拦截"><a href="#2-请求拦截" class="headerlink" title="2. 请求拦截"></a>2. 请求拦截</h5><p>​	代表：<a href="http://mockjs.com/">Mock.js</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Mock</span>.<span class="title function_">mock</span>(<span class="regexp">/\\\\/</span>api\\\\/visitor\\\\/list/, <span class="string">&#x27;get&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="number">2000</span>,</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;ok&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;data|10&#x27;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&#x27;id|+1&#x27;</span>: <span class="number">6</span>,</span><br><span class="line">      <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;@csentence(5)&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;tag&#x27;</span>: <span class="string">&#x27;@integer(6, 9)-@integer(10, 14)岁 @cword(&quot;零有&quot;, 1)基础&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;lesson_image&#x27;</span>: <span class="string">&quot;&lt;https://images.pexels.com/3737094/pexels-photo-3737094.jpeg&gt;&quot;</span>,</span><br><span class="line">      <span class="string">&#x27;lesson_package&#x27;</span>: <span class="string">&#x27;L1基础指令课&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;done&#x27;</span>: <span class="string">&#x27;@integer(10000, 99999)&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ol>
<li>与前端代码分离</li>
<li>可生成随机数据</li>
</ol>
<p>缺点：</p>
<ol>
<li>数据都是动态生成的假数据，无法真实模拟增删改查的情况</li>
<li>只支持ajax，不支持fetch（本质上是重写了ajax方法，两者的差别见：<a href="https://zhuanlan.zhihu.com/p/24594294">AJAX 之 XHR, Fetch 的对比</a>）</li>
</ol>
<h5 id="3-接口管理工具"><a href="#3-接口管理工具" class="headerlink" title="3. 接口管理工具"></a>3. 接口管理工具</h5><p>代表：rap，swagger，moco，yapi</p>
<p>优点：</p>
<p>​	1.配置功能强大，接口管理与Mock一体，后端修改接口Mock也跟着更改，可靠</p>
<p>缺点：</p>
<p>​	1.配置复杂，依赖后端</p>
<p>​	2.一般会作为大团队的基础建设而存在</p>
<h5 id="4-本地node服务器"><a href="#4-本地node服务器" class="headerlink" title="4. 本地node服务器"></a>4. 本地node服务器</h5><p>代表：<a href="https://github.com/typicode/json-server">json-server</a></p>
<p>优点：</p>
<p>​	1.配置简单，json-server甚至可以0代码30s启动一个REST API Server</p>
<p>​	2.自定义程度高</p>
<p>​	3.增删改查真是模拟</p>
<h5 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h5><p>一句话总结：URI 代表 资源&#x2F;对象，METHOD 代表行为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /tickets // 列表</span><br><span class="line">GET /tickets/12 // 详情</span><br><span class="line">POST /tickets  // 增加</span><br><span class="line">PUT /tickets/12 // 替换</span><br><span class="line">PATCH /tickets/12 // 修改</span><br><span class="line">DELETE /tickets/12 // 删除</span><br></pre></td></tr></table></figure>



<h4 id="d-ts类型文件"><a href="#d-ts类型文件" class="headerlink" title="d.ts类型文件"></a>d.ts类型文件</h4><p>改造js文件为ts文件后，引入的qs库报错</p>
<p><img src="/../assets/image-20211110193223804.png" alt="image-20211110193223804"></p>
<p><code>yarn add @types/qs --save-dev   </code> 安装对应的ts补丁文件</p>
<p><strong>d.ts文件的作用：说明书文件</strong></p>
<p>JS 文件 + .d.ts 文件   &#x3D;&#x3D;&#x3D; ts 文件</p>
<p>.d.ts 文件可以让 JS 文件继续维持自己JS文件的身份，而拥有TS的类型保护</p>
<p>一般写业务代码不会用到，但是点击类型跳转一般会跳转到 .d.ts文件</p>
]]></content>
      <categories>
        <category>Chore</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Mini-React</title>
    <url>/2022/03/04/Mini-React/</url>
    <content><![CDATA[<h4 id="项目拆解："><a href="#项目拆解：" class="headerlink" title="项目拆解："></a>项目拆解：</h4><ol>
<li><p>Jsx 和虚拟 DOM</p>
</li>
<li><p>组件和生命周期</p>
</li>
<li><p>Diff</p>
</li>
<li><p>异步的setState</p>
</li>
<li><p>hook支持</p>
</li>
</ol>
<h4 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h4><h5 id="将jsx经过babel转成React-createElement的形式"><a href="#将jsx经过babel转成React-createElement的形式" class="headerlink" title="将jsx经过babel转成React.createElement的形式"></a>将jsx经过babel转成React.createElement的形式</h5><p>例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hem</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">A</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">B</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">C</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">div</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">span</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">C</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">D</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">B</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">E</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">F</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">A</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过babel转义后</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">_createClass</span>(<span class="title class_">Hem</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&quot;render&quot;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">                A,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                <span class="comment">// A组件的亲儿子组件B</span></span><br><span class="line">                <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">                    B,</span><br><span class="line">                    <span class="literal">null</span>,</span><br><span class="line">                    <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">                        C,</span><br><span class="line">                        <span class="literal">null</span>,</span><br><span class="line">                        <span class="comment">// C组件的亲儿子 div</span></span><br><span class="line">                        <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>),</span><br><span class="line">                        <span class="comment">// C组件的亲儿子 span</span></span><br><span class="line">                        <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>)</span><br><span class="line">                    ),</span><br><span class="line">                    <span class="title class_">React</span>.<span class="title function_">createElement</span>(D, <span class="literal">null</span>)</span><br><span class="line">                ),</span><br><span class="line">                <span class="comment">// A组件的亲儿子组件E</span></span><br><span class="line">                <span class="title class_">React</span>.<span class="title function_">createElement</span>(E, <span class="literal">null</span>),</span><br><span class="line">                <span class="comment">// A组件的亲儿子组件F</span></span><br><span class="line">                <span class="title class_">React</span>.<span class="title function_">createElement</span>(F, <span class="literal">null</span>)</span><br><span class="line">            );</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h5 id="createElement生成虚拟dom"><a href="#createElement生成虚拟dom" class="headerlink" title="createElement生成虚拟dom"></a>createElement生成虚拟dom</h5>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Node中的process.env</title>
    <url>/2022/03/11/Node%E4%B8%AD%E7%9A%84process.env/</url>
    <content><![CDATA[<h4 id="process-env"><a href="#process-env" class="headerlink" title="process.env"></a>process.env</h4><p><code>process</code> 是 <code>Node.js</code> 中的 一个全局变量，提供来有关当前 Node.js 进程的信息并对其进行控制。而<code>process</code> 中的 <code>env</code> 则是返回包含用户环境的对象。可以通过 <code>process.env</code> 拿到当前项目运行环境的信息。</p>
<h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><h5 id="通过cli的方式进行设置"><a href="#通过cli的方式进行设置" class="headerlink" title="通过cli的方式进行设置"></a>通过cli的方式进行设置</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js中</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(process.<span class="property">env</span>.<span class="property">PROT</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Windows (cmd.exe)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> PROT=10086 &amp;&amp; node index.js</span><br></pre></td></tr></table></figure>

<p><strong>Linux, macOS (Bash)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PROT=10086 node index.js</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h5 id="env文件"><a href="#env文件" class="headerlink" title=".env文件"></a><a name="env">.env文件</a></h5><ul>
<li>创建</li>
</ul>
<p>直接在项目根目录中创建 <code>.env</code> 文件，然后键入环境变量及其值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NDOE_ENV=development</span><br><span class="line">PROT=10086</span><br><span class="line">APP_KEY=***********</span><br><span class="line">HOST_URL=**********</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>⚠️注意</strong>：不要把<code>.env</code>文入放入代码版本管理中，因为这些环境变量都是项目中的隐私数据。</p>
<ul>
<li>读取</li>
</ul>
<p><strong>在cra创建的项目中，自带了dotenv解析.env，所以创建.env文件后即可</strong>。</p>
<p>创建 <code>.env</code> 文件后，可以自己编写代码来查找解析文件并将其写入到你的项目中，或者利用第三方的<code>npm</code>包，比如 <a href="https://link.juejin.cn/?target=https://github.com/motdotla/dotenv"><code>dotenv</code></a> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add dotenv</span><br><span class="line"></span><br><span class="line"><span class="comment">// .env</span></span><br><span class="line"><span class="variable constant_">PROT</span>=<span class="number">10086</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> dotenv = <span class="built_in">require</span>(<span class="string">&#x27;dotenv&#x27;</span>);</span><br><span class="line">dotenv.<span class="title function_">config</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(process.<span class="property">env</span>.<span class="property">PROT</span>); <span class="comment">// 10086</span></span><br></pre></td></tr></table></figure>

<p>现在当你执行命令脚本的时候就不用传入环境变量及其值了，在 <code>.env</code> 文件里也能更直观的看到和管理各环境变量的配置。</p>
<h5 id="更好的组织"><a href="#更好的组织" class="headerlink" title="更好的组织"></a>更好的组织</h5><p>一旦环境变量变多，就需要对所有环境变量进行集中式的管理，因为在所有需要使用的地直接引用变量与集中管理相比，重构和维护会更加困难。</p>
<p>所以<strong>创建一个负责收集环境变量的模块</strong>是一个更好的方式，这样可以轻松地一次查看环境变量并将它们映射为可读的名称。</p>
<ul>
<li>手动整理</li>
</ul>
<p>创建一个名为 <code>config.js</code> 的文件，然后写入变量，将其命名为具有良好可读性的属性进行并导出它们。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dotenv = <span class="built_in">require</span>（<span class="string">&#x27;dotenv&#x27;</span>）; </span><br><span class="line"></span><br><span class="line">dotenv.<span class="property">config</span>（）; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; </span><br><span class="line">  hostUrl：process.<span class="property">env</span>.<span class="property">HOST_URL</span>，</span><br><span class="line">  secretKey：process.<span class="property">env</span>.<span class="property">API_KEY</span>，</span><br><span class="line">  port：process.<span class="property">env</span>.<span class="property">PORT</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后就可以这样进行使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;port&#125; = <span class="built_in">require</span>（<span class="string">&#x27;./ config&#x27;</span>）; </span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span>（<span class="string">`端口为：$ &#123;port&#125;`</span>）; <span class="comment">// 10086</span></span><br></pre></td></tr></table></figure>

<p>这样有什么好处呢？</p>
<ol>
<li><p>项目文件组织更为直观合理</p>
</li>
<li><p>清楚的知道环境变量的映射关系</p>
</li>
<li><p>变量重命名为更具可读性的属性</p>
</li>
<li><p>可以添加其他非环境变量的配置属性</p>
</li>
</ol>
<p>但是如果要添加新的环境变量时，就必须将其添加到<code>config</code>模块中。</p>
<ul>
<li>自动整理</li>
</ul>
<p>前面提到的第三方 <code>NPM</code> 包 <code>dotenv</code> 就可以做到。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config.js </span></span><br><span class="line"><span class="keyword">const</span> dotenv = <span class="built_in">require</span>(<span class="string">&#x27;dotenv&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> result = dotenv.<span class="title function_">config</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result.<span class="property">error</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> result.<span class="property">error</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">parsed</span>: envs &#125; = result;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(envs);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = envs;</span><br></pre></td></tr></table></figure>

<p>然后就可以其他模块中这样引用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="variable constant_">HOST_URL</span>, <span class="variable constant_">API_KEY</span>, <span class="variable constant_">PROT</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./config&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="CRA创建的项目使用环境变量"><a href="#CRA创建的项目使用环境变量" class="headerlink" title="CRA创建的项目使用环境变量"></a>CRA创建的项目使用环境变量</h4><p>必须以 <code>REACT_APP_</code> 开头创建自定义环境变量，环境变量在构建期间嵌入。</p>
<h5 id="设置临时环境变量"><a href="#设置临时环境变量" class="headerlink" title="设置临时环境变量"></a>设置临时环境变量</h5><p><strong>Windows (cmd.exe)</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="string">&quot;REACT_APP_SECRET_CODE=abcdef&quot;</span> &amp;&amp; npm <span class="built_in">start</span></span><br></pre></td></tr></table></figure>

<p>（注意：变量赋值需要用引号包裹，以避免尾随空格。）</p>
<p><strong>Windows (Powershell)</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(<span class="variable">$env:REACT_APP_SECRET_CODE</span> = <span class="string">&quot;abcdef&quot;</span>) <span class="operator">-and</span> (npm <span class="built_in">start</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Linux, macOS (Bash)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">REACT_APP_SECRET_CODE=abcdef npm start</span><br></pre></td></tr></table></figure>



<h5 id="env-中添加环境变量"><a href="#env-中添加环境变量" class="headerlink" title=".env 中添加环境变量"></a><code>.env</code> 中添加环境变量</h5><p>见<a href="#env">上文</a>设置。</p>
<h5 id="其他-env-文件"><a href="#其他-env-文件" class="headerlink" title="其他 .env 文件"></a>其他 <code>.env</code> 文件</h5><blockquote>
<p>注意：此功能 <strong>适用于 <code>react-scripts@1.0.0</code> 及更高版本</strong>。</p>
</blockquote>
<ul>
<li><code>.env</code>：默认。</li>
<li><code>.env.local</code>：本地覆盖。<strong>除 test 之外的所有环境都加载此文件</strong>。</li>
<li><code>.env.development</code>, <code>.env.test</code>, <code>.env.production</code>：设置特定环境。</li>
<li><code>.env.development.local</code>, <code>.env.test.local</code>, <code>.env.production.local</code>：设置特定环境的本地覆盖。</li>
</ul>
<p>左侧的文件比右侧的文件具有更高的优先级：</p>
<ul>
<li><code>npm start</code>: <code>.env.development.local</code>, <code>.env.development</code>, <code>.env.local</code>, <code>.env</code></li>
<li><code>npm run build</code>: <code>.env.production.local</code>, <code>.env.production</code>, <code>.env.local</code>, <code>.env</code></li>
<li><code>npm test</code>: <code>.env.test.local</code>, <code>.env.test</code>, <code>.env</code> (注意没有 <code>.env.local</code> )</li>
</ul>
<h5 id="NODE-ENV-的特殊内置环境变量"><a href="#NODE-ENV-的特殊内置环境变量" class="headerlink" title="NODE_ENV 的特殊内置环境变量"></a><code>NODE_ENV</code> 的特殊内置环境变量</h5><p>有一个名为 <code>NODE_ENV</code> 的特殊内置环境变量。可以从 <code>process.env.NODE_ENV</code> 中读取。运行 <code>npm start</code> 时，它总是等于 <code>&#39;development&#39;</code> ，运行 <code>npm test</code> 它总是等于 <code>&#39;test&#39;</code> ，运行 <code>npm run build</code> 来生成一个生产 bundle(包) 时，它总是等于 <code>&#39;production&#39;</code> 。**<code>NODE_ENV</code>无法手动覆盖。** </p>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2021/09/03/Promise/</url>
    <content><![CDATA[<h3 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h3><p>感觉promise的思想非常有意思，为了代码的可读性和可维护性提供了一种新的异步编程方法，接触了一段时间的工程代码也让我体会到代码可维护，可拓展的必要性。</p>
<h3 id="为什么要用Promise？"><a href="#为什么要用Promise？" class="headerlink" title="为什么要用Promise？"></a>为什么要用Promise？</h3><p>对于异步操作，例如文件读取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./a.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./b.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./c.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<p>输出结果：</p>
<p><img src="/../assets/image-20210324010746141.png" alt="image-20210324010746141"></p>
<p>由于读取文件为异步操作，输出的结果不确定。</p>
<p>为了a -&gt; b -&gt; c依次读取文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./src/a.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./src/b.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./src/c.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="keyword">throw</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>回调函数嵌套回调函数，导致了回调地狱，带来的问题也很明显，不便于维护，阅读，异常处理。</p>
<p>使用promise：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myReadFile</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(url, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">resolve</span>(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">myReadFile</span>(<span class="string">&#x27;./a.txt&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">myReadFile</span>(<span class="string">&#x27;./b.txt&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">myReadFile</span>(<span class="string">&#x27;./c.txt&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reason&#x27;</span>, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>由于异常穿透，异常只需要在最后捕获，代码的可读性和维护性也更高，解决了回调地狱的问题。</p>
<h3 id="Promise的工作流程"><a href="#Promise的工作流程" class="headerlink" title="Promise的工作流程"></a>Promise的工作流程</h3><p><img src="/../assets/image-20210321164956018.png" alt="image-20210321164956018"></p>
<h3 id="如何改变promise对象的状态？"><a href="#如何改变promise对象的状态？" class="headerlink" title="如何改变promise对象的状态？"></a>如何改变promise对象的状态？</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//1. resolve 函数</span></span><br><span class="line">    <span class="comment">// resolve(&#x27;&#x27;); // pending   =&gt; fulfilled (resolved)</span></span><br><span class="line">    <span class="comment">//2. reject 函数</span></span><br><span class="line">    <span class="comment">// reject(&quot;&quot;);// pending  =&gt;  rejected </span></span><br><span class="line">    <span class="comment">//3. 抛出错误</span></span><br><span class="line">    <span class="comment">//throw &#x27;出问题了&#x27;;// pending  =&gt;  rejected</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>Promise对象初始状态</li>
</ul>
<p><img src="/../assets/image-20210321172121084.png" alt="image-20210321172121084"></p>
<ul>
<li>Promise对象成功状态</li>
</ul>
<p><img src="/../assets/image-20210322004628047.png" alt="image-20210322004628047"></p>
<ul>
<li>Promise对象失败状态</li>
</ul>
<p><img src="/../assets/image-20210322004718603.png" alt="image-20210322004718603"></p>
<h3 id="Promise-Api"><a href="#Promise-Api" class="headerlink" title="Promise Api"></a>Promise Api</h3><h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h4><figure class="highlight plaintext"><figcaption><span>方法返回一个 ```Promise```。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### Promise.prototype.then()返回的新 promise 的结果状态由什么决定?</span><br><span class="line"></span><br><span class="line">​       **由 then()指定的回调函数执行的结果决定**</span><br><span class="line"></span><br><span class="line">1. 如果抛出异常, 新 promise 变为 rejected, *[[PromiseResult]]*为抛出的异常 </span><br><span class="line"></span><br><span class="line">2. 如果返回的是非 promise 的任意值, 或者没有返回值（相当于返回undefined），新 promise 变为 resolved, *[[PromiseResult]]*为返回的值 </span><br><span class="line"></span><br><span class="line">3. ***如果返回的是另一个新 promise, 此promise的状态成为新promise的状态，此 promise 的[[PromiseResult]]就会成为新 promise 的[[PromiseResult]]***</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">let result = p.then(value =&gt; &#123;</span><br><span class="line">    // console.log(value);</span><br><span class="line">    //1. 抛出错误</span><br><span class="line">    // throw &#x27;出了问题&#x27;;</span><br><span class="line">    //2. 返回结果是非 Promise 类型的对象</span><br><span class="line">    // return 521;</span><br><span class="line">    //3. 返回结果是 Promise 对象</span><br><span class="line">    // return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    //     // resolve(&#x27;success&#x27;);</span><br><span class="line">    //     reject(&#x27;error&#x27;);</span><br><span class="line">    // &#125;);</span><br><span class="line">&#125;, reason =&gt; &#123;</span><br><span class="line">    console.warn(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="then的链式调用"><a href="#then的链式调用" class="headerlink" title="then的链式调用"></a>then的链式调用</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 链式调用</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);<span class="comment">//输出undefine，原因：上一次的then方法返回值为undefine，所以上一次返回一个参数为undefine，状态为resolve的promise对象</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h4><ul>
<li>如果传入的参数为 非Promise类型的对象, 则返回的结果为成功promise对象</li>
<li>如果传入的参数为 Promise 对象, 则参数的结果决定了 resolve 的结果</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">521</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// resolve(&#x27;OK&#x27;);</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// console.log(p2);</span></span><br><span class="line">p2.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h4><p>Promise.reject(reason)方法返回一个失败的promise对象（无论reason是什么）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="/../assets/image-20210321171102762.png" alt="image-20210321171102762"></p>
<h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h4><p><strong>catch()</strong> 方法返回一个Promise，只处理拒绝的情况。它的行为与调用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"><code>Promise.prototype.then(undefined, onRejected)</code></a>相同。</p>
<h3 id="Promise关键问题"><a href="#Promise关键问题" class="headerlink" title="Promise关键问题"></a>Promise关键问题</h3><h4 id="Promise可以执行多个成功-失败的回调"><a href="#Promise可以执行多个成功-失败的回调" class="headerlink" title="Promise可以执行多个成功&#x2F;失败的回调"></a>Promise可以执行多个成功&#x2F;失败的回调</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">///指定回调 - 1</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//指定回调 - 2</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="异常穿透"><a href="#异常穿透" class="headerlink" title="异常穿透"></a>异常穿透</h4><ol>
<li><p>当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调。</p>
</li>
<li><p>前面任何操作出了异常, 都会传到最后失败的回调中处理</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//resolve(&#x27;OK&#x27;);</span></span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&#x27;Err&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(111);</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;失败啦!&#x27;</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason); <span class="comment">// 如果前面then有设置失败的回调，则会在前面就被捕获</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hyz&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Err</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// hyz</span></span><br></pre></td></tr></table></figure>

<h4 id="如何中断Promise链？"><a href="#如何中断Promise链？" class="headerlink" title="如何中断Promise链？"></a>如何中断Promise链？</h4><p>添加一个pendding状态的promise</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">    <span class="comment">//有且只有一个方式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Async与Await"><a href="#Async与Await" class="headerlink" title="Async与Await"></a>Async与Await</h3><p>Async&#x2F;Await 是js异步编程的终极解决方案</p>
<h4 id="Async函数"><a href="#Async函数" class="headerlink" title="Async函数"></a>Async函数</h4><p>返回值规则与Promise.prototype.then()相同</p>
<ul>
<li>函数的返回值为 promise 对象</li>
<li>promise 对象的结果由 async 函数执行的返回值决定</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//1. 如果返回值是一个非Promise类型的数据</span></span><br><span class="line">    <span class="comment">// return 521;</span></span><br><span class="line">    <span class="comment">//2. 如果返回的是一个Promise对象</span></span><br><span class="line">    <span class="comment">// return new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     // resolve(&#x27;OK&#x27;);</span></span><br><span class="line">    <span class="comment">//     reject(&#x27;Error&#x27;);</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line">    <span class="comment">//3. 抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;Oh NO&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Await表达式"><a href="#Await表达式" class="headerlink" title="Await表达式"></a>Await表达式</h4><ul>
<li>await 右侧的表达式一般为 promise 对象, 但也可以是其它的值</li>
<li>如果表达式是 promise 对象, await 返回的是 promise 成功的值([[PromiseResult]])</li>
<li>如果表达式是其它值, 直接将此值作为 await 的返回值</li>
</ul>
<h4 id="mentoon："><a href="#mentoon：" class="headerlink" title="mentoon："></a>mentoon：</h4><ol>
<li>await 必须写在 async 函数中, 但 async 函数中可以没有 await</li>
<li>如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// resolve(&#x27;OK&#x27;);</span></span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//1. 右侧为promise的情况</span></span><br><span class="line">    <span class="comment">// let res = await p;</span></span><br><span class="line">    <span class="comment">//2. 右侧为其他类型的数据</span></span><br><span class="line">    <span class="comment">// let res2 = await 20;</span></span><br><span class="line">    <span class="comment">//3. 如果promise是失败的状态</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res3 = <span class="keyword">await</span> p;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure>

<h3 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./resource/1.html&#x27;</span>, <span class="function">(<span class="params">err, data1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./resource/2.html&#x27;</span>, <span class="function">(<span class="params">err, data2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./resource/3.html&#x27;</span>, <span class="function">(<span class="params">err, data3</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data1 + data2 + data3);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//async 与 await</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//读取第一个文件的内容</span></span><br><span class="line">        <span class="keyword">let</span> data1 = <span class="keyword">await</span> <span class="title function_">mineReadFile</span>(<span class="string">&#x27;./resource/1x.html&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> data2 = <span class="keyword">await</span> <span class="title function_">mineReadFile</span>(<span class="string">&#x27;./resource/2.html&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> data3 = <span class="keyword">await</span> <span class="title function_">mineReadFile</span>(<span class="string">&#x27;./resource/3.html&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data1 + data2 + data3);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="async-await-封装ajax"><a href="#async-await-封装ajax" class="headerlink" title="async await 封装ajax"></a>async await 封装ajax</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点击获取段子<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//axios</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">sendAJAX</span>(<span class="params">url</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="property">responseType</span> = <span class="string">&#x27;json&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url);</span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//处理结果</span></span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">//判断成功</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="comment">//成功的结果</span></span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">resolve</span>(xhr.<span class="property">response</span>);</span></span><br><span class="line"><span class="language-javascript">                        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">reject</span>(xhr.<span class="property">status</span>);</span></span><br><span class="line"><span class="language-javascript">                        &#125;</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//段子接口地址 https://api.apiopen.top/getJoke</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#btn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//获取段子信息</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> duanzi = <span class="keyword">await</span> <span class="title function_">sendAJAX</span>(<span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(duanzi);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>React Router</title>
    <url>/2021/09/01/React-Router/</url>
    <content><![CDATA[<h3 id="SPA的理解"><a href="#SPA的理解" class="headerlink" title="SPA的理解"></a>SPA的理解</h3><ol>
<li><p>单页Web应用（single page web application，SPA）。</p>
</li>
<li><p>整个应用只有<strong>一个完整的页面</strong>。</p>
</li>
<li><p>点击页面中的链接<strong>不会刷新</strong>页面，只会做页面的<strong>局部更新。</strong></p>
</li>
<li><p>数据都需要通过ajax请求获取, 并在前端异步展现。</p>
</li>
</ol>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h5 id="后端路由"><a href="#后端路由" class="headerlink" title="后端路由"></a>后端路由</h5><ul>
<li><p>注册路由： router.get(path, function(req, res))</p>
</li>
<li><p>工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据</p>
</li>
</ul>
<h5 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h5><ul>
<li><p>注册路由: <code>&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt;</code></p>
</li>
<li><p>工作过程：当浏览器的path变为&#x2F;test时, 当前路由组件就会变为Test组件</p>
</li>
</ul>
<span id="more"></span>

<h3 id="React-router-dom相关API"><a href="#React-router-dom相关API" class="headerlink" title="React-router-dom相关API"></a>React-router-dom相关API</h3><h4 id="1-内置API"><a href="#1-内置API" class="headerlink" title="1.内置API"></a>1.内置API</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;BrowserRouter&gt; &lt;/BrowserRouter&gt;</span><br><span class="line"></span><br><span class="line">&lt;HashRouter&gt; &lt;/HashRouter&gt;</span><br><span class="line"></span><br><span class="line">&lt;Route&gt; &lt;/Route&gt;</span><br><span class="line"></span><br><span class="line">&lt;Redirect&gt; &lt;/Redirect&gt;</span><br><span class="line"></span><br><span class="line">&lt;Link&gt; &lt;/Link&gt;</span><br><span class="line"></span><br><span class="line">&lt;NavLink&gt; &lt;/NavLink&gt;</span><br><span class="line"></span><br><span class="line">&lt;Switch&gt; &lt;/Switch&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-其他"><a href="#2-其他" class="headerlink" title="2. 其他"></a>2. 其他</h4><ul>
<li><p>history对象</p>
</li>
<li><p>match对象</p>
</li>
<li><p>withRouter函数</p>
</li>
</ul>
<h3 id="路由组件与一般组件"><a href="#路由组件与一般组件" class="headerlink" title="路由组件与一般组件"></a>路由组件与一般组件</h3><h5 id="1-写法不同："><a href="#1-写法不同：" class="headerlink" title="1. 写法不同："></a>1. 写法不同：</h5><p>一般组件： <code>&lt;Demo/&gt;</code><br>路由组件： <code>&lt;Route path=&quot;/demo&quot; component=&#123;Demo&#125;/&gt;</code></p>
<h5 id="2-存放位置不同："><a href="#2-存放位置不同：" class="headerlink" title="2. 存放位置不同："></a>2. 存放位置不同：</h5><p>一般组件：components<br>路由组件：pages</p>
<h5 id="3-接收到的props不同："><a href="#3-接收到的props不同：" class="headerlink" title="3. 接收到的props不同："></a>3. 接收到的props不同：</h5><p>一般组件：写组件标签时传递了什么，就能收到什么<br>路由组件：接收到三个固定的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">history</span>:</span><br><span class="line">	<span class="attr">go</span>: ƒ <span class="title function_">go</span>(n)</span><br><span class="line">	<span class="attr">goBack</span>: ƒ <span class="title function_">goBack</span>()</span><br><span class="line">	<span class="attr">goForward</span>: ƒ <span class="title function_">goForward</span>()</span><br><span class="line">	<span class="attr">push</span>: ƒ <span class="title function_">push</span>(path, state)</span><br><span class="line">	<span class="attr">replace</span>: ƒ <span class="title function_">replace</span>(path, state)</span><br><span class="line"><span class="attr">location</span>:</span><br><span class="line">	<span class="attr">pathname</span>: <span class="string">&quot;/about&quot;</span></span><br><span class="line">	<span class="attr">search</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="attr">state</span>: <span class="literal">undefined</span></span><br><span class="line"><span class="attr">match</span>:</span><br><span class="line">	<span class="attr">params</span>: &#123;&#125;</span><br><span class="line">	<span class="attr">path</span>: <span class="string">&quot;/about&quot;</span></span><br><span class="line">	<span class="attr">url</span>: <span class="string">&quot;/about&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="NavLink与封装NavLink"><a href="#NavLink与封装NavLink" class="headerlink" title="NavLink与封装NavLink"></a>NavLink与封装NavLink</h3><ul>
<li>NavLink可以实现路由链接的高亮，通过activeClassName指定样式名</li>
</ul>
<h3 id="Switch的使用"><a href="#Switch的使用" class="headerlink" title="Switch的使用"></a>Switch的使用</h3><ul>
<li>通常情况下，path和component是一一对应的关系。</li>
<li>Switch可以提高路由匹配效率(单一匹配)。</li>
</ul>
<h3 id="解决多级路径刷新页面样式丢失的问题"><a href="#解决多级路径刷新页面样式丢失的问题" class="headerlink" title="解决多级路径刷新页面样式丢失的问题"></a>解决多级路径刷新页面样式丢失的问题</h3><ul>
<li>public&#x2F;index.html 中 引入样式时不写 .&#x2F; 写 &#x2F; （常用）</li>
<li>public&#x2F;index.html 中 引入样式时不写 .&#x2F; 写 %PUBLIC_URL% （常用）</li>
<li>使用HashRouter</li>
</ul>
<h3 id="路由的严格匹配与模糊匹配"><a href="#路由的严格匹配与模糊匹配" class="headerlink" title="路由的严格匹配与模糊匹配"></a>路由的严格匹配与模糊匹配</h3><ul>
<li>默认使用的是模糊匹配（简单记：【输入的路径】必须包含要【匹配的路径】，且顺序要一致）</li>
<li>开启严格匹配：<code>&lt;Route exact=&#123;true&#125; path=&quot;/about&quot; component=&#123;About&#125;/&gt;</code></li>
<li>严格匹配不要随便开启，需要再开，有些时候开启会导致无法继续匹配二级路由</li>
</ul>
<h3 id="Redirect的使用"><a href="#Redirect的使用" class="headerlink" title="Redirect的使用"></a>Redirect的使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>一般写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到<span class="title class_">Redirect</span>指定的路由</span><br><span class="line"><span class="number">2.</span>具体编码：</span><br><span class="line">&lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;/</span>&gt;</span></span></span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>/&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Switch</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><ul>
<li>注册子路由时要写上父路由的path值</li>
<li>路由的匹配是按照注册路由的顺序进行的</li>
</ul>
<h3 id="向路由组件传递参数"><a href="#向路由组件传递参数" class="headerlink" title="向路由组件传递参数"></a>向路由组件传递参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>params参数</span><br><span class="line">	路由链接(携带参数)：&lt;<span class="title class_">Link</span> to=<span class="string">&#x27;/demo/test/tom/18&#x27;</span>&#125;&gt;详情&lt;/<span class="title class_">Link</span>&gt;</span><br><span class="line">	注册路由(声明接收)：&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/demo/test/:name/:age&quot;</span> component=&#123;<span class="title class_">Test</span>&#125;/&gt;</span><br><span class="line">	接收参数：<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">match</span>.<span class="property">params</span></span><br><span class="line"><span class="number">2.</span>search参数</span><br><span class="line">	路由链接(携带参数)：&lt;<span class="title class_">Link</span> to=<span class="string">&#x27;/demo/test?name=tom&amp;age=18&#x27;</span>&#125;&gt;详情&lt;/<span class="title class_">Link</span>&gt;</span><br><span class="line">	注册路由(无需声明，正常注册即可)：&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/demo/test&quot;</span> component=&#123;<span class="title class_">Test</span>&#125;/&gt;</span><br><span class="line">	接收参数：<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">location</span>.<span class="property">search</span></span><br><span class="line">	备注：获取到的search是urlencoded编码字符串，需要借助querystring解析</span><br><span class="line"><span class="number">3.</span>state参数</span><br><span class="line">	路由链接(携带参数)：&lt;<span class="title class_">Link</span> to=&#123;&#123;<span class="attr">pathname</span>:<span class="string">&#x27;/demo/test&#x27;</span>,<span class="attr">state</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;&#125;&#125;&gt;详情&lt;/<span class="title class_">Link</span>&gt;</span><br><span class="line">	注册路由(无需声明，正常注册即可)：&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/demo/test&quot;</span> component=&#123;<span class="title class_">Test</span>&#125;/&gt;</span><br><span class="line">	接收参数：<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">location</span>.<span class="property">state</span></span><br><span class="line">	备注：刷新也可以保留住参数</span><br></pre></td></tr></table></figure>



<h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">借助<span class="variable language_">this</span>.<span class="property">prosp</span>.<span class="property">history</span>对象上的<span class="variable constant_">API</span>对操作路由跳转、前进、后退</span><br><span class="line">	-<span class="variable language_">this</span>.<span class="property">prosp</span>.<span class="property">history</span>.<span class="title function_">push</span>()</span><br><span class="line">	-<span class="variable language_">this</span>.<span class="property">prosp</span>.<span class="property">history</span>.<span class="title function_">replace</span>()</span><br><span class="line">	-<span class="variable language_">this</span>.<span class="property">prosp</span>.<span class="property">history</span>.<span class="title function_">goBack</span>()</span><br><span class="line">	-<span class="variable language_">this</span>.<span class="property">prosp</span>.<span class="property">history</span>.<span class="title function_">goForward</span>()</span><br><span class="line">	-<span class="variable language_">this</span>.<span class="property">prosp</span>.<span class="property">history</span>.<span class="title function_">go</span>()</span><br></pre></td></tr></table></figure>



<h3 id="BrowserRouter与HashRouter的区别"><a href="#BrowserRouter与HashRouter的区别" class="headerlink" title="BrowserRouter与HashRouter的区别"></a>BrowserRouter与HashRouter的区别</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>底层原理不一样：</span><br><span class="line">	<span class="title class_">BrowserRouter</span>使用的是<span class="variable constant_">H5</span>的history <span class="variable constant_">API</span>，不兼容<span class="title class_">IE9</span>及以下版本。</span><br><span class="line">	<span class="title class_">HashRouter</span>使用的是<span class="variable constant_">URL</span>的哈希值。</span><br><span class="line"><span class="number">2.</span>path表现形式不一样</span><br><span class="line">	<span class="title class_">BrowserRouter</span>的路径中没有#,例如：<span class="attr">localhost</span>:<span class="number">3000</span>/demo/test</span><br><span class="line">	<span class="title class_">HashRouter</span>的路径包含#,例如：<span class="attr">localhost</span>:<span class="number">3000</span>/#/demo/test</span><br><span class="line"><span class="number">3.</span>刷新后对路由state参数的影响</span><br><span class="line">	(<span class="number">1</span>).<span class="property">BrowserRouter</span>没有任何影响，因为state保存在history对象中。</span><br><span class="line">	(<span class="number">2</span>).<span class="property">HashRouter</span>刷新后会导致路由state参数的丢失！！！</span><br><span class="line"><span class="number">4.</span>备注：<span class="title class_">HashRouter</span>可以用于解决一些路径错误相关的问题。</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React最佳实践</title>
    <url>/2021/10/01/React%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="事件机制，合成事件"><a href="#事件机制，合成事件" class="headerlink" title="事件机制，合成事件"></a>事件机制，合成事件</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>React 基于浏览器的事件机制⾃身实现了⼀套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等。<br>在 React 中这套事件机制被称之为合成事件</p>
<h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parentRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">childRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;React componentDidMount！&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parentRef</span>.<span class="property">current</span>?.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;原⽣事件：⽗元素 DOM 事件监听！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">childRef</span>.<span class="property">current</span>?.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;原⽣事件：⼦元素 DOM 事件监听！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;原⽣事件：document DOM 事件监听！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> parentClickFun = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;React 事件：⽗元素事件监听！&quot;</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> childClickFun = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;React 事件：⼦元素事件监听！&quot;</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.parentRef&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.parentClickFun&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.childRef&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.childClickFun&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                分析事件执⾏顺序</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>
<p>最终输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原⽣事件：⼦元素 DOM 事件监听！</span><br><span class="line">原⽣事件：⽗元素 DOM 事件监听！</span><br><span class="line">React 事件：⼦元素事件监听！</span><br><span class="line">React 事件：⽗元素事件监听！</span><br><span class="line">原⽣事件：document DOM 事件监听！</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>React 上注册的事件最终会绑定在document这个 DOM 上，⽽不是 React 组件对应的 DOM(减少内存开销就是因为所有的事件都绑定在 document 上，其他节点没有绑定事件)<!-- - React ⾃身实现了⼀套事件冒泡机制，所以这也就是为什么我们 event.stopPropagation()⽆效的原因。 --></li>
<li>React 通过队列的形式，从触发的组件向⽗组件回溯，然后调⽤他们 JSX 中定义的 callback</li>
<li>React 有⼀套⾃⼰的合成事件 SyntheticEvent</li>
</ul>
<h3 id="CSS引入"><a href="#CSS引入" class="headerlink" title="CSS引入"></a>CSS引入</h3><h4 id="在组件内直接使⽤"><a href="#在组件内直接使⽤" class="headerlink" title="在组件内直接使⽤"></a>在组件内直接使⽤</h4><p>内联style引入</p>
<h4 id="组件中引⼊-css-⽂件"><a href="#组件中引⼊-css-⽂件" class="headerlink" title="组件中引⼊ .css ⽂件"></a>组件中引⼊ .css ⽂件</h4><p>全局生效，样式之间会互相影响</p>
<h4 id="组件中引⼊-module-css-⽂件"><a href="#组件中引⼊-module-css-⽂件" class="headerlink" title="组件中引⼊ .module.css ⽂件"></a>组件中引⼊ .module.css ⽂件</h4><p>将 css ⽂件作为⼀个模块引⼊，这个模块中的所有 css ，只作⽤于当前组件。不会影响当前组件的后代组件<br>这种⽅式是 webpack 特⼯的⽅案，只需要配置 webpack 配置⽂件中 <code>modules:true</code> 即可</p>
<h4 id="CSS-in-JS"><a href="#CSS-in-JS" class="headerlink" title="CSS in JS"></a>CSS in JS</h4><p>CSS-in-JS， 是指⼀种模式，其中 CSS 由 JavaScript ⽣成⽽不是在外部⽂件中定义<br>此功能并不是 React 的⼀部分，⽽是由第三⽅库提供，例如：</p>
<ul>
<li>styled-components</li>
<li>emotion</li>
<li>glamorous</li>
</ul>
<p>本质是通过函数的调⽤，最终创建出⼀个组件：</p>
<ul>
<li>这个组件会被⾃动添加上⼀个不重复的class</li>
<li>styled-components会给该class添加相关的样式</li>
</ul>
<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><p>本质上是一个函数，接收一个或多个组件作为参数，并返回一个组件</p>
<h3 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h3><p>错误边界是一种 React 组件，<strong>这种组件可以捕获发生在其子组件树任何位置的 JavaScript 错误，并打印这些错误，同时展示降级 UI</strong>，而并不会渲染那些发生崩溃的子组件树。错误边界可以捕获发生在整个子组件树的渲染期间、生命周期方法以及构造函数中的错误。</p>
<p>形成错误边界组件的两个条件：</p>
<ul>
<li>使⽤了 <code>static getDerivedStateFromError()</code></li>
<li>使⽤了 <code>componentDidCatch()</code><br>抛出错误后，使⽤ <code>static getDerivedStateFromError()</code> 渲染备⽤ UI ，使⽤ componentDidCatch() 打印错误信息，如下：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, errorInfo</span>) &#123;</span><br><span class="line">    <span class="comment">// 你同样可以将错误日志上报给服务器</span></span><br><span class="line">    <span class="title function_">logErrorToMyService</span>(error, errorInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="comment">// 你可以自定义降级后的 UI 并渲染</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下⾯这些情况⽆法捕获到异常：</p>
<ul>
<li>事件处理</li>
<li>异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）</li>
<li>服务端渲染</li>
<li>它自身抛出来的错误（仅能捕获子组件抛出的错误）</li>
</ul>
<h3 id="setState更新，批量更新"><a href="#setState更新，批量更新" class="headerlink" title="setState更新，批量更新"></a>setState更新，批量更新</h3><h3 id="render原理（jsx经过babel编译）、render触发时机"><a href="#render原理（jsx经过babel编译）、render触发时机" class="headerlink" title="render原理（jsx经过babel编译）、render触发时机"></a>render原理（jsx经过babel编译）、render触发时机</h3><h3 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h3><h3 id="React-Portal"><a href="#React-Portal" class="headerlink" title="React Portal"></a>React Portal</h3><p>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。<br><code>ReactDOM.createPortal(child, container)</code><br>第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 fragment。第二个参数（container）是一个 DOM 元素。</p>
<h3 id="React-router"><a href="#React-router" class="headerlink" title="React router"></a>React router</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><p>react-router 等前端路由的原理⼤致相同，可以实现⽆刷新的条件下切换显示不同的⻚⾯<br>路由的本质就是⻚⾯的 URL 发⽣改变时，⻚⾯的显示结果可以根据 URL 的变化⽽变化，但是⻚⾯不会刷新因此，可以通过前端路由可以实现单⻚(SPA)应⽤</p>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><h5 id="HashRouter（Hash模式）"><a href="#HashRouter（Hash模式）" class="headerlink" title="HashRouter（Hash模式）"></a>HashRouter（Hash模式）</h5><ul>
<li>采用监听 <code>window</code> 上的 <code>hashchange</code> 事件实现；</li>
<li>path的表现形式是 <code>localhost:3000/#/demo/test</code>；</li>
<li>服务器无须做额外配置（因为对于服务器而言，<code>http://example.com/#/home</code>和<code>http://example.com</code>这两个请求在服务器看来是完全一样的，因为服务器只处理<code>http://example.com</code>这个部分，而<code>#/home</code>这个哈希部分的变化不会触发新的服务器请求）</li>
</ul>
<h5 id="BrowserRouter（History模式）"><a href="#BrowserRouter（History模式）" class="headerlink" title="BrowserRouter（History模式）"></a>BrowserRouter（History模式）</h5><ul>
<li><code>BrowserRouter</code>使用的是H5的history API来实现；</li>
<li>path的表现形式是 <code>localhost:3000/demo/test</code>；</li>
<li>服务器需要进行额外的配置（当path变化时，浏览器会向服务器发送请求。服务器需要能够识别这些请求并返回正确的页面或者资源。例如，在服务器重定向配置中，需要设置一个通配符路由（<code>*</code>）来处理所有可能的路由请求，将请求重定向到应用的入口文件（通常是<code>index.html</code>），这样客户端的 JavaScript 代码才能根据 URL 中的路径来正确地渲染页面）</li>
</ul>
<h3 id="lazyload"><a href="#lazyload" class="headerlink" title="lazyload"></a>lazyload</h3><h3 id="render-props、children"><a href="#render-props、children" class="headerlink" title="render props、children"></a>render props、children</h3><h3 id="Hooks相关"><a href="#Hooks相关" class="headerlink" title="Hooks相关"></a>Hooks相关</h3><h3 id="React-fiber"><a href="#React-fiber" class="headerlink" title="React fiber"></a>React fiber</h3><h3 id="React性能优化"><a href="#React性能优化" class="headerlink" title="React性能优化"></a>React性能优化</h3><h3 id="React状态管理"><a href="#React状态管理" class="headerlink" title="React状态管理"></a>React状态管理</h3><p><a href="https://huangyunt.github.io/2021/10/11/Redux/">Redux</a></p>
<h3 id="react如何实现ssr"><a href="#react如何实现ssr" class="headerlink" title="react如何实现ssr"></a>react如何实现ssr</h3>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React生态</title>
    <url>/2021/09/30/React%E7%94%9F%E6%80%81/</url>
    <content><![CDATA[<h3 id="React-DevTools"><a href="#React-DevTools" class="headerlink" title="React DevTools"></a>React DevTools</h3><h5 id="General-设置"><a href="#General-设置" class="headerlink" title="General 设置"></a>General 设置</h5><img src="../assets/image-20220222024702149.png" alt="image-20220222024702149" style="zoom:33%;" />

<p>General 面板中最重要的功能就是 **”Highlight updates when components render”**。勾选上之后，可以查看 React 重绘时，页面哪些部分有更新。在遇到性能问题时，可以快速帮助决策在哪部分不需要重绘的组件部分添加 React.memo 阻止重绘。</p>
<h5 id="Debugging-设置"><a href="#Debugging-设置" class="headerlink" title="Debugging 设置"></a>Debugging 设置</h5><img src="..\assets\image-20220222024832097.png" alt="image-20220222024832097" style="zoom:33%;" />

<p><strong>“Append components stacks to console warnings and errors.”</strong></p>
<p>可以帮助我们定位 React 报错信息来自哪个组件</p>
<span id="more"></span>


<h5 id="Components-设置"><a href="#Components-设置" class="headerlink" title="Components 设置"></a>Components 设置</h5><img src="..\assets\image-20220222024936104.png" alt="image-20220222024936104" style="zoom:33%;" />

<p><strong>“Hide components where…”</strong></p>
<p>此项在过滤组件树时有用。比如，大多数应用可能会在顶层有很多 Context.Provider，就可以过滤 Context 类型、不显示。当我们只关心业务逻辑层的组件时，可以过滤掉 DOM 组件，减少树的节点</p>
<h5 id="Profiler-设置"><a href="#Profiler-设置" class="headerlink" title="Profiler 设置"></a>Profiler 设置</h5><img src="..\assets\image-20220222025024293.png" alt="image-20220222025024293" style="zoom:33%;" />

<p><strong>“Record why each component rendered while profiling”</strong></p>
<img src="..\assets\image-20220222025054509.png" alt="image-20220222025054509" style="zoom:33%;" />

<p>勾选之后会在渲染火焰图的 hover 面板中看到 **”Why did this render”**。</p>
<h5 id="现在有哪些-render-原因呢？"><a href="#现在有哪些-render-原因呢？" class="headerlink" title="现在有哪些 render 原因呢？"></a>现在有哪些 render 原因呢？</h5><ul>
<li><p><strong>Props changed</strong></p>
<p>​     顾名思义，传入组件的 props 变更</p>
</li>
<li><p><strong>The parent component rendered</strong></p>
<p>​	父组件渲染导致的子组件渲染。一般要做性能优化都是找这类重绘原因的组件。但是要注意，如果组件中有用到 useContext，Provider 的 value 变更导致的重绘也是被标记为 The parent component rendered，需要注意</p>
</li>
<li><p><strong>Hooks changed</strong></p>
<p>​	Hook 状态变更导致的重绘，一般就是指 useState 返回的更新函数被调用了</p>
</li>
<li><p><strong>State changed</strong></p>
<p>​	这个只会在 class component 中有，大家忽略</p>
</li>
<li><p><strong>“Hide commits below xx (ms)”</strong></p>
<p>​	设置一个更新耗时的阈值，低于该阈值的渲染不显示。用来快速过滤哪些渲染有性能问题</p>
</li>
</ul>
<h5 id="React-组件检视器"><a href="#React-组件检视器" class="headerlink" title="React 组件检视器"></a>React 组件检视器</h5><p>用法和 DevTools 的元素面板类似，可以直接在页面上定位到元素对应的 React Component。并且可以实时查看当前组件内部的 hooks 状态，返回的组件树</p>
<img src="..\assets\image-20220222025129591.png" alt="image-20220222025129591" style="zoom:33%;" />

<p>右上角的四个图标</p>
<img src="..\assets\image-20220222025154916.png" alt="image-20220222025154916" style="zoom:33%;" />

<p>分别作用如下：</p>
<ul>
<li>模拟 ReactLazy 懒加载组件 Suspense 状态</li>
<li>定位组件所渲染的 DOM 节点</li>
<li>在 Console 中打印 Component 内部状态</li>
<li>跳转到组件所在源文件（配合 sourcemap）</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React的设计和实现</title>
    <url>/2021/09/29/React%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="本篇笔记的目的：站在更高的角度看待React"><a href="#本篇笔记的目的：站在更高的角度看待React" class="headerlink" title="本篇笔记的目的：站在更高的角度看待React"></a>本篇笔记的目的：站在更高的角度看待React</h4><h4 id="React的设计思路"><a href="#React的设计思路" class="headerlink" title="React的设计思路"></a>React的设计思路</h4><ul>
<li><p>解决UI编程的痛点</p>
<ol>
<li><p>状态更新，UI不会自动更新，需要手动调dom api进行更新</p>
<ol start="2">
<li>欠缺基本代码的封装和隔离，代码层面没有组件化</li>
<li>UI之间数据依赖，需要手动维护，如果依赖链路过长，会有 callback hell的问题</li>
</ol>
</li>
</ol>
</li>
<li><p>响应式编程</p>
</li>
</ul>
<p><img src="/../assets/image-20220210203412954.png" alt="image-20220210203412954"></p>
<ul>
<li><p>期望能</p>
<pre><code>1. 状态更新，UI自动更新
2. 前端代码组件化，可复用，可封装
3. 状态之间的依赖关系，只需要声明即可
</code></pre>
</li>
<li><p>组件化</p>
<pre><code>1. 组件是组件的组合/原子组件
2. 组件内拥有状态，外部不可见
3. 父组件可将状态传入组件内部
</code></pre>
</li>
<li><p>状态归属问题</p>
<pre><code>1. react是单向数据流，只能父组件将状态传递给子组件（但可以将改变父组件状态的方法传递给子组件实现父子组件通信）
2. 如何解决不合理的状态上升问题？
3. 组件状态改变后，如何更新dom
</code></pre>
</li>
</ul>
<span id="more"></span>


<h4 id="React的实现"><a href="#React的实现" class="headerlink" title="React的实现"></a>React的实现</h4><ul>
<li>DIff算法</li>
</ul>
<img src="../assets/image-20220210212319207.png" alt="image-20220210212319207" style="zoom:40%;" />



<h3 id="React解决状态管理问题"><a href="#React解决状态管理问题" class="headerlink" title="React解决状态管理问题"></a>React解决状态管理问题</h3><p>先说结论：使用状态管理库</p>
<ul>
<li><p>状态管理库核心思想：将状态抽离到ui外部进行统一管理。</p>
</li>
<li><p>将状态抽离到ui外部的问题：降低了组件复用性，组件跟外部状态强耦合</p>
</li>
</ul>
<p><strong>何时使用状态管理库？</strong></p>
<p><strong>判断一个状态是不是只属于组件本身，如若是则不需要状态管理库</strong></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React组件性能优化</title>
    <url>/2021/10/14/React%E7%BB%84%E4%BB%B6%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="React-性能优化思路"><a href="#React-性能优化思路" class="headerlink" title="React 性能优化思路"></a>React 性能优化思路</h3><p>我觉得React 性能优化的理念的主要方向就是这两个：</p>
<ol>
<li><strong>减少重新 render 的次数。因为在 React 里最重(花时间最长)的一块就是 reconciliation(简单的可以理解为 diff)，如果不 render，就不会 reconciliation。</strong></li>
<li><strong>减少计算的量。主要是减少重复计算，对于函数式组件来说，每次 render 都会重新从头开始执行函数调用。</strong></li>
</ol>
<p>在使用类组件的时候，使用的 React 优化 API 主要是：<code>shouldComponentUpdate</code>和  <code>PureComponent</code>，这两个 API 所提供的解决思路都是为了<strong>减少重新 render 的次数</strong>，主要是减少父组件更新而子组件也更新的情况。</p>
<p>但是在函数式组件里面没有声明周期也没有类，那如何来做性能优化呢？</p>
<p><strong>先分个类，组件什么时候会重新执行？</strong></p>
<ol>
<li><strong>组件自己的状态改变</strong></li>
<li><strong>父组件重新渲染，导致子组件重新渲染，但是父组件的 props 没有改变</strong></li>
<li><strong>父组件重新渲染，导致子组件重新渲染，但是父组件传递的 props 改变</strong></li>
</ol>
<p>针对第二点，在FC中，可以通过memo减少rerender</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params">props</span>) &#123;</span><br><span class="line">   <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponent</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">Component</span>);</span><br></pre></td></tr></table></figure>

<p>通过 <code>React.memo</code> 包裹的组件在 props 不变的情况下，这个被包裹的组件是不会重新渲染的(相当于PureComonent)</p>
<p>默认情况下其只会对 props 的复杂对象做浅层对比(浅层对比就是只会对比前后两次 props 对象引用是否相同，不会对比对象里面的内容是否相同)，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">areEqual</span>(<span class="params">prevProps, nextProps</span>) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果把 nextProps 传入 render 方法的返回结果与</span></span><br><span class="line"><span class="comment">  将 prevProps 传入 render 方法的返回结果一致则返回 true，</span></span><br><span class="line"><span class="comment">  否则返回 false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">MyComponent</span>, areEqual);</span><br></pre></td></tr></table></figure>

<h3 id="组件性能优化"><a href="#组件性能优化" class="headerlink" title="组件性能优化"></a>组件性能优化</h3><p>React 组件是一个树形结构，且每个节点都是懒计算的（类似于 Thunk 的概念）。当一个节点不需要重新计算（重绘）时，他的子树都不会计算（重绘）。<strong>所以我们做性能优化的目标，就是在尽量离根节点近的位置，拦截不必要的节点重算，从而减少重绘的计算量。</strong></p>
<h5 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h5><p>阻止节点重绘主要通过 React.memo 方法生成特殊的组件节点。它接受两个传参：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">Component</span>, areEqual);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Component：组件</p>
</li>
<li><p>areEqual：比较函数<br>比较函数的入参有两个，arg0 为 前一次渲染的 props, arg1 为本次渲染的 props。如果返回 true，则该节点本次渲染将被标记为无需重新计算，从而使其所有子节点、孙子节点都无需计算。<br>areEqual 如果不传，默认使用</p>
</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">prevProps</span>, nextProps) =&gt; shallowEqual(<span class="name">prevProps</span>, nextProps)</span><br></pre></td></tr></table></figure>

<p>做为比较函数。</p>
<h5 id="如何定位优化点"><a href="#如何定位优化点" class="headerlink" title="如何定位优化点"></a>如何定位优化点</h5><p>使用前一章节提到 React DevTools 中的 Profiling 功能，record 发生卡顿的操作，从耗时长的组件逐个查看，找到那些跟此次操作无关的上层渲染节点，尝试使用 React.memo 包裹这些组件。</p>
<h5 id="不要为了优化而优化"><a href="#不要为了优化而优化" class="headerlink" title="不要为了优化而优化"></a>不要为了优化而优化</h5><p>在没有性能问题前，不用去纠结是否要用 Profiling、React.memo、useMemo、useCallback 去优化性能，这些不一定能带来性能提升，反而肯定会带来首屏的性能下降。大多数情况下，React 现有算法以能满足性能需求。</p>
<h5 id="对于一个组件，有三样东西会让她重绘"><a href="#对于一个组件，有三样东西会让她重绘" class="headerlink" title="对于一个组件，有三样东西会让她重绘"></a>对于一个组件，有三样东西会让她重绘</h5><ol>
<li>State 变更</li>
<li>依赖的 context 变更</li>
<li>父组件重绘</li>
</ol>
<p>所以用 React.memo 包裹之后，并不是说性能就会有多大的提高。如果组件中依赖的 context 中，有一部分并不是此组件需要的数据，但会经常变更，也会导致组件经常重绘。这时候我们可以增加一层组件，把依赖 context 中的数据，通过增加的一层父组件取出来，然后通过 props 传给真正渲染的组件，把 React.memo 加在真正渲染的组件上，来达到屏蔽 context 变更引起的重绘问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useMemo, useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">SomeContext</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./SomeContext&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">PickContextData</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = <span class="title function_">useContext</span>(<span class="title class_">SomeContext</span>);</span><br><span class="line">  <span class="keyword">const</span> someDataFromContext = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ctx.<span class="property">data</span>;</span><br><span class="line">  &#125;, [ctx.<span class="property">data</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">RenderComponent</span> <span class="attr">data</span>=<span class="string">&#123;someDataFromContext&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">RenderComponent</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 略</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>更通用点，可以封装出 react-redux 的 connect 函数，传入 selector 来取所需的 Context 数据。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Hooks</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React组件通信</title>
    <url>/2021/10/07/React%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><h5 id="爷孙组件通信"><a href="#爷孙组件通信" class="headerlink" title="爷孙组件通信"></a>爷孙组件通信</h5><p>爷孙组件通信主要有 3 种方式：</p>
<ol>
<li>将孙子组件的 props 封装在一个固定字段中</li>
<li>通过 children 透传</li>
<li>通过 context 传递</li>
</ol>
<p>假设有个三层组件，爷爷分别给儿子和孙子发红包</p>
<p>先看青铜解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Grandpa</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [someMoneyForMe] = <span class="title function_">useState</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">const</span> [someMoneyForDaddy] = <span class="title function_">useState</span>(<span class="number">101</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Daddy</span> <span class="attr">money</span>=<span class="string">&#123;someMoneyForDaddy&#125;</span> <span class="attr">moneyForSon</span>=<span class="string">&#123;someMoneyForMe&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Daddy</span>(<span class="params">props: &#123; money: number; moneyForSon: number &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; money, moneyForSon &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;daddy&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>This is Daddy, received $&#123;money&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Me</span> <span class="attr">money</span>=<span class="string">&#123;moneyForSon&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Me</span>(<span class="params">props: &#123; money: number &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; money &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>This is Me, received $&#123;money&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Daddy 组件会透传爷爷给孙子的组件给 Me。这种方案的缺点很明显，以后爷爷要给 Daddy 和 Me 发糖果的时候，Daddy 还得加字段。</p>
<p><strong>将孙子组件的 props 封装在一个固定字段中</strong></p>
<p>按照 1 的方案，我们可以固定给 Daddy 添加一个 sonProps 的字段，然后将 Grandpa 需要传给孙子的状态全部通过 sonProps 传递</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Grandpa</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [someMoneyForMe] = <span class="title function_">useState</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">const</span> [someMoneyForDaddy] = <span class="title function_">useState</span>(<span class="number">101</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Daddy</span> <span class="attr">money</span>=<span class="string">&#123;someMoneyForDaddy&#125;</span> <span class="attr">sonProps</span>=<span class="string">&#123;&#123;money:</span> <span class="attr">someMoneyForMe</span>&#125;&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Daddy</span>(<span class="params">props: &#123; money: number; sonProps: Parameters&lt;<span class="keyword">typeof</span> Me&gt;[<span class="number">0</span>]; &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; money, sonProps &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;daddy&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>This is Daddy, received $&#123;money&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Me</span> &#123;<span class="attr">...sonProps</span>&#125;/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Me</span>(<span class="params">props: &#123; money: number &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; money &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>This is Me, received $&#123;money&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样以后要给 Me 加字段，就不用改 Daddy 了。<strong>但要测试 Daddy 时还得 mock Me 组件的数据，Daddy 和 Son 耦合。</strong></p>
<p><strong>通过 children 透传</strong></p>
<p>children 类似于 vue 中的 slot，可以完成一些嵌套组件通信的功能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Grandpa</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [someMoneyForMe] = <span class="title function_">useState</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">const</span> [someMoneyForDaddy] = <span class="title function_">useState</span>(<span class="number">101</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Daddy</span> <span class="attr">money</span>=<span class="string">&#123;someMoneyForDaddy&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Me</span> <span class="attr">money</span>=<span class="string">&#123;someMoneyForMe&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Daddy</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Daddy</span>(<span class="params">props: &#123; money: number; children?: React.ChildNode &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; money, children &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;daddy&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>This is Daddy, received $&#123;money&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Me</span>(<span class="params">props: &#123; money: number &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; money &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>This is Me, received $&#123;money&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 Daddy 的嵌套部分用 children 替代后，解耦了子组件和孙子组件的依赖关系，Daddy 组件更加独立。</p>
<p>作为替代，也可以传递一个组件实例：</p>
<p><code><Daddy money=&#123;someMoneyForDaddy&#125; me=&#123;<Me money=&#123;someMoneyForMe&#125; /> </code></p>
<p><strong>三种方案的决策</strong></p>
<ol>
<li>第一种方案一般用于固定结构和跨组件有互相依赖的场景，多见于 UI 框架中的复合组件与原子组件的设计中</li>
<li>第二种常用在嵌套层级不深的业务代码中，比如表单场景。<strong>优点是顶层 Grandpa 的业务收敛度很高，一眼能看清 UI 结构及状态绑定关系，相当于拍平了 React 组件树</strong></li>
<li>第三种比较通用，适合复杂嵌套透传场景。缺点是范式代码较多，且会造成 react dev tools 层级过多；Context 无法在父组件看出依赖关系，必须到子组件文件中才能知道数据来源</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Hooks</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>TradingView使用</title>
    <url>/2025/06/05/TradingView%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="TradingView-自定义Plugin使用"><a href="#TradingView-自定义Plugin使用" class="headerlink" title="TradingView 自定义Plugin使用"></a>TradingView 自定义Plugin使用</h2><p>结合官方文档：<a href="https://tradingview.github.io/lightweight-charts/docs/plugins/intro">https://tradingview.github.io/lightweight-charts/docs/plugins/intro</a> 食用</p>
<h4 id="1-Series-Primitives"><a href="#1-Series-Primitives" class="headerlink" title="1. Series Primitives"></a>1. Series Primitives</h4><ol>
<li>生命周期<ul>
<li>attached：添加到图表时触发，附加方法通过一个参数调用，该参数包含图表、系列以及用于请求更新的回调函数</li>
<li>detached：移除图表时触发</li>
</ul>
</li>
<li>更新视图<br>您的原语应该在方法中更新视图 updateAllViews()，以便渲染器被调用时，它们能够使用最新信息进行绘制。当库需要更新和重绘图表时，它会调用此方法。如果您想通知库应该触发更新，可以使用requestUpdate附加生命周期方法提供的回调。</li>
</ol>
<p>该接口会调用一下getter来绘制视图</p>
<ul>
<li>paneViews</li>
<li>priceAxisPaneViews</li>
<li>timeAxisPaneViews</li>
<li>priceAxisViews</li>
<li>timeAxisViews</li>
</ul>
<h4 id="2-Views"><a href="#2-Views" class="headerlink" title="2. Views"></a>2. Views</h4><p>该接口可用于定义一个视图，该视图提供一个渲染器（实现该 接口），以便使用CanvasRenderingContext2DIPrimitivePaneRenderer API 在图表的相应区域进行绘制 </p>
<h4 id="3-Renderer"><a href="#3-Renderer" class="headerlink" title="3. Renderer"></a>3. Renderer</h4><ul>
<li>draw方法<br>渲染器提供了一个接口，在该接口上应执行CanvasRenderingTarget2D绘图逻辑（使用 浏览器的 2D Canvas API ）。由Fancy CanvasCanvasRenderingTarget2D库提供 。</li>
</ul>
<h4 id="CanvasRenderingTarget2D"><a href="#CanvasRenderingTarget2D" class="headerlink" title="CanvasRenderingTarget2D"></a>CanvasRenderingTarget2D</h4><p>CanvasRenderingTarget2D提供了两个可以使用的渲染范围：</p>
<p>useMediaCoordinateSpace<br>useBitmapCoordinateSpace</p>
<h4 id="useMediaCoordinateSpace和useBitmapCoordinateSpace的区别"><a href="#useMediaCoordinateSpace和useBitmapCoordinateSpace的区别" class="headerlink" title="useMediaCoordinateSpace和useBitmapCoordinateSpace的区别"></a>useMediaCoordinateSpace和useBitmapCoordinateSpace的区别</h4><ul>
<li><p>useBitmapCoordinateSpace如果您想使用实际设备像素作为坐标尺寸进行绘制，可以使用 。提供的范围（类型为 BitmapCoordinatesRenderingScope）包含以下只读值：</p>
<ul>
<li>context （CanvasRenderingContext2D）。可用于渲染的上下文。</li>
<li>horizontalPixelRatio（数字）</li>
<li>verticalPixelRatio（数字）</li>
<li>bitmapSize（尺寸）。位图尺寸中画布的高度和宽度。</li>
<li>mediaSize（尺寸）。画布在媒体尺寸中的高度和宽度。</li>
</ul>
</li>
<li><p>useMediaCoordinateSpace如果您想使用媒体尺寸作为坐标大小进行绘制，可以使用 。提供的范围（类型为 MediaCoordinatesRenderingScope）包含以下只读值：</p>
<ul>
<li>context （CanvasRenderingContext2D）。可用于渲染的上下文。</li>
<li>mediaSize（尺寸）。画布在媒体尺寸中的高度和宽度。</li>
</ul>
</li>
</ul>
<h3 id="自定义Plugin实践-k线图上绘制用户头像"><a href="#自定义Plugin实践-k线图上绘制用户头像" class="headerlink" title="自定义Plugin实践 - k线图上绘制用户头像"></a>自定义Plugin实践 - k线图上绘制用户头像</h3><p><img src="/../assets/trading-view-plugin-demo.png" alt="DEMO示例"></p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>工程化</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux</title>
    <url>/2021/10/11/Redux/</url>
    <content><![CDATA[<h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><ul>
<li>（1）Web 应用是一个状态机，视图与状态是一一对应的。</li>
<li>（2）所有的状态，保存在一个对象里面。</li>
</ul>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><ol>
<li><p>Action 就是 View 发出的通知，表示 State 应该要发生变化了。</p>
</li>
<li><p>Action 是一个对象，其中的<code>type</code>属性是必须的，表示 Action 的名称，Action 描述当前发生的事情。</p>
</li>
<li><p>改变 State 的唯一办法，就是使用 Action。</p>
</li>
</ol>
<p>可以定义一个函数来生成 Action，这个函数就叫 Action Creator，示例如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">ADD_TODO</span> = <span class="string">&#x27;添加 TODO&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTodo</span>(<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="variable constant_">ADD_TODO</span>,</span><br><span class="line">    text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> action = <span class="title function_">addTodo</span>(<span class="string">&#x27;Learn Redux&#x27;</span>);</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><ol>
<li><p>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</p>
</li>
<li><p>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;init&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state = initState, action</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reducer:&#x27;</span>, state, action);</span><br><span class="line">    <span class="keyword">switch</span>(action.<span class="property">type</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;send_type&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, state, action);</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><h4 id="store-subscribe"><a href="#store-subscribe" class="headerlink" title="store.subscribe()"></a>store.subscribe()</h4><p>添加一个变化监听器。每当 <code>dispatch action</code> 的时候就会执行，<code>state</code> 树中的一部分可能已经变化。可以在回调函数里调用<code>getState()</code>来拿到当前 <code>state</code>，并且让<code>View</code>重新渲染<br>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">listerner</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newState = store.<span class="title function_">getState</span>();</span><br><span class="line">  component.<span class="title function_">setState</span>(newState);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="store-dispatch"><a href="#store-dispatch" class="headerlink" title="store.dispatch()"></a>store.dispatch()</h4><p><code>store.dispatch()</code>是 <code>View</code> 发出 <code>Action</code> 的唯一方法，将使用当前 <code>getState()</code>的结果和传入的 <code>action</code> 以同步方式的调用 <code>store</code> 的 <code>reducer</code> 函数。它的返回值会被作为下一个 <code>state</code>。从现在开始，这就成为了 <code>getState()</code>的返回值，同时变化监听器(change listener)会被触发。</p>
<blockquote>
</blockquote>
<ul>
<li><p>流程：</p>
<p>组件 – <code>store.dispatch(action)</code> – 触发reducer的执行 – 根据type区分返回的state – 返回值给store – 更新state – <code>store.subscribe(listener)</code>中listener回调函数执行。</p>
</li>
</ul>
<p><img src="/../assets/image-20210309183756689.png" alt="image-20210309183756689"></p>
<h2 id="中间件和异步操作"><a href="#中间件和异步操作" class="headerlink" title="中间件和异步操作"></a>中间件和异步操作</h2><h3 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a>中间件的概念</h3><p>本质上就是对原方法进行了重定义，以<code>redux-logger</code>为例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> next = store.<span class="property">dispatch</span>;</span><br><span class="line">store.<span class="property">dispatch</span> = <span class="keyword">function</span> <span class="title function_">dispatchAndLog</span>(<span class="params">action</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;dispatching&#x27;</span>, action);</span><br><span class="line">  <span class="title function_">next</span>(action);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next state&#x27;</span>, store.<span class="title function_">getState</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中间件的用法"><a href="#中间件的用法" class="headerlink" title="中间件的用法"></a>中间件的用法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; applyMiddleware, createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> createLogger <span class="keyword">from</span> <span class="string">&#x27;redux-logger&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> logger = <span class="title function_">createLogger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(</span><br><span class="line">  reducer,</span><br><span class="line">  <span class="comment">// 中间件的次序有要求</span></span><br><span class="line">  <span class="title function_">applyMiddleware</span>(thunk, promise, logger)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="异步操作的思路"><a href="#异步操作的思路" class="headerlink" title="异步操作的思路"></a>异步操作的思路</h3><blockquote>
<p>同步操作只需要一种<code>Action</code>，而异步操作需要发出三种<code>Action</code></p>
</blockquote>
<ul>
<li>操作发起时的 <code>Action</code></li>
<li>操作成功时的 <code>Action</code></li>
<li>操作失败时的 <code>Action</code></li>
</ul>
<blockquote>
<p>异步操作的 <code>State</code> 也要进行改造，整个过程如下</p>
</blockquote>
<ul>
<li>操作开始时，送出一个 <code>Action</code>，触发 <code>State</code> 更新为”正在操作”状态，<code>View</code> 重新渲染</li>
<li>操作结束后，再送出一个 <code>Action</code>，触发 <code>State</code> 更新为”操作结束”状态，<code>View</code> 再一次重新渲染</li>
</ul>
<h3 id="Redux-thunk中间件"><a href="#Redux-thunk中间件" class="headerlink" title="Redux-thunk中间件"></a>Redux-thunk中间件</h3><h2 id="React-redux"><a href="#React-redux" class="headerlink" title="React-redux"></a>React-redux</h2><h3 id="UI组件和容器组件"><a href="#UI组件和容器组件" class="headerlink" title="UI组件和容器组件"></a>UI组件和容器组件</h3><h3 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h3><p><img src="/../assets/image-20210309200347890.png" alt="image-20210309200347890"></p>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p><code>connect</code>方法接受两个参数：<code>mapStateT.oProps</code>和<code>mapDispatchToProps</code>。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将<code>state</code>映射到 UI 组件的参数（<code>props</code>），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。</p>
<ul>
<li><h4 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps"></a><code>mapStateToProps</code></h4><p><code>mapStateToProps</code>是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）<code>state</code>对象到（UI 组件的）<code>props</code>对象的映射关系。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mapStateToProps</span> = (<span class="params">state</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">todos</span>: <span class="title function_">getVisibleTodos</span>(state.<span class="property">todos</span>, state.<span class="property">visibilityFilter</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mapStateToProps</code>会订阅 Store，每当<code>state</code>更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p>
<p><code>mapStateToProps</code>的第一个参数总是<code>state</code>对象，还可以使用第二个参数，代表容器组件的<code>props</code>对象。</p>
<p><code>connect</code>方法可以省略<code>mapStateToProps</code>参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新。</p>
</li>
<li><h4 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a><code>mapDispatchToProps</code></h4><p><code>mapDispatchToProps</code>是<code>connect</code>函数的第二个参数，用来建立 UI 组件的参数到<code>store.dispatch</code>方法的映射</p>
<p>如果<code>mapDispatchToProps</code>是一个函数，会得到<code>dispatch</code>和<code>ownProps</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mapDispatchToProps</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  dispatch,</span></span><br><span class="line"><span class="params">  ownProps</span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">onClick</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">dispatch</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>,</span><br><span class="line">        <span class="attr">filter</span>: ownProps.<span class="property">filter</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>mapDispatchToProps</code>是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出(dispatch).</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123;</span><br><span class="line">  <span class="attr">onClick</span>: <span class="function">(<span class="params">filter</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>,</span><br><span class="line">    <span class="attr">filter</span>: filter</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="计数器Demo："><a href="#计数器Demo：" class="headerlink" title="计数器Demo："></a>计数器Demo：</h3><p>  两个组件，按钮ComA和文本ComB，点击按钮+1，用react-redux实现通信的过程</p>
<p><img src="/../assets/image-20210310173423401.png" alt="image-20210310173423401"></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript入门</title>
    <url>/2021/10/14/Typescript%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="TypeScript简介"><a href="#TypeScript简介" class="headerlink" title="TypeScript简介"></a>TypeScript简介</h3><ol>
<li>TypeScript是JavaScript的超集。</li>
<li>它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。</li>
<li>TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。</li>
<li>TS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。</li>
<li>相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。</li>
</ol>
<h3 id="TypeScript-开发环境搭建"><a href="#TypeScript-开发环境搭建" class="headerlink" title="TypeScript 开发环境搭建"></a>TypeScript 开发环境搭建</h3><ol>
<li><p>下载Node.js</p>
<ul>
<li>64位：<a href="https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi">https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi</a></li>
<li>32位：<a href="https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi">https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi</a></li>
</ul>
</li>
<li><p>安装Node.js</p>
</li>
<li><p>使用npm全局安装typescript</p>
<ul>
<li>进入命令行</li>
<li>输入：npm i -g typescript</li>
</ul>
</li>
<li><p>创建一个ts文件</p>
</li>
<li><p>使用tsc对ts文件进行编译</p>
<ul>
<li><p>进入命令行</p>
</li>
<li><p>进入ts文件所在目录</p>
</li>
<li><p>执行命令：tsc xxx.ts</p>
</li>
</ul>
</li>
</ol>
 <span id="more"></span>    

<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><h5 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h5><ul>
<li><p>类型声明是TS非常重要的一个特点</p>
</li>
<li><p>通过类型声明可以指定TS中变量（参数、形参）的类型</p>
</li>
<li><p>指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错</p>
</li>
<li><p>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值</p>
</li>
<li><p>语法：</p>
<ul>
<li><pre><code class="typescript">let 变量: 类型;

let 变量: 类型 = 值;

function fn(参数: 类型, 参数: 类型): 类型&#123;
    ...
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 自动类型判断</span><br><span class="line"></span><br><span class="line">- TS拥有自动的类型判断机制</span><br><span class="line">- 当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型</span><br><span class="line">- 所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 类型</span><br><span class="line"></span><br><span class="line">|  类型   |       例子        |              描述              |</span><br><span class="line">| :-----: | :---------------: | :----------------------------: |</span><br><span class="line">| number  |    1, -33, 2.5    |            任意数字            |</span><br><span class="line">| string  | &#x27;hi&#x27;, &quot;hi&quot;, `hi`  |           任意字符串           |</span><br><span class="line">| boolean |    true、false    |       布尔值true或false        |</span><br><span class="line">| 字面量  |      其本身       |  限制变量的值就是该字面量的值  |</span><br><span class="line">|   any   |         *         |            任意类型            |</span><br><span class="line">| unknown |         *         |         类型安全的any          |</span><br><span class="line">|  void   | 空值（undefined） |     没有值（或undefined）      |</span><br><span class="line">|  never  |      没有值       |          不能是任何值          |</span><br><span class="line">| object  |  &#123;name:&#x27;孙悟空&#x27;&#125;  |          任意的JS对象          |</span><br><span class="line">|  array  |      [1,2,3]      |           任意JS数组           |</span><br><span class="line">|  tuple  |       [4,5]       | 元素，TS新增类型，固定长度数组 |</span><br><span class="line">|  enum   |    enum&#123;A, B&#125;     |       枚举，TS中新增类型       |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### **enum 枚举类型**</span><br><span class="line"></span><br><span class="line">- ```typescript</span><br><span class="line">  enum Color &#123;</span><br><span class="line">    Red = 0,</span><br><span class="line">    Green,</span><br><span class="line">    Blue,</span><br><span class="line">  &#125;</span><br><span class="line">  // 使用</span><br><span class="line">  const red = Color.Red;</span><br><span class="line">  const green = Color.Green;</span><br><span class="line">  </span><br><span class="line">  // 编译成js后，枚举类型实际上是一个双向键值对对象（可以通过键获取值也可以通过值获取键）</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  var Color;</span><br><span class="line">  (function (Color) &#123;</span><br><span class="line">      Color[Color[&quot;Red&quot;] = 0] = &quot;Red&quot;;</span><br><span class="line">      Color[Color[&quot;Green&quot;] = 1] = &quot;Green&quot;;</span><br><span class="line">      Color[Color[&quot;Blue&quot;] = 2] = &quot;Blue&quot;;</span><br><span class="line">  &#125;)(Color || (Color = &#123;&#125;));</span><br><span class="line">  // 使用</span><br><span class="line">  const red = Color.Red;</span><br><span class="line">  const green = Color.Green;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>定义常量枚举（只能通过键获取值）</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> red = <span class="title class_">Color</span>.<span class="property">Red</span>;</span><br><span class="line"><span class="keyword">const</span> green = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译成js</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> red = <span class="number">0</span> <span class="comment">/* Red */</span>;</span><br><span class="line"><span class="keyword">const</span> green = <span class="number">1</span> <span class="comment">/* Green */</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="定义函数类型"><a href="#定义函数类型" class="headerlink" title="定义函数类型"></a>定义函数类型</h5><ul>
<li><pre><code class="typescript">// 箭头函数可以以这种形式定义
const add: (a: number, b: number) =&gt; number = (a, b) =&gt; &#123;
    return a + b;
&#125;;

// 也可以这种形式
interface Iadd &#123;
    (x: number, y: number): number;
&#125;
const add: Iadd = (a, b) =&gt; &#123;
    return a + b;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 类型别名</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;..\Picture\image-20220225230844666.png&quot; alt=&quot;image-20220225230844666&quot; style=&quot;zoom:23%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 类型断言</span><br><span class="line"></span><br><span class="line">- 有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：</span><br><span class="line"></span><br><span class="line">  - 第一种</span><br><span class="line"></span><br><span class="line">    - ```typescript</span><br><span class="line">      let someValue: unknown = &quot;this is a string&quot;;</span><br><span class="line">      let strLength: number = (someValue as string).length;</span><br></pre></td></tr></table></figure>

- 第二种

  - ```typescript
    let someValue: unknown = &quot;this is a string&quot;;
    let strLength: number = (&lt;string&gt;someValue).length;
    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 类型保卫与类型守护</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;..\assets\image-20220225231806225.png&quot; alt=&quot;image-20220225231806225&quot; style=&quot;zoom:25%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;..\assets\image-20220225232035688.png&quot; alt=&quot;image-20220225232035688&quot; style=&quot;zoom:25%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;..\assets\image-20220225232336109.png&quot; alt=&quot;image-20220225232336109&quot; style=&quot;zoom:25%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">##### d.ts文件/declare</span><br><span class="line"></span><br><span class="line">+ 安装第三方模块（例如lodash）时</span><br><span class="line"></span><br><span class="line">![image-20220225193949940](..\assets\image-20220225193949940.png)</span><br><span class="line"></span><br><span class="line">原因是lodash是使用js编写的，没有类型声明，如下，camelCase函数没有类型声明</span><br><span class="line"></span><br><span class="line">```typescript</span><br><span class="line">import &#123; camelCase &#125; from &#x27;lodash&#x27;;</span><br><span class="line">const res = camelCase(&#x27;hello guy&#x27;)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>这时候可以使用<strong>declare</strong>（其实就是一个成员在定义的时候没有声明，比如node装第三方模块，大部分都是js写的，这时候使用declare做一个单独的声明）对函数声明</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; camelCase &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">camelCase</span>(<span class="params"><span class="attr">input</span>: <span class="built_in">string</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="title function_">camelCase</span>(<span class="string">&#x27;hello guy&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>其他解决方案：</strong>安装d.ts文件（专门用来做类型声明的文件，应该为开发依赖）</p>
<h3 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h3><ul>
<li><p>自动编译文件</p>
<ul>
<li><p>编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。</p>
</li>
<li><p>示例：</p>
<ul>
<li>powershell<br>tsc xxx.ts -w</li>
</ul>
</li>
</ul>
</li>
<li><p>自动编译整个项目</p>
<ul>
<li><p>如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。</p>
</li>
<li><p>但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json</p>
</li>
<li><p>tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译</p>
</li>
<li><p>配置选项：</p>
<ul>
<li><p>include</p>
<ul>
<li><p>定义希望被编译文件所在的目录</p>
</li>
<li><p>默认值：[“**&#x2F;*“]</p>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="json">&quot;include&quot;:[&quot;src/**/*&quot;, &quot;tests/**/*&quot;]
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 上述示例中，所有src目录和tests目录下的文件都会被编译</span><br><span class="line"></span><br><span class="line">- exclude</span><br><span class="line"></span><br><span class="line">  - 定义需要排除在外的目录</span><br><span class="line"></span><br><span class="line">  - 默认值：[&quot;node_modules&quot;, &quot;bower_components&quot;, &quot;jspm_packages&quot;]</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;exclude&quot;: [&quot;./src/hello/**/*&quot;]</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>上述示例中，src下hello目录下的文件都不会被编译</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>extends</p>
<ul>
<li><p>定义被继承的配置文件</p>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="json">&quot;extends&quot;: &quot;./configs/base&quot;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息</span><br><span class="line"></span><br><span class="line">- files</span><br><span class="line"></span><br><span class="line">  - 指定被编译文件的列表，只有需要编译的文件少时才会用到</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;files&quot;: [</span><br><span class="line">          &quot;core.ts&quot;,</span><br><span class="line">          &quot;sys.ts&quot;,</span><br><span class="line">          &quot;types.ts&quot;,</span><br><span class="line">          &quot;scanner.ts&quot;,</span><br><span class="line">          &quot;parser.ts&quot;,</span><br><span class="line">          &quot;utilities.ts&quot;,</span><br><span class="line">          &quot;binder.ts&quot;,</span><br><span class="line">          &quot;checker.ts&quot;,</span><br><span class="line">          &quot;tsc.ts&quot;</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>列表中的文件都会被TS编译器所编译</p>
</li>
</ul>
</li>
<li><p>compilerOptions</p>
<ul>
<li><p>编译选项是配置文件中非常重要也比较复杂的配置选项</p>
</li>
<li><p>在compilerOptions中包含多个子选项，用来完成对编译的配置</p>
<ul>
<li><p>项目选项</p>
<ul>
<li><p>target</p>
<ul>
<li><p>设置ts代码编译的目标版本</p>
</li>
<li><p>可选值：</p>
<ul>
<li>ES3（默认）、ES5、ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES2017、ES2018、ES2019、ES2020、ESNext</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="json">&quot;compilerOptions&quot;: &#123;
    &quot;target&quot;: &quot;ES6&quot;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码</span><br><span class="line"></span><br><span class="line">- lib</span><br><span class="line"></span><br><span class="line">  - 指定代码运行时所包含的库（宿主环境）</span><br><span class="line"></span><br><span class="line">  - 可选值：</span><br><span class="line"></span><br><span class="line">    - ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;compilerOptions&quot;: &#123;</span><br><span class="line">          &quot;target&quot;: &quot;ES6&quot;,</span><br><span class="line">          &quot;lib&quot;: [&quot;ES6&quot;, &quot;DOM&quot;],</span><br><span class="line">          &quot;outDir&quot;: &quot;dist&quot;,</span><br><span class="line">          &quot;outFile&quot;: &quot;dist/aa.js&quot;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>module</p>
<ul>
<li><p>设置编译后代码使用的模块化系统</p>
</li>
<li><p>可选值：</p>
<ul>
<li>CommonJS、UMD、AMD、System、ES2020、ESNext、None</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="typescript">&quot;compilerOptions&quot;: &#123;
    &quot;module&quot;: &quot;CommonJS&quot;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- outDir</span><br><span class="line"></span><br><span class="line">  - 编译后文件的所在目录</span><br><span class="line"></span><br><span class="line">  - 默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;compilerOptions&quot;: &#123;</span><br><span class="line">          &quot;outDir&quot;: &quot;dist&quot;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>设置后编译后的js文件将会生成到dist目录</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>outFile</p>
<ul>
<li><p>将所有的文件编译为一个js文件</p>
</li>
<li><p>默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中</p>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="json">&quot;compilerOptions&quot;: &#123;
    &quot;outFile&quot;: &quot;dist/app.js&quot;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- rootDir</span><br><span class="line"></span><br><span class="line">  - 指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;compilerOptions&quot;: &#123;</span><br><span class="line">          &quot;rootDir&quot;: &quot;./src&quot;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>allowJs</p>
<ul>
<li>是否对js文件编译</li>
</ul>
</li>
<li><p>checkJs</p>
<ul>
<li><p>是否对js文件进行检查</p>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="json">&quot;compilerOptions&quot;: &#123;
    &quot;allowJs&quot;: true,
    &quot;checkJs&quot;: true
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">            - removeComments</span><br><span class="line"></span><br><span class="line">              - 是否删除注释</span><br><span class="line">              - 默认值：false</span><br><span class="line"></span><br><span class="line">            - noEmit</span><br><span class="line"></span><br><span class="line">              - 不对代码进行编译</span><br><span class="line">              - 默认值：false</span><br><span class="line"></span><br><span class="line">            - sourceMap</span><br><span class="line"></span><br><span class="line">              - 是否生成sourceMap</span><br><span class="line">              - 默认值：false</span><br><span class="line"></span><br><span class="line">              </span><br><span class="line"></span><br><span class="line">          - 严格检查</span><br><span class="line"></span><br><span class="line">            - strict</span><br><span class="line">              - 启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查</span><br><span class="line">            - alwaysStrict</span><br><span class="line">              - 总是以严格模式对代码进行编译</span><br><span class="line">            - noImplicitAny</span><br><span class="line">              - 禁止隐式的any类型</span><br><span class="line">            - noImplicitThis</span><br><span class="line">              - 禁止类型不明确的this</span><br><span class="line">            - strictBindCallApply</span><br><span class="line">              - 严格检查bind、call和apply的参数列表</span><br><span class="line">            - strictFunctionTypes</span><br><span class="line">              - 严格检查函数的类型</span><br><span class="line">            - strictNullChecks</span><br><span class="line">              - 严格的空值检查</span><br><span class="line">            - strictPropertyInitialization</span><br><span class="line">              - 严格检查属性是否初始化</span><br><span class="line"></span><br><span class="line">          - 额外检查</span><br><span class="line"></span><br><span class="line">            - noFallthroughCasesInSwitch</span><br><span class="line">              - 检查switch语句包含正确的break</span><br><span class="line">            - noImplicitReturns</span><br><span class="line">              - 检查函数没有隐式的返回值</span><br><span class="line">            - noUnusedLocals</span><br><span class="line">              - 检查未使用的局部变量</span><br><span class="line">            - noUnusedParameters</span><br><span class="line">              - 检查未使用的参数</span><br><span class="line"></span><br><span class="line">          - 高级</span><br><span class="line"></span><br><span class="line">            - allowUnreachableCode</span><br><span class="line">              - 检查不可达代码</span><br><span class="line">              - 可选值：</span><br><span class="line">                - true，忽略不可达代码</span><br><span class="line">                - false，不可达代码将引起错误</span><br><span class="line">            - noEmitOnError</span><br><span class="line">              - 有错误的情况下不进行编译</span><br><span class="line">              - 默认值：false</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line"></span><br><span class="line">### webpack</span><br><span class="line"></span><br><span class="line">- 通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。</span><br><span class="line"></span><br><span class="line">- 步骤：</span><br><span class="line"></span><br><span class="line">  1. 初始化项目</span><br><span class="line"></span><br><span class="line">     - 进入项目根目录，执行命令 ``` npm init -y```</span><br><span class="line">       - 主要作用：创建package.json文件</span><br><span class="line"></span><br><span class="line">  2. 下载构建工具</span><br><span class="line"></span><br><span class="line">     - npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin</span><br><span class="line">       - 共安装了7个包</span><br><span class="line">         - webpack</span><br><span class="line">           - 构建工具webpack</span><br><span class="line">         - webpack-cli</span><br><span class="line">           - webpack的命令行工具</span><br><span class="line">         - webpack-dev-server</span><br><span class="line">           - webpack的开发服务器</span><br><span class="line">         - typescript</span><br><span class="line">           - ts编译器</span><br><span class="line">         - ts-loader</span><br><span class="line">           - ts加载器，用于在webpack中编译ts文件</span><br><span class="line">         - html-webpack-plugin</span><br><span class="line">           - webpack中html插件，用来自动创建html文件</span><br><span class="line">         - clean-webpack-plugin</span><br><span class="line">           - webpack中的清除插件，每次构建都会先清除目录</span><br><span class="line"></span><br><span class="line">  3. 根目录下创建webpack的配置文件webpack.config.js</span><br><span class="line"></span><br><span class="line">     - ```javascript</span><br><span class="line">       const path = require(&quot;path&quot;);</span><br><span class="line">       const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);</span><br><span class="line">       const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;);</span><br><span class="line">       </span><br><span class="line">       module.exports = &#123;</span><br><span class="line">           optimization:&#123;</span><br><span class="line">               minimize: false // 关闭代码压缩，可选</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           entry: &quot;./src/index.ts&quot;,</span><br><span class="line">           </span><br><span class="line">           devtool: &quot;inline-source-map&quot;,</span><br><span class="line">           </span><br><span class="line">           devServer: &#123;</span><br><span class="line">               contentBase: &#x27;./dist&#x27;</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           output: &#123;</span><br><span class="line">               path: path.resolve(__dirname, &quot;dist&quot;),</span><br><span class="line">               filename: &quot;bundle.js&quot;,</span><br><span class="line">               environment: &#123;</span><br><span class="line">                   arrowFunction: false // 关闭webpack的箭头函数，可选</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           resolve: &#123;</span><br><span class="line">               extensions: [&quot;.ts&quot;, &quot;.js&quot;]</span><br><span class="line">           &#125;,</span><br><span class="line">           </span><br><span class="line">           module: &#123;</span><br><span class="line">               rules: [</span><br><span class="line">                   &#123;</span><br><span class="line">                       test: /\.ts$/,</span><br><span class="line">                       use: &#123;</span><br><span class="line">                          loader: &quot;ts-loader&quot;     </span><br><span class="line">                       &#125;,</span><br><span class="line">                       exclude: /node_modules/</span><br><span class="line">                   &#125;</span><br><span class="line">               ]</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           plugins: [</span><br><span class="line">               new CleanWebpackPlugin(),</span><br><span class="line">               new HtmlWebpackPlugin(&#123;</span><br><span class="line">                   title:&#x27;TS测试&#x27;</span><br><span class="line">               &#125;),</span><br><span class="line">           ]</span><br><span class="line">       </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li><p>根目录下创建tsconfig.json，配置可以根据自己需要</p>
<ul>
<li><pre><code class="json">&#123;
    &quot;compilerOptions&quot;: &#123;
        &quot;target&quot;: &quot;ES2015&quot;,
        &quot;module&quot;: &quot;ES2015&quot;,
        &quot;strict&quot;: true
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. 修改package.json添加如下配置</span><br><span class="line"></span><br><span class="line">   - ```json</span><br><span class="line">     &#123;</span><br><span class="line">       ...略...</span><br><span class="line">       &quot;scripts&quot;: &#123;</span><br><span class="line">         &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">         &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">         &quot;start&quot;: &quot;webpack serve --open chrome.exe&quot;</span><br><span class="line">       &#125;,</span><br><span class="line">       ...略...</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>在src下创建ts文件，并在并命令行执行<code>npm run build</code>对代码进行编译，或者执行<code>npm start</code>来启动开发服务器</p>
</li>
</ol>
</li>
</ul>
<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><ul>
<li><p>经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合babel来对代码进行转换以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中。</p>
<ol>
<li><p>安装依赖包：</p>
<ul>
<li><code>npm i -D @babel/core @babel/preset-env babel-loader core-js</code></li>
<li>共安装了4个包，分别是：<ul>
<li>@babel&#x2F;core<ul>
<li>babel的核心工具</li>
</ul>
</li>
<li>@babel&#x2F;preset-env<ul>
<li>babel的预定义环境</li>
</ul>
</li>
<li>@babel-loader<ul>
<li>babel在webpack中的加载器</li>
</ul>
</li>
<li>core-js<ul>
<li>core-js用来使老版本的浏览器支持新版ES语法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>修改webpack.config.js配置文件</p>
<ul>
<li><pre><code class="javascript">...略...
module: &#123;
    rules: [
        &#123;
            test: /\.ts$/,
            use: [
                &#123;
                    loader: &quot;babel-loader&quot;,
                    options:&#123;
                        presets: [
                            [
                                &quot;@babel/preset-env&quot;,
                                &#123;
                                    &quot;targets&quot;:&#123;
                                        &quot;chrome&quot;: &quot;58&quot;,
                                        &quot;ie&quot;: &quot;11&quot;
                                    &#125;,
                                    &quot;corejs&quot;:&quot;3&quot;,
                                    &quot;useBuiltIns&quot;: &quot;usage&quot;
                                &#125;
                            ]
                        ]
                    &#125;
                &#125;,
                &#123;
                    loader: &quot;ts-loader&quot;,

                &#125;
            ],
            exclude: /node_modules/
        &#125;
    ]
&#125;
...略...
</code></pre>
</li>
<li><p>如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Web3相关学习</title>
    <url>/2024/10/29/Web3%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>先开个坑，准备下Web3相关的学习</p>
<h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><ul>
<li><strong>Web3入门计划</strong>： <a href="https://cubic-leaf-731.notion.site/web3-202208-09-1623ccd15c2148a1ae00ed8794d153b1">polebug大佬学习记录</a></li>
<li><strong>Web3开发学习路线</strong>： <a href="https://54web3.cc/blog/roadmap/learning-path-web3">https://54web3.cc/blog/roadmap/learning-path-web3</a></li>
<li><strong>Web3从入门到精通开发学习路线</strong>：<a href="https://juejin.cn/post/7307185531330838543">https://juejin.cn/post/7307185531330838543</a></li>
</ul>
<h3 id="WEEK-1-区块链的基础知识"><a href="#WEEK-1-区块链的基础知识" class="headerlink" title="WEEK 1: 区块链的基础知识"></a><strong>WEEK 1: 区块链的基础知识</strong></h3><ul>
<li>密码学基础</li>
<li>区块链基础</li>
<li>相关金融知识</li>
<li>学习比特币底层技术</li>
<li>学习以太坊原理</li>
</ul>
<!-- ![image-20241105](../assets/Week1：区块链基础知识.png) -->]]></content>
      <categories>
        <category>Web3/加密货币</category>
      </categories>
      <tags>
        <tag>Web3</tag>
        <tag>区块链</tag>
        <tag>智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack</title>
    <url>/2022/04/14/Webpack/</url>
    <content><![CDATA[<h3 id="Webpack-是什么"><a href="#Webpack-是什么" class="headerlink" title="Webpack 是什么"></a>Webpack 是什么</h3><p>webpack 是一种<strong>前端资源构建工具</strong>，一个静态模块打包器(module bundler)。</p>
<p>在webpack 看来, 前端的所有资源文件(js&#x2F;json&#x2F;css&#x2F;img&#x2F;less&#x2F;…)都会作为模块处理。<br>它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。</p>
<h3 id="Webpack-五个核心概念"><a href="#Webpack-五个核心概念" class="headerlink" title="Webpack 五个核心概念"></a>Webpack 五个核心概念</h3><h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><p>入口(Entry)：指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图。</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>输出(Output)：指示 webpack 打包后的资源 bundles 输出到哪里去，以及如何命名。</p>
<h4 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h4><p>Loader：让 webpack 能够去处理那些非 JS 的文件，比如样式文件、图片文件(webpack 自身只理解<br>JS)</p>
<h4 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h4><p>插件(Plugins)：可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，<br>一直到重新定义环境中的变量等。</p>
<span id="more"></span>

<h4 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h4><p>模式(Mode)：指示 webpack 使用相应模式的配置。</p>
<ol>
<li><p>development:  </p>
<p> 会将 DefinePlugin 中 <code>process.env.NODE_ENV</code> 的值设置为 development。</p>
<p>启用 </p>
<figure class="highlight plaintext"><figcaption><span>和 ```NamedModulesPlugin```。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   特点： 能让代码本地调试运行的环境。</span><br><span class="line"></span><br><span class="line">2. production</span><br><span class="line"></span><br><span class="line">   会将 DefinePlugin 中 ```process.env.NODE_ENV``` 的值设置为 production。</span><br><span class="line"></span><br><span class="line">   启用 </span><br><span class="line"></span><br><span class="line">   ```FlagDependencyUsagePlugin,```</span><br><span class="line"></span><br><span class="line">   ```FlagIncludedChunksPlugin,``` </span><br><span class="line"></span><br><span class="line">   ```ModuleConcatenationPlugin,``` </span><br><span class="line"></span><br><span class="line">   ```NoEmitOnErrorsPlugin,```</span><br><span class="line"></span><br><span class="line">    ```OccurrenceOrderPlugin,```</span><br><span class="line"></span><br><span class="line">   ```SideEffectsFlagPlugin 和 TerserPlugin```。</span><br><span class="line"></span><br><span class="line">   特点： 能让代码优化上线运行的环境。</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">### 编译打包应用</span><br><span class="line"></span><br><span class="line">创建 src 下的 js 等文件后，不需要配置 webpack.config.js 文件，在命令行就可以编译打包。</span><br><span class="line"></span><br><span class="line">指令：</span><br><span class="line"></span><br><span class="line">- 开发环境：</span><br><span class="line">```shell</span><br><span class="line">webpack ./src/index.js -o ./build/built.js --mode=development</span><br></pre></td></tr></table></figure></li>
</ol>
<p>  webpack会以 .&#x2F;src&#x2F;index.js 为入口文件开始打包，打包后输出到 .&#x2F;build&#x2F;built.js 整体打包环境，是开发环境</p>
<ul>
<li>生产环境：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">webpack ./src/index.js -o ./build/built.js --mode=production</span><br></pre></td></tr></table></figure>
webpack会以 .&#x2F;src&#x2F;index.js 为入口文件开始打包，打包后输出到 .&#x2F;build&#x2F;built.js 整体打包环境，是生产环境</li>
</ul>
<p>结论：</p>
<ol>
<li>webpack 本身能处理 js&#x2F;json 资源，不能处理 css&#x2F;img 等其他资源</li>
<li>生产环境和开发环境将 ES6 模块化编译成浏览器能识别的模块化，但是不能处理 ES6 的基本语法转化为 ES5（需要借助 loader）</li>
<li>生产环境比开发环境多一个压缩 js 代码</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// resolve用来拼接绝对路径的方法</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// webpack配置</span></span><br><span class="line">  <span class="comment">// 入口起点</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;built.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 输出路径</span></span><br><span class="line">    <span class="comment">// __dirname nodejs的变量，代表当前文件的目录绝对路径</span></span><br><span class="line">    <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// loader的配置</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 详细loader配置</span></span><br><span class="line">      <span class="comment">// 不同文件必须配置不同loader处理</span></span><br><span class="line">      &#123; </span><br><span class="line">        <span class="comment">// 匹配哪些文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// 使用哪些loader进行处理</span></span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="comment">// use数组中loader执行顺序：从右到左，从下到上 依次执行</span></span><br><span class="line">          <span class="comment">// 创建style标签，将js中的样式资源插入进行，添加到head中生效</span></span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// 将css文件变成commonjs模块加载js中，里面内容是样式字符串</span></span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// 将less文件编译成css文件</span></span><br><span class="line">          <span class="comment">// 需要下载 less-loader和less</span></span><br><span class="line">           <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// plugins的配置</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 详细plugins的配置</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 开发模式</span></span><br><span class="line">  <span class="comment">// mode: &#x27;production&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>打包工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack运行时runtime做了什么事情</title>
    <url>/2025/05/28/Webpack%E8%BF%90%E8%A1%8C%E6%97%B6runtime%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85/</url>
    <content><![CDATA[<h2 id="Webpack-Runtime"><a href="#Webpack-Runtime" class="headerlink" title="Webpack Runtime"></a>Webpack Runtime</h2><p>webpack 的 runtime，也就是 webpack 最后生成的代码，实现了一个自定义的模块加载系统，替代浏览器原生的模块机制：</p>
<p><strong>webpack_modules</strong>: 维护一个所有模块的数组。将入口模块解析为 AST，根据 AST 深度优先搜索所有的模块，并构建出这个模块数组。每个模块都由一个包裹函数 (module, module.exports, <strong>webpack_require</strong>) 对模块进行包裹构成。<br><strong>webpack_require</strong>(moduleId): 手动实现加载一个模块。对已加载过的模块进行缓存，对未加载过的模块，执行 id 定位到 <strong>webpack_modules</strong> 中的包裹函数，执行并返回 module.exports，并缓存<br><strong>webpack_require</strong>(0): 运行第一个模块，即运行入口模块<br>另外，当涉及到多个 chunk 的打包方式中，比如 code spliting，webpack 中会有 jsonp 加载 chunk 的运行时代码。</p>
<p>以下是 webpack runtime 的最简代码，配置示例可见 node-examples</p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>工程化</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>package lockfile的作用</title>
    <url>/2025/06/09/package.json%E5%92%8Clockfile%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h2 id="package-json-和-package-lock-json"><a href="#package-json-和-package-lock-json" class="headerlink" title="package.json 和 package-lock.json"></a>package.json 和 package-lock.json</h2>]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>工程化</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>require() 源码解读</title>
    <url>/2021/08/21/require%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【前端面试】JavaScript相关</title>
    <url>/2024/08/21/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%91JavaScript%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="let、const的区别"><a href="#let、const的区别" class="headerlink" title="let、const的区别"></a>let、const的区别</h3><ul>
<li>块级作用域</li>
<li>重复声明变量会报错</li>
<li>不能在声明前访问</li>
</ul>
<span id="more"></span>

<h3 id="Promise相关"><a href="#Promise相关" class="headerlink" title="Promise相关"></a>Promise相关</h3><ul>
<li>解决回调地狱的问题</li>
<li>异常穿透</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【前端面试】代码编程题</title>
    <url>/2024/08/21/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%91%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B%E9%A2%98/</url>
    <content><![CDATA[<h2 id="JavaScript-Coding"><a href="#JavaScript-Coding" class="headerlink" title="JavaScript Coding"></a>JavaScript Coding</h2><h3 id="数组去重方法"><a href="#数组去重方法" class="headerlink" title="数组去重方法"></a>数组去重方法</h3><h3 id="对象拷贝方法"><a href="#对象拷贝方法" class="headerlink" title="对象拷贝方法"></a>对象拷贝方法</h3><h3 id="数组交集、并集、差集"><a href="#数组交集、并集、差集" class="headerlink" title="数组交集、并集、差集"></a>数组交集、并集、差集</h3><h3 id="数组扁平"><a href="#数组扁平" class="headerlink" title="数组扁平"></a>数组扁平</h3><span id="more"></span>

<h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><h3 id="实现Promise"><a href="#实现Promise" class="headerlink" title="实现Promise"></a>实现Promise</h3><h3 id="实现一个new"><a href="#实现一个new" class="headerlink" title="实现一个new"></a>实现一个new</h3><p><strong>new的具体步骤</strong></p>
<ol>
<li>内存中创建一个新对象</li>
<li>新建对象的 _ <em>proto</em> _指向构造函数的prototype</li>
<li>调用构造函数，函数的this指向新创建的对象</li>
<li>执行构造函数内部的代码（给新对象添加属性）</li>
<li><strong>如果构造函数返回非空对象，则返回该对象，否则，返回新创建的对象</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">age, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 修改obj.__proto__ = fn.prototype，如果直接obj = &#123;&#125;会出现没有对象标识的问题（对象标识为Object），还会使得方法没有被创建</span></span><br><span class="line">    <span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(fn.<span class="property"><span class="keyword">prototype</span></span>)  <span class="comment">//fn.prototype代表 用当前对象的原型去创建</span></span><br><span class="line">    <span class="comment">//现在obj就代表Dog了,但是参数和this指向没有修改</span></span><br><span class="line">    <span class="keyword">const</span> rel = fn.<span class="title function_">apply</span>(obj,args)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       正常规定,如何fn返回的是null或undefined(也就是不返回内容),我们返回的是obj,否则返回rel</span></span><br><span class="line"><span class="comment">       因为比如下面这个构造函数</span></span><br><span class="line"><span class="comment">       function Person(name, age) &#123;</span></span><br><span class="line"><span class="comment">            this.name = name;</span></span><br><span class="line"><span class="comment">            this.age = age;</span></span><br><span class="line"><span class="comment">            return &#123;</span></span><br><span class="line"><span class="comment">                a: 1,</span></span><br><span class="line"><span class="comment">                b: 2,</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        const p = new Person(&#x27;h&#x27;, &#x27;y&#x27;);</span></span><br><span class="line"><span class="comment">        这里new会优先为构造函数的返回值</span></span><br><span class="line"><span class="comment">        所以p的值为&#123;a: 1,b: 2&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> rel <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? rel : obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title function_">myNew</span>(<span class="title class_">Person</span>, <span class="number">19</span>, <span class="string">&#x27;hyz&#x27;</span>);</span><br></pre></td></tr></table></figure>

<!--more-->

<h4 id="实现一个Object-create"><a href="#实现一个Object-create" class="headerlink" title="实现一个Object.create"></a>实现一个Object.create</h4><p>Object.create(proto)创建一个空对象，proto为空对象的”<em><strong>proto</strong></em>“</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// Object.create(null) 返回一个__proto__指向空的干净对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 非对象非null，抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> <span class="title class_">Object</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="虾皮笔试题"><a href="#虾皮笔试题" class="headerlink" title="虾皮笔试题"></a>虾皮笔试题</h4><p>十分有水平的一道题，综合了new原理，原型链+instanceof原理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;ee&#x27;</span>,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// Person 的 prototype 已经改变，而 person1.__proto__ 指向一开始的 Person.prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person1 instanceof Person: &#x27;</span>, person1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>) <span class="comment">// 为啥是false</span></span><br><span class="line"><span class="comment">// 所有的对象都继承自 Object，除了 null 或者你把最顶层的 prototype 也给改了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person1 instanceof Object: &#x27;</span>, person1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">// 为啥是true</span></span><br><span class="line"><span class="comment">// person1 本身没有 constructor, 会沿着原型链找，</span></span><br><span class="line"><span class="comment">// person1.constructor === person1.__proto__.constructor</span></span><br><span class="line"><span class="comment">// 而上面也说了 person1.__proto__ 并没有因为 Person.prototype 改变而改变</span></span><br><span class="line"><span class="comment">// 这里需要注意的是：</span></span><br><span class="line"><span class="comment">// Person 本身就是 constructor</span></span><br><span class="line"><span class="comment">// 初始情况下</span></span><br><span class="line"><span class="comment">// Person.prototype =&gt; Person.prototype</span></span><br><span class="line"><span class="comment">// Person.prototype.constructor =&gt; Person</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person1.constructor == Person: &#x27;</span>, person1.<span class="property">constructor</span> == <span class="title class_">Person</span>) <span class="comment">// 为啥是true</span></span><br><span class="line"><span class="comment">// 上面是 true, 下面就好说了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person1.constructor == Object: &#x27;</span>, person1.<span class="property">constructor</span> == <span class="title class_">Object</span>) <span class="comment">// 为啥是false</span></span><br></pre></td></tr></table></figure>

<h4 id="实现消息订阅"><a href="#实现消息订阅" class="headerlink" title="实现消息订阅"></a>实现消息订阅</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventCenter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Map&lt;string, Array&lt;Function&gt;</span>&#125; <span class="variable">handlers</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">handlers=<span class="keyword">new</span> <span class="built_in">Map</span>()</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handlers</span> = handlers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; <span class="variable">handler</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">type</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="title function_">addEventListener</span>(<span class="params">type, newHandler</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> hanlder = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">has</span>(type);</span><br><span class="line">        <span class="keyword">if</span> (hanlder) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">set</span>(type, [...<span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">get</span>(type), newHandler]) </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">set</span>(type, [newHandler]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">type</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">params</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="title function_">dispatchEvent</span>(<span class="params">type, params=[]</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> handler = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">get</span>(type);</span><br><span class="line">        handler &amp;&amp; handler.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">callback</span>(...params);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; type </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; delHandler </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">removeEventListener</span>(<span class="params">type, delHandler</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">has</span>(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Errow</span>(<span class="string">&quot;Unable to delete&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delHanlder) &#123;</span><br><span class="line">            <span class="keyword">const</span> oldHandlers = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">get</span>(type);</span><br><span class="line">            <span class="keyword">const</span> ind = oldHandlers.<span class="title function_">indexOf</span>(delHandler);</span><br><span class="line">            <span class="keyword">if</span> (ind === -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Errow</span>(<span class="string">&quot;Unable to delete&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            oldHandlers.<span class="title function_">splice</span>(ind, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">delete</span>(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现一个JSONP"><a href="#实现一个JSONP" class="headerlink" title="实现一个JSONP"></a>实现一个JSONP</h4><p>前端部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">url, options</span>) &#123;</span><br><span class="line">    <span class="comment">// 超时处理</span></span><br><span class="line">    <span class="keyword">const</span> &#123; timeout &#125; = options;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 防止函数名冲突</span></span><br><span class="line">        <span class="keyword">let</span> funcName = <span class="string">`jsonp<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">let</span> time = <span class="literal">null</span>, scriptNode;</span><br><span class="line">        <span class="comment">// 定义callback</span></span><br><span class="line">        <span class="variable language_">window</span>[funcName] = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(time);</span><br><span class="line">            <span class="title function_">resolve</span>(data);</span><br><span class="line">            <span class="comment">// 很重要的性能优化点</span></span><br><span class="line">            <span class="comment">// 清除本次请求产生的回调函数和script标签</span></span><br><span class="line">            <span class="keyword">delete</span> <span class="variable language_">window</span>[funcName];</span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(scriptNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建script标签</span></span><br><span class="line">        scriptNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        <span class="comment">// 给script标签添加src属性</span></span><br><span class="line">        scriptNode.<span class="property">src</span> = <span class="string">`<span class="subst">$&#123;url&#125;</span>?callback=<span class="subst">$&#123;funcName&#125;</span>`</span>;</span><br><span class="line">        <span class="comment">// 发出请求</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(scriptNode);</span><br><span class="line">        time = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;network err, timeout&#x27;</span>)</span><br><span class="line">        &#125;, timeout)</span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        scriptNode.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">jsonp</span>(<span class="string">&#x27;http://localhost:9090/api&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">callBack</span>: <span class="string">&#x27;res1&#x27;</span>,</span><br><span class="line">    <span class="comment">// 超时处理</span></span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">// 请求成功</span></span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;jsonp-&gt;&#x27;</span>, res);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 请求失败</span></span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;network err!&quot;</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>后端部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后端</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// /api?callback=onResponse</span></span><br><span class="line">  <span class="comment">// 解析前端请求url中的callback名</span></span><br><span class="line">  <span class="keyword">if</span>(req.<span class="property">url</span>.<span class="title function_">includes</span>(<span class="string">&#x27;/api&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> myurl = url.<span class="title function_">parse</span>(req.<span class="property">url</span>);</span><br><span class="line">    <span class="keyword">let</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(myurl.<span class="property">query</span>)</span><br><span class="line">    <span class="keyword">let</span> posts = [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;php&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> mathodName = params.<span class="title function_">get</span>(<span class="string">&#x27;callback&#x27;</span>);</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">`<span class="subst">$&#123;mathodName&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(posts)&#125;</span>)`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">listen</span>(<span class="number">9090</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">9090</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【前端面试】工程化相关</title>
    <url>/2024/08/27/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%91%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h2><h3 id="Pnpm是怎么解决幽灵依赖的"><a href="#Pnpm是怎么解决幽灵依赖的" class="headerlink" title="Pnpm是怎么解决幽灵依赖的"></a>Pnpm是怎么解决幽灵依赖的</h3><p>hard link + symbolic link</p>
<h3 id="如何确定一个项目用的包管理器版本：enigne字段"><a href="#如何确定一个项目用的包管理器版本：enigne字段" class="headerlink" title="如何确定一个项目用的包管理器版本：enigne字段"></a>如何确定一个项目用的包管理器版本：enigne字段</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;engines&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;node&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&gt;=14.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;npm&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&gt;=7.0.0&quot;</span>  <span class="comment">// 项目要求的 npm 最低版本</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="如何避免业务项目被发到npm上"><a href="#如何避免业务项目被发到npm上" class="headerlink" title="如何避免业务项目被发到npm上"></a>如何避免业务项目被发到npm上</h3><h4 id="在-package-json-中添加-private-字段"><a href="#在-package-json-中添加-private-字段" class="headerlink" title="在 package.json 中添加 private 字段"></a>在 package.json 中添加 private 字段</h4><p>在项目的 package.json 文件中添加 private: true 字段，这是最直接的方式。当 private 为 true 时，npm 会拒绝发布该项目。</p>
<h4 id="使用-npmignore-或-gitignore-文件"><a href="#使用-npmignore-或-gitignore-文件" class="headerlink" title="使用 .npmignore 或 .gitignore 文件"></a>使用 .npmignore 或 .gitignore 文件</h4><p>将项目中的所有文件添加到忽略列表，确保没有文件被发布。.npmignore 会覆盖 .gitignore 的规则。</p>
<h4 id="设置预发布钩子"><a href="#设置预发布钩子" class="headerlink" title="设置预发布钩子"></a>设置预发布钩子</h4><p>在 package.json 中添加 prepublishOnly 脚本，使其在发布前失败：</p>
<h4 id="使用-npmrc-文件锁定发布源"><a href="#使用-npmrc-文件锁定发布源" class="headerlink" title="使用 .npmrc 文件锁定发布源"></a>使用 .npmrc 文件锁定发布源</h4><p>在项目根目录创建 .npmrc 文件，设置为私有源或无效源：</p>
<span id="more"></span>

<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><h3 id="package-json-中-main-module-browser-exports-字段有何区别"><a href="#package-json-中-main-module-browser-exports-字段有何区别" class="headerlink" title="package.json 中 main&#x2F;module&#x2F;browser&#x2F;exports 字段有何区别"></a>package.json 中 main&#x2F;module&#x2F;browser&#x2F;exports 字段有何区别</h3><h3 id="peerdependencies相关"><a href="#peerdependencies相关" class="headerlink" title="peerdependencies相关"></a>peerdependencies相关</h3><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><h3 id="webpack-的-loader-的机制是什么，有哪些常用的loader？"><a href="#webpack-的-loader-的机制是什么，有哪些常用的loader？" class="headerlink" title="webpack 的 loader 的机制是什么，有哪些常用的loader？"></a>webpack 的 loader 的机制是什么，有哪些常用的loader？</h3><p>本质上是一个函数，做文件转换，处理的操作，输入输出都是文件，常用loader有ts-loader，less-loader，babel-loader</p>
<h3 id="webpack默认打包成什么产物？UMD、CJS、ESM"><a href="#webpack默认打包成什么产物？UMD、CJS、ESM" class="headerlink" title="webpack默认打包成什么产物？UMD、CJS、ESM"></a>webpack默认打包成什么产物？UMD、CJS、ESM</h3><p>类似于UMD的那种iife</p>
<h3 id="webpack-的插件系统是什么，有哪些常用的plugin？"><a href="#webpack-的插件系统是什么，有哪些常用的plugin？" class="headerlink" title="webpack 的插件系统是什么，有哪些常用的plugin？"></a>webpack 的插件系统是什么，有哪些常用的plugin？</h3><p>用于在webpack打包构建的生命周期里去做一些逻辑，常用plugin有：</p>
<ul>
<li><strong>HtmlWebpackPlugin</strong>：生成 HTML 文件并自动注入打包后的 JS&#x2F;CSS</li>
<li><strong>TerserPlugin</strong>：压缩和混淆 JavaScript 代码</li>
<li><strong>SplitChunksPlugin</strong>：自动分割公共代码和第三方库（Webpack 内置）</li>
</ul>
<h3 id="webpack有哪两种代码分割模式"><a href="#webpack有哪两种代码分割模式" class="headerlink" title="webpack有哪两种代码分割模式"></a>webpack有哪两种代码分割模式</h3><p><strong>打包分离（bundle spliting）</strong><br>  为了更好的缓存，把代码分割成一个个小文件<br><strong>代码分离（code spliting）</strong><br>  动态，按需的加载代码</p>
<h3 id="webpack-splitchunk有哪些配置"><a href="#webpack-splitchunk有哪些配置" class="headerlink" title="webpack splitchunk有哪些配置"></a>webpack splitchunk有哪些配置</h3><ul>
<li><strong>chunks</strong>: ‘async’,      &#x2F;&#x2F; 分割哪些类型的模块（async、initial、all）</li>
<li><strong>minSize</strong>: 20000,       &#x2F;&#x2F; 生成 chunk 的最小体积（字节）</li>
<li><strong>minRemainingSize</strong>: 0,  &#x2F;&#x2F; 确保拆分后剩余的最小 chunk 体积</li>
<li><strong>minChunks</strong>: 1,         &#x2F;&#x2F; 被多少模块共享时才分割</li>
<li><strong>maxAsyncRequests</strong>: 30, &#x2F;&#x2F; 按需加载时的最大并行请求数</li>
<li><strong>maxInitialRequests</strong>: 30, &#x2F;&#x2F; 入口点的最大并行请求数</li>
<li><strong>enforceSizeThreshold</strong>: 50000, &#x2F;&#x2F; 强制拆分阈值</li>
<li><strong>cacheGroups</strong>: {        &#x2F;&#x2F; 缓存组，自定义拆分策略<br>  defaultVendors: {<br>  test: &#x2F;[\&#x2F;]node_modules[\&#x2F;]&#x2F;, &#x2F;&#x2F; 匹配 node_modules 中的模块<br>  priority: -10,                 &#x2F;&#x2F; 优先级<br>  reuseExistingChunk: true,      &#x2F;&#x2F; 复用已存在的 chunk<br>  },<br>  default: {<br>  minChunks: 2,<br>  priority: -20,<br>  reuseExistingChunk: true,<br>  },<br>},</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="有哪些常见的性能优化指标，如何计算出这些指标"><a href="#有哪些常见的性能优化指标，如何计算出这些指标" class="headerlink" title="有哪些常见的性能优化指标，如何计算出这些指标"></a>有哪些常见的性能优化指标，如何计算出这些指标</h3><p>如何计算：通过Performance API获取<br><code>performance.getEntriesByType(&#39;paint&#39;)</code></p>
<ul>
<li><strong>FP（首次绘制）</strong><br>表示渲染出第一个像素点。FP一般在HTML解析完成或者解析一部分时候触发。标志着页面开始有视觉反馈</li>
<li><strong>FCP（首次内容绘制）</strong><br>表示渲染出第一个内容，这里的“内容”可以是文本、图片、canvas。用户首次看到实际内容的时间，更贴近真实体验。</li>
<li><strong>LCP（最大内容渲染）</strong><br>最大内容绘制，可视区域内最大的内容元素完成渲染的时间点，用于衡量主内容可见的时间，反映首屏加载速度</li>
<li><strong>DCL（DOMContentLoaded）</strong><br>HTML 解析完成且 DOM 树已构建完毕时触发，但此时 CSS、图片等外部资源可能仍在加载中。标志着可以安全操作 DOM，是前端交互初始化的重要时机。</li>
<li><strong>FID（首次输入延迟）</strong><br>用户首次与页面交互（点击按钮、输入框等）到浏览器实际能够处理该交互的时间差。</li>
<li><strong>TTI（可交互时间）</strong><br>页面不仅完成渲染（如 LCP），且能可靠响应用户输入的时间点。</li>
</ul>
<h3 id="关注哪些性能指标，怎么实现的"><a href="#关注哪些性能指标，怎么实现的" class="headerlink" title="关注哪些性能指标，怎么实现的"></a>关注哪些性能指标，怎么实现的</h3><h4 id="首字节时间"><a href="#首字节时间" class="headerlink" title="首字节时间"></a>首字节时间</h4><p>HTML解析完成，开始渲染第一个字节的时间。<br>应该也是借助Performance API实现</p>
<h4 id="DomReady时间"><a href="#DomReady时间" class="headerlink" title="DomReady时间"></a>DomReady时间</h4><p>和DCL一致，HTML文档被完全加载和解析后触发，此时外部资源可能仍然在下载</p>
<h4 id="首屏时间"><a href="#首屏时间" class="headerlink" title="首屏时间"></a>首屏时间</h4><p>页面完全渲染完毕的结束时间。<br>借助MutationObserver和PerformanceObserver实现</p>
<ul>
<li><strong>MutationObserver</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver">MDN: MutationObserver</a></li>
<li><strong>PerformanceObserver</strong>：<a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver">MDN: PerformanceObserver</a></li>
<li><strong>实现方案</strong>：<br><img src="/../assets/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E9%A6%96%E5%B1%8F%E6%80%A7%E8%83%BD.png" alt="alt text"></li>
</ul>
<h3 id="在做按需加载时，如何去实现一个asyncComponent"><a href="#在做按需加载时，如何去实现一个asyncComponent" class="headerlink" title="在做按需加载时，如何去实现一个asyncComponent"></a>在做按需加载时，如何去实现一个asyncComponent</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Home</span> = <span class="title class_">AsyncComponent</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;./test.tsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">AsyncComponent</span> = (<span class="params">importComponent</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">funciton</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> [component, setComponent] = <span class="title function_">useState</span>(<span class="literal">null</span>)</span><br><span class="line">        <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            importComponent.<span class="title function_">then</span>(<span class="function">(<span class="params">cmp</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">setComponent</span>(cmp.<span class="property">default</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, [])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> component ? <span class="language-xml"><span class="tag">&lt;<span class="name">component</span>/&gt;</span></span> : <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>【前端面试】React相关</title>
    <url>/2024/08/23/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%91React%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="useEffect-中如何使用-async-await"><a href="#useEffect-中如何使用-async-await" class="headerlink" title="useEffect 中如何使用 async&#x2F;await"></a>useEffect 中如何使用 async&#x2F;await</h3><ol>
<li>async函数抽离到外部 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchMyAPI</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;api/data&quot;</span>);</span><br><span class="line">  response = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">  å<span class="title function_">dataSet</span>(response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">fetchMyAPI</span>();</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<ol start="2">
<li>async立即执行函数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">   (<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">anyNameFunction</span>(<span class="params"></span>) &#123; </span><br><span class="line">     <span class="keyword">await</span> <span class="title function_">loadContent</span>(); </span><br><span class="line">   &#125;)(); </span><br><span class="line"> &#125;, []);</span><br></pre></td></tr></table></figure></li>
<li>ahooks - useAsyncEffect<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useAsyncEffect</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="attr">effect</span>: () =&gt; <span class="title class_">AsyncGenerator</span>&lt;<span class="built_in">void</span>, <span class="built_in">void</span>, <span class="built_in">void</span>&gt; | <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt;,</span></span><br><span class="line"><span class="params">    deps?: <span class="title class_">DependencyList</span>,</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> e = <span class="title function_">effect</span>();</span><br><span class="line">      <span class="keyword">let</span> cancelled = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">execute</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isAsyncGenerator</span>(e)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">              <span class="keyword">const</span> result = <span class="keyword">await</span> e.<span class="title function_">next</span>();</span><br><span class="line">                <span class="keyword">if</span> (result.<span class="property">done</span> || cancelled) &#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> e;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">execute</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        cancelled = <span class="literal">true</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;, deps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="React-hooks如何实现类似Redux的状态管理"><a href="#React-hooks如何实现类似Redux的状态管理" class="headerlink" title="React hooks如何实现类似Redux的状态管理"></a>React hooks如何实现类似Redux的状态管理</h3><p>useContext+useReducer</p>
<h3 id="React-key的作用"><a href="#React-key的作用" class="headerlink" title="React key的作用"></a>React key的作用</h3><h3 id="React-useCallback使用场景"><a href="#React-useCallback使用场景" class="headerlink" title="React useCallback使用场景"></a>React useCallback使用场景</h3><ol>
<li>作为props传递的函数，集合memo一起使用；</li>
<li>作为更新触发的依赖项 主要目的是为了避免高昂的计算和不必要的重复渲染</li>
</ol>
<h3 id="React闭包陷阱"><a href="#React闭包陷阱" class="headerlink" title="React闭包陷阱"></a>React闭包陷阱</h3><h3 id="React-reconcile"><a href="#React-reconcile" class="headerlink" title="React reconcile"></a>React reconcile</h3><p><a href="https://zh-hans.legacy.reactjs.org/docs/reconciliation.html#motivation">https://zh-hans.legacy.reactjs.org/docs/reconciliation.html#motivation</a></p>
<h3 id="特殊的React-Hooks"><a href="#特殊的React-Hooks" class="headerlink" title="特殊的React Hooks"></a>特殊的React Hooks</h3><h4 id="useTransition"><a href="#useTransition" class="headerlink" title="useTransition"></a>useTransition</h4><h4 id="useOptimistic"><a href="#useOptimistic" class="headerlink" title="useOptimistic"></a>useOptimistic</h4><h4 id="useSyncExternalStore"><a href="#useSyncExternalStore" class="headerlink" title="useSyncExternalStore"></a>useSyncExternalStore</h4><h4 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h4><h3 id="当多次重复点击按钮时，以下三个-Heading-是如何渲染的"><a href="#当多次重复点击按钮时，以下三个-Heading-是如何渲染的" class="headerlink" title="当多次重复点击按钮时，以下三个 Heading 是如何渲染的"></a>当多次重复点击按钮时，以下三个 Heading 是如何渲染的</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; memo, useMemo, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Heading</span> = <span class="title function_">memo</span>(<span class="function">(<span class="params">&#123; style, title &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Rendered:&quot;</span>, title); </span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;style&#125;</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">const</span> normalStyle = &#123;</span><br><span class="line">    <span class="attr">backgroundColor</span>: <span class="string">&quot;teal&quot;</span>,</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;white&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">const</span> memoizedStyle = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">backgroundColor</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&quot;white&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          setCount(count + 1);</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        Increment &#123;count&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Heading</span> <span class="attr">style</span>=<span class="string">&#123;memoizedStyle&#125;</span> <span class="attr">title</span>=<span class="string">&quot;Memoized&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Heading</span> <span class="attr">style</span>=<span class="string">&#123;normalStyle&#125;</span> <span class="attr">title</span>=<span class="string">&quot;Normal&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Heading</span> <span class="attr">title</span>=<span class="string">&quot;React.memo Normal&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setState代码输出"><a href="#setState代码输出" class="headerlink" title="setState代码输出"></a>setState代码输出</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [todo, setTodo] = <span class="title function_">useState</span>(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">status</span>: <span class="string">&quot;TODO&quot;</span> &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          todo.status = !todo.status;</span></span><br><span class="line"><span class="language-xml">          setTodo(todo);</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        Toggle Status</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;todo.status&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useCallback和useMemo性能优化"><a href="#useCallback和useMemo性能优化" class="headerlink" title="useCallback和useMemo性能优化"></a>useCallback和useMemo性能优化</h3><h3 id="优化React项目性能"><a href="#优化React项目性能" class="headerlink" title="优化React项目性能"></a>优化React项目性能</h3><ol>
<li>避免不必要的渲染，shouldComponentUpdate、React.memo、React.useMemo、React.useCallback。</li>
<li>代码分割，React.lazy 动态加载组件</li>
<li>使用 <code>react-query</code>，对请求响应进行缓存、重发等，避免多次请求，减少网络 IO 消耗及优化渲染次数</li>
<li>使用 <code>useDebounce</code>，对值及事件处理函数进行防抖，避免状态频繁变动，优化渲染次数</li>
<li>使用 <code>useImmer</code></li>
</ol>
<h3 id="React-19"><a href="#React-19" class="headerlink" title="React 19"></a>React 19</h3>]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>【前端面试】计算机网络</title>
    <url>/2024/08/19/%E3%80%90%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h3><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>正向代理是代理客户端，服务器无法感知客户端，客户端的请求都发往代理服务器，代理服务器替客户端发送请求给服务器，并把服务器响应的数据返回给客户端</p>
<p>应用：翻墙，接口转发实现跨域</p>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>反向代理是代理服务器，客户端无法感知服务器</p>
<p>应用：负载均衡</p>
<span id="more"></span>]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>书单 / BookList</title>
    <url>/2024/09/26/%E4%B9%A6%E5%8D%95/</url>
    <content><![CDATA[<h4 id="专业向"><a href="#专业向" class="headerlink" title="专业向"></a>专业向</h4><h5 id="计算机（4）"><a href="#计算机（4）" class="headerlink" title="计算机（4）"></a>计算机（4）</h5><ul>
<li><a href="https://markdown.com.cn/">你所不知道的JavaScript</a></li>
<li><a href="https://markdown.com.cn/">深入浅出NodeJS</a></li>
<li><a href="https://markdown.com.cn/">Webpack实战：入门、进阶与调优</a></li>
<li><a href="https://markdown.com.cn/">TypeScript图形渲染实战</a></li>
</ul>
<h5 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h5><hr>
<h4 id="非专业向"><a href="#非专业向" class="headerlink" title="非专业向"></a>非专业向</h4><h5 id="社科文学类（5）"><a href="#社科文学类（5）" class="headerlink" title="社科文学类（5）"></a>社科文学类（5）</h5><ul>
<li><a href="https://markdown.com.cn/">山月记</a></li>
<li><a href="https://markdown.com.cn/">宋词群星闪耀时</a></li>
<li><a href="https://markdown.com.cn/">我在西南联大的日子</a></li>
<li><a href="https://markdown.com.cn/">当呼吸化为空气</a></li>
<li><a href="https://markdown.com.cn/">被讨厌的勇气</a></li>
<li><a href="https://markdown.com.cn/">台湾四百年</a></li>
</ul>
<h5 id="杂文散文（1）"><a href="#杂文散文（1）" class="headerlink" title="杂文散文（1）"></a>杂文散文（1）</h5><ul>
<li><a href="https://markdown.com.cn/">生命是孤独的旅程</a></li>
</ul>
<h5 id="小说（5）"><a href="#小说（5）" class="headerlink" title="小说（5）"></a>小说（5）</h5><ul>
<li><a href="https://markdown.com.cn/">羊毛战记</a></li>
<li><a href="https://markdown.com.cn/">三国演义</a></li>
<li><a href="https://markdown.com.cn/">冰与火之歌</a></li>
<li><a href="https://markdown.com.cn/">野性的呼唤</a></li>
<li><a href="https://markdown.com.cn/">龙族</a></li>
</ul>
<h5 id="传记（1）"><a href="#传记（1）" class="headerlink" title="传记（1）"></a>传记（1）</h5><ul>
<li><a href="https://markdown.com.cn/">苏东坡全传</a></li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/2021/10/08/%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h4><p>函数式编程具有五个鲜明的特点。</p>
<p><strong>1. 函数是”第一等公民”</strong></p>
<p>指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p>
<p>举例来说，下面代码中的print变量就是一个函数，可以作为另一个函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">　　<span class="keyword">var</span> print = <span class="keyword">function</span>(<span class="params">i</span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(i);&#125;;</span><br><span class="line"></span><br><span class="line">　　[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">forEach</span>(print);</span><br></pre></td></tr></table></figure>

<p><strong>2. 只用”表达式”，不用”语句”</strong></p>
<p>“表达式”（expression）是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</p>
<p>原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I&#x2F;O）。”语句”属于对系统的读写操作，所以就被排斥在外。</p>
<p>当然，实际应用中，不做I&#x2F;O是不可能的。因此，编程过程中，函数式编程只要求把I&#x2F;O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。</p>
<span id="more"></span>

<p><strong>3. 没有”副作用”</strong></p>
<p>所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。</p>
<p>函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p>
<p><strong>4. 不修改状态</strong></p>
<p>上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。</p>
<p>在其他类型的语言中，变量往往用来保存”状态”（state）。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。下面的代码是一个将字符串逆序排列的函数，它演示了不同的参数如何决定了运算所处的”状态”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function reverse(string) &#123;</span><br><span class="line">　　if(string.length == 0) &#123;</span><br><span class="line">　　　　return string;</span><br><span class="line">　　&#125; else &#123;</span><br><span class="line">　　　　return reverse(string.substring(1, string.length)) + string.substring(0, 1);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于使用了递归，函数式语言的运行速度比较慢，这是它长期不能在业界推广的主要原因。</p>
<p><strong>5. 引用透明</strong></p>
<p>引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。</p>
<p>有了前面的第三点和第四点，这点是很显然的。其他类型的语言，函数的返回值往往与系统状态有关，不同的状态之下，返回值是不一样的。这就叫”引用不透明”，很不利于观察和理解程序的行为。</p>
<h4 id="函数式编程的意义"><a href="#函数式编程的意义" class="headerlink" title="函数式编程的意义"></a>函数式编程的意义</h4><p><strong>1. 代码简洁，开发快速</strong></p>
<p>函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。</p>
<p><strong>2. 更方便的代码管理</strong></p>
<p>函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。</p>
]]></content>
      <categories>
        <category>Chore</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Functional Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Web Development Trend</title>
    <url>/2024/12/05/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF/</url>
    <content><![CDATA[<h2 id="前端供需关系"><a href="#前端供需关系" class="headerlink" title="前端供需关系"></a>前端供需关系</h2><h2 id="新的样式解决方案和组件库现状-发展"><a href="#新的样式解决方案和组件库现状-发展" class="headerlink" title="新的样式解决方案和组件库现状&amp;发展"></a>新的样式解决方案和组件库现状&amp;发展</h2><blockquote>
<p>样式如何结合组件库去使用</p>
</blockquote>
<h3 id="CSS-in-JS-style-component"><a href="#CSS-in-JS-style-component" class="headerlink" title="CSS in JS: style component"></a>CSS in JS: style component</h3><p>能够实现CSS模块化，专注于</p>
<p>语义差，不利于SSO<br>运行时编译</p>
<h3 id="Tailwind-CSS"><a href="#Tailwind-CSS" class="headerlink" title="Tailwind CSS"></a>Tailwind CSS</h3><p>语义好，利于AI学习，AI</p>
<h3 id="Shadcn"><a href="#Shadcn" class="headerlink" title="Shadcn"></a>Shadcn</h3><h3 id="HeadlessUI"><a href="#HeadlessUI" class="headerlink" title="HeadlessUI"></a>HeadlessUI</h3><h3 id="Radix"><a href="#Radix" class="headerlink" title="Radix"></a>Radix</h3><p>主题样式</p>
]]></content>
      <categories>
        <category>Chore</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>前端安全相关</title>
    <url>/2025/01/12/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p><strong>跨站脚本攻击（XSS，Cross - Site Scripting）</strong>攻击者通过在目标网站中注入恶意脚本，来获取用户的敏感信息、执行恶意操作等。这些恶意脚本通常是 JavaScript</p>
<h3 id="整体过程"><a href="#整体过程" class="headerlink" title="整体过程"></a>整体过程</h3><p>攻击者提交恶意代码 -&gt; 浏览器执行恶意代码</p>
<h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><h4 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h4><p>示例：一个简单的搜索功能，用户在搜索框输入内容后，服务器将用户输入的内容直接在页面上显示。攻击者构造一个类似 <code>http://example.com/search?q=&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code> 的 URL，当用户点击这个链接，就会弹出一个警告框显示 “XSS”。</p>
<span id="more"></span>
<h4 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h4><p>原理：攻击者将恶意脚本存储在目标服务器上，如存储在数据库、文件系统等。当其他用户访问包含该恶意脚本的页面时，浏览器就会执行这个脚本。这种类型的 XSS 通常出现在用户可以提交内容并且这些内容会被长期存储和展示的场景中，比如论坛、博客的评论区等。<br>示例：在一个论坛系统中，攻击者在评论区提交一个包含恶意脚本 <code>&lt;script&gt;stealCookie()&lt;/script&gt;</code>（假设存在一个名为 stealCookie 的恶意函数）的评论。当其他用户查看这个评论时，他们的浏览器会执行这个脚本，导致他们的 Cookie 信息可能被窃取。</p>
<h4 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h4><p>原理：这种类型的 XSS 是由于 HTML 页面中，JavaScript 通过 DOM 操作动态地修改页面内容而导致的。攻击者利用 JavaScript 代码中的漏洞，修改 DOM 来注入恶意脚本。与前面两种不同的是，它不依赖于服务器端对数据的反射或者存储，而是完全在客户端浏览器环境中发生。<br>示例：有一个网页，其中有一段 JavaScript 代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;userInput&#x27;</span>).<span class="property">innerHTML</span> = location.<span class="property">hash</span>.<span class="title function_">substr</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>攻击者可以构造一个 URL，如 <code>http://example.com/page.html#&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code>，当用户访问这个 URL 时，浏览器会执行这个恶意脚本，弹出警告框。</p>
<h3 id="预防漏洞的思路"><a href="#预防漏洞的思路" class="headerlink" title="预防漏洞的思路"></a>预防漏洞的思路</h3><ul>
<li>前端提交时过滤（请求可以绕过前端）</li>
<li>后端过滤（不能预防dom型XSS）</li>
<li>前端渲染时转义（完美）</li>
</ul>
<h3 id="其他安全措施"><a href="#其他安全措施" class="headerlink" title="其他安全措施"></a>其他安全措施</h3><ul>
<li>CSP内容安全策略</li>
<li>HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。</li>
<li>验证码：防止脚本冒充用户提交危险操作。</li>
</ul>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p><strong>CSRF（Cross-site request forgery）跨站请求伪造</strong>：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p>
<p>一个典型的CSRF攻击有着如下的流程：</p>
<ul>
<li>受害者登录a.com，并保留了登录凭证（Cookie）。</li>
<li>攻击者引诱受害者访问了b.com。</li>
<li>b.com 向 a.com 发送了一个请求：a.com&#x2F;act&#x3D;xx。浏览器会默认携带a.com的Cookie。</li>
<li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</li>
<li>a.com以受害者的名义执行了act&#x3D;xx。</li>
<li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。</li>
</ul>
<h3 id="预防漏洞的思路-1"><a href="#预防漏洞的思路-1" class="headerlink" title="预防漏洞的思路"></a>预防漏洞的思路</h3><h4 id="阻止不明外域的访问"><a href="#阻止不明外域的访问" class="headerlink" title="阻止不明外域的访问"></a>阻止不明外域的访问</h4><ul>
<li>同源检测</li>
<li>Samesite Cookie</li>
</ul>
<h4 id="提交时要求附加本域才能获取的信息"><a href="#提交时要求附加本域才能获取的信息" class="headerlink" title="提交时要求附加本域才能获取的信息"></a>提交时要求附加本域才能获取的信息</h4><ul>
<li>CSRF Token</li>
<li>双重Cookie验证</li>
</ul>
<h3 id="Samesite-Cookie"><a href="#Samesite-Cookie" class="headerlink" title="Samesite Cookie"></a>Samesite Cookie</h3><ul>
<li><code>Samesite Cookie = Strict</code>（同源请求才会带上cookie）</li>
<li><code>Samesite Cookie = Lax</code>（这意味着 cookie 不会在跨站请求中被发送，如：加载图像或框架（frame）的请求。但 cookie 在用户从外部站点导航到源站时，cookie 也会被发送（例如，访问一个链接）。这是 <code>SameSite</code> 属性未被设置时的默认行为。）</li>
<li><code>Samesite Cookie = None</code>（都会带）</li>
</ul>
]]></content>
      <categories>
        <category>Chore</category>
      </categories>
      <tags>
        <tag>前端安全</tag>
      </tags>
  </entry>
  <entry>
    <title>前端模块化</title>
    <url>/2025/03/27/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="CommonJS-ESModule-UMD等模块化方案"><a href="#CommonJS-ESModule-UMD等模块化方案" class="headerlink" title="CommonJS&#x2F;ESModule&#x2F;UMD等模块化方案"></a>CommonJS&#x2F;ESModule&#x2F;UMD等模块化方案</h2><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><ul>
<li><p>使用<code>require</code>，<code>export</code>进行导入导出</p>
</li>
<li><p><code>CommonJS</code>是<code>Node</code>的模块化方案，只能在<code>Node</code>端运行，不能在浏览器端，除非使用一些构建工具进行编译（<code>Webpack</code>、<code>Rollup</code>）</p>
</li>
<li><p>特定的第三方库只支持<code>CommonJS</code>，比如下载量很高的<a href="https://www.npmjs.com/package/ms">ms</a></p>
</li>
<li><p><code>CommonJS</code>属于动态加载，可以直接<code>require</code>一个变量：<code>require(`./$&#123;a&#125;`);</code></p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sum.js</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">sum</span> = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; sum &#125; = <span class="built_in">require</span>(<span class="string">&quot;./sum.js&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<span id="more"></span>

<h3 id="ESModule"><a href="#ESModule" class="headerlink" title="ESModule"></a>ESModule</h3><ul>
<li><code>Esmodule</code> 是tc39对于<code>ESMAScript</code>的模块化规范，正因是语言层规范，<strong>因此在 Node 及 浏览器中均支持。</strong>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sum.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x, y</span>) =&gt; x + y;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&quot;./sum&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li>使用<code>import</code>，<code>export</code>进行模块的导入导出</li>
<li><code>Esmodule</code>为静态导入，正因如此，可在编译期进行<code>Tree Shaking</code>，减少 js 体积。</li>
<li>如果需要动态导入，tc39 为动态加载模块定义了 API: <code>import(module)</code>。</li>
<li><code>cjs</code>模块输出的是一个值的拷贝，<code>esm</code>输出的是值的引用</li>
<li>Node环境下的<code>cjs</code>模块是<strong>运行时加载</strong>，Webpack环境下的<code>esm</code>模块化是<strong>编译时加载</strong><br><strong>本质上是多了个文件IO</strong></li>
</ul>
<hr>
<h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><p>一种<strong>兼容<code>cjs</code>与<code>amd</code>的模块化方案</strong>，既可以在<code>node/webpack</code>环境中被<code>require</code>引用，也可以在浏览器中直接用 CDN 被<code>script.src</code>引入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">root, factory</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&quot;function&quot;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">    <span class="comment">// AMD</span></span><br><span class="line">    <span class="title function_">define</span>([<span class="string">&quot;jquery&quot;</span>], factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// CommonJS</span></span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>(<span class="built_in">require</span>(<span class="string">&quot;jquery&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 全局变量</span></span><br><span class="line">    root.<span class="property">returnExports</span> = <span class="title function_">factory</span>(root.<span class="property">jQuery</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="variable language_">this</span>, <span class="keyword">function</span> (<span class="params">$</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="center">特性</th>
<th>ESM（ES6 模块）</th>
<th>UMD（通用模块定义）</th>
<th>CJS（CommonJS）</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>语法</strong></td>
<td>import&#x2F;export</td>
<td>自执行函数，兼容多种环境</td>
<td>require&#x2F;exports&#x2F;module.exports</td>
</tr>
<tr>
<td align="center"><strong>兼容性</strong></td>
<td>现代浏览器、Node.js（需配置）</td>
<td>所有环境（浏览器、Node.js）</td>
<td>Node.js（默认）</td>
</tr>
<tr>
<td align="center"><strong>加载时机</strong></td>
<td>编译时静态分析（静态结构）</td>
<td>运行时动态加载</td>
<td>运行时动态加载</td>
</tr>
<tr>
<td align="center"><strong>依赖解析</strong></td>
<td>编译阶段确定依赖关系</td>
<td>运行时判断环境并选择加载方式</td>
<td>运行时执行 require 语句</td>
</tr>
<tr>
<td align="center"><strong>Tree Shaking</strong></td>
<td>支持	✅（静态结构可分析）</td>
<td>❌（动态加载）</td>
<td>❌（动态加载）</td>
</tr>
<tr>
<td align="center"><strong>典型应用场景</strong></td>
<td>现代前端项目（Webpack&#x2F;Vite）</td>
<td>通用库（需兼容所有环境）</td>
<td>Node.js 后端项目</td>
</tr>
<tr>
<td align="center"><strong>作用域</strong></td>
<td>每个模块有独立作用域</td>
<td>封装在 IIFE 中，避免全局污染</td>
<td>每个文件是独立模块</td>
</tr>
<tr>
<td align="center"><strong>导出机制</strong></td>
<td>实时绑定（引用共享）</td>
<td>对象拷贝</td>
<td>对象拷贝</td>
</tr>
</tbody></table>
<h3 id="常见问题Q-A"><a href="#常见问题Q-A" class="headerlink" title="常见问题Q&amp;A"></a>常见问题Q&amp;A</h3><h4 id="1、第三方npm包基于commonjs开发，使用到webpack的前端项目中，能否通过esmodule语法import引入"><a href="#1、第三方npm包基于commonjs开发，使用到webpack的前端项目中，能否通过esmodule语法import引入" class="headerlink" title="1、第三方npm包基于commonjs开发，使用到webpack的前端项目中，能否通过esmodule语法import引入"></a>1、第三方npm包基于commonjs开发，使用到webpack的前端项目中，能否通过esmodule语法import引入</h4><p>可以通过<code>import</code>引入<code>CommonJS</code>模块，<code>Webpack</code>会自动处理兼容性，比如引入下载量很高的<a href="https://www.npmjs.com/package/ms">ms</a></p>
<ul>
<li>直接导入：在Webpack环境下可直接使用<code>import ms from &#39;ms&#39;</code>导入，Webpack会自动处理</li>
<li>要注意的是<code>Tree Shaking</code>限制： <code>Webpack</code>只会对<code>Esmodule</code>模块进行<code>TreeShaking</code>。</li>
</ul>
<h4 id="2、如何判断引入的第三方包是否支持-Tree-Shaking"><a href="#2、如何判断引入的第三方包是否支持-Tree-Shaking" class="headerlink" title="2、如何判断引入的第三方包是否支持 Tree Shaking"></a>2、如何判断引入的第三方包是否支持 Tree Shaking</h4><ul>
<li>只有<code>ESM</code>支持<code>Tree Shaking</code></li>
<li>要根据第三方依赖的产物来判断（是否打成<code>ESM</code>的格式），而不是根据第三方依赖的源码判断</li>
</ul>
<h4 id="3、CJS的运行时加载和ESM的编译时加载有什么区别"><a href="#3、CJS的运行时加载和ESM的编译时加载有什么区别" class="headerlink" title="3、CJS的运行时加载和ESM的编译时加载有什么区别"></a>3、CJS的运行时加载和ESM的编译时加载有什么区别</h4><ul>
<li><p><strong>前端Webpack环境编译时加载模块的执行过程</strong><br><code>源代码（含import语句） → 打包工具（如Webpack） → 分析import依赖 → 生成合并后的代码 → 浏览器直接执行</code><br>关键步骤：</p>
<ol>
<li>静态分析：Webpack 在打包时扫描所有 import 语句，构建依赖图。</li>
<li>代码合并：将所有依赖的模块打包到一个或多个文件中（如 bundle.js）。</li>
<li>运行时执行：浏览器直接执行打包后的代码，无需再加载其他文件（依赖已包含在主文件中）。</li>
</ol>
</li>
<li><p><strong>Node环境运行时加载模块的执行过程</strong><br><code>代码执行 → 遇到require()语句 → 查找模块文件 → 读取文件内容 → 执行模块代码 → 返回导出值</code><br>关键步骤：</p>
<ol>
<li>执行到 require()：代码运行到该语句时，触发模块加载逻辑。</li>
<li>路径解析：根据 require() 的参数（如 .&#x2F;math.js），查找对应的文件。</li>
<li>文件读取与执行：读取模块文件内容，创建新的模块上下文并执行代码。</li>
<li>缓存结果：将模块的 exports 对象存入缓存，下次引用时直接返回缓存。</li>
</ol>
</li>
</ul>
<h4 id="4、成熟的第三方npm包是怎么去做构建的（以Lodash为例）"><a href="#4、成熟的第三方npm包是怎么去做构建的（以Lodash为例）" class="headerlink" title="4、成熟的第三方npm包是怎么去做构建的（以Lodash为例）"></a>4、成熟的第三方npm包是怎么去做构建的（以Lodash为例）</h4><p><strong>Lodash</strong> 的源码采用定义全局对象，「无模块化」设计，核心是通过构建工具将函数集合打包为多种格式：</p>
<p>源码组织：所有工具函数（如 map、filter）定义在全局对象上。<br>构建工具：使用定制的构建系统，将源码转换为：<br><strong>CJS 格式</strong>：lodash&#x2F;index.js<br><strong>ESM 格式</strong>：lodash-es&#x2F;index.js<br><strong>UMD 格式</strong>：dist&#x2F;lodash.js（可通过 CDN 引入）</p>
<h4 id="5、如何把开发的NPM包打成不同的格式（ESM，CJS，UMD）"><a href="#5、如何把开发的NPM包打成不同的格式（ESM，CJS，UMD）" class="headerlink" title="5、如何把开发的NPM包打成不同的格式（ESM，CJS，UMD）"></a>5、如何把开发的NPM包打成不同的格式（ESM，CJS，UMD）</h4><p>详见：<a href="https://github.com/huangyunt/Learning-Demo/tree/master/esm%2Ccjs%2Cumd%E6%89%93%E5%8C%85%E7%A4%BA%E4%BE%8B">打包示例</a><br>js代码<br>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">capitalize</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + str.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">truncate</span>(<span class="params">str, maxLength = <span class="number">10</span>, suffix = <span class="string">&#x27;...&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (str.<span class="property">length</span> &lt;= maxLength) <span class="keyword">return</span> str;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">slice</span>(<span class="number">0</span>, maxLength) + suffix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  capitalize,</span><br><span class="line">  truncate</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>webpack配置文件<br>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanWebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TerserPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公共配置</span></span><br><span class="line"><span class="keyword">const</span> commonConfig = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                <span class="comment">// use: &#123;</span></span><br><span class="line">                <span class="comment">//   loader: &#x27;babel-loader&#x27;,</span></span><br><span class="line">                <span class="comment">//   options: &#123;</span></span><br><span class="line">                <span class="comment">//     presets: [&#x27;@babel/preset-env&#x27;]</span></span><br><span class="line">                <span class="comment">//   &#125;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="comment">// new CleanWebpackPlugin() // 清理dist目录</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ESM 配置</span></span><br><span class="line"><span class="keyword">const</span> esmConfig = &#123;</span><br><span class="line">    ...commonConfig,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;string-utils.esm.js&#x27;</span>,</span><br><span class="line">        <span class="attr">library</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;module&#x27;</span> <span class="comment">// 输出ESM格式</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">experiments</span>: &#123;</span><br><span class="line">        <span class="attr">outputModule</span>: <span class="literal">true</span> <span class="comment">// 启用ESM输出</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">minimize</span>: <span class="literal">false</span> <span class="comment">// 开发环境不压缩</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CJS 配置</span></span><br><span class="line"><span class="keyword">const</span> cjsConfig = &#123;</span><br><span class="line">    ...commonConfig,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;string-utils.cjs.js&#x27;</span>,</span><br><span class="line">        <span class="attr">library</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;commonjs2&#x27;</span> <span class="comment">// 输出CJS格式</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">target</span>: <span class="string">&#x27;node&#x27;</span>, <span class="comment">// 针对Node.js环境</span></span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">minimize</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UMD 配置（开发环境）</span></span><br><span class="line"><span class="keyword">const</span> umdDevConfig = &#123;</span><br><span class="line">    ...commonConfig,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;string-utils.umd.js&#x27;</span>,</span><br><span class="line">        <span class="attr">library</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;StringUtils&#x27;</span>, <span class="comment">// 全局变量名</span></span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;umd&#x27;</span> <span class="comment">// 输出UMD格式</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">globalObject</span>: <span class="string">&#x27;this&#x27;</span> <span class="comment">// 兼容浏览器和Node.js</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">minimize</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = [esmConfig, cjsConfig, umdDevConfig, umdProdConfig];</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>工程化</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>包管理器</title>
    <url>/2025/03/13/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h2 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h2><h3 id="Npm-Yarn"><a href="#Npm-Yarn" class="headerlink" title="Npm&#x2F;Yarn"></a>Npm&#x2F;Yarn</h3><h4 id="Npm发包"><a href="#Npm发包" class="headerlink" title="Npm发包"></a>Npm发包</h4><h5 id="files"><a href="#files" class="headerlink" title="files"></a>files</h5><p>指定哪些文件会被打包发布（后面详细描述）。</p>
<h5 id="main、browser、exports、module"><a href="#main、browser、exports、module" class="headerlink" title="main、browser、exports、module"></a>main、browser、exports、module</h5><p>这四个字段都是用来定义包的入口，<code>npm</code> 只规定了 <code>main</code> 和 <code>browser</code> 这两个字段，<code>exports</code> 是 <code>nodejs</code> 的规范，<code>module</code> 一般被构建工具所支持。</p>
<h5 id="main"><a href="#main" class="headerlink" title="main"></a>main</h5><p><code>main</code> 规定了包的主要入口点，默认值为 <code>index.js</code>。</p>
<p>如果你的包名为 <code>foo</code> 可以通过 <code>require(&quot;foo&quot;)</code> 引入对应模块导出的内容，所以这应该是个 CommonJS 模块，除非你设置了 <code>&quot;type&quot;: &quot;module&quot;</code>。</p>
<span id="more"></span>

<h3 id="Pnpm"><a href="#Pnpm" class="headerlink" title="Pnpm"></a>Pnpm</h3><ul>
<li>省空间</li>
<li>解决幽灵依赖的问题</li>
</ul>
<p>如何确定一个项目的包管理工具？</p>
<ul>
<li>lock文件、package.json下packageManager字段来判断</li>
</ul>
<p>如何确定包管理工具的版本号？</p>
<ul>
<li>engines字段</li>
</ul>
<h2 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h2><h3 id="npm-scripts"><a href="#npm-scripts" class="headerlink" title="npm scripts"></a>npm scripts</h3><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><h4 id="lock文件"><a href="#lock文件" class="headerlink" title="lock文件"></a>lock文件</h4><ul>
<li>第三方包需要锁定版本号吗</li>
</ul>
<h4 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a>peerDependencies</h4><ul>
<li>项目安装的某个依赖存在peerDependencies，项目又没有声明这个依赖，那项目会自动安装吗，会autoinstall</li>
</ul>
<h3 id="github-action"><a href="#github-action" class="headerlink" title="github action"></a>github action</h3><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3>]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>工程化</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链基础知识</title>
    <url>/2024/11/01/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="区块链的本质"><a href="#区块链的本质" class="headerlink" title="区块链的本质"></a>区块链的本质</h2><p>区块链是什么？一言以蔽之：<strong>特殊的分布式数据库</strong><br>区块链的主要作用还是储存信息，任何需要保存的信息，都可以写入区块链，也可以从里面读取。</p>
<p>其次，任何人都可以架设服务器，加入区块链网络，成为一个节点。区块链的世界里面，没有中心节点，每个节点都是平等的，都保存着整个数据库。你可以向任何一个节点，写入&#x2F;读取数据，因为所有节点最后都会同步，保证区块链一致。</p>
<h2 id="区块链的最大特点"><a href="#区块链的最大特点" class="headerlink" title="区块链的最大特点"></a>区块链的最大特点</h2><p>去中心化、保持一致性（算力证明增加叛徒成本）</p>
<h3 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h3><blockquote>
<p>如何解决在所有网络节点存在故障、恶意节点时，保证其余部分结点的准确性和一致性</p>
</blockquote>
<h4 id="拜占庭容错（将军-副官模型）"><a href="#拜占庭容错（将军-副官模型）" class="headerlink" title="拜占庭容错（将军-副官模型）"></a>拜占庭容错（将军-副官模型）</h4><ol>
<li>忠诚的副官遵守同一个命令</li>
<li>若将军忠诚，则忠诚的副官会执行他的命令<br>m: 恶意副官的个数；n: 总人数<br>当 n&gt;3m, 问题可解</li>
</ol>
]]></content>
      <categories>
        <category>Web3/加密货币</category>
      </categories>
      <tags>
        <tag>Web3</tag>
        <tag>区块链</tag>
        <tag>智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title>同源和跨域</title>
    <url>/2025/01/10/%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<p>| 比较杂的知识点，同源跨域、服务器代理、简单请求非简单请求</p>
<h2 id="同源和跨域"><a href="#同源和跨域" class="headerlink" title="同源和跨域"></a>同源和跨域</h2><h3 id="为什么要有同源策略"><a href="#为什么要有同源策略" class="headerlink" title="为什么要有同源策略"></a>为什么要有同源策略</h3><ul>
<li>本质上是浏览器有cookie这么个玩意，比如移动端app就没有同源限制</li>
<li>防止CSRF攻击</li>
</ul>
<span id="more"></span>

<h3 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h3><h4 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h4><p><strong>jsonp</strong>的原理就是利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createScriptTag</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.<span class="property">type</span> = <span class="string">&#x27;text/javascript&#x27;</span>;</span><br><span class="line">  <span class="comment">// 设置请求的URL，假设服务端接口为http://example.com/api/data，同时指定回调函数名为handleData</span></span><br><span class="line">  script.<span class="property">src</span> = <span class="string">&#x27;http://example.com/api/data?callback=handleData&#x27;</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义回调函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleData</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  <span class="comment">// 在这里可以对返回的JSON数据进行处理，如更新页面内容等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器会返回一个函数调用，类似于 <code>handleData(&#123;&quot;data&quot;: &quot;value&quot;&#125;)</code> 的内容</p>
<h4 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h4><p>| 本质上是通过服务端来允许<br>配置受信任的域名，允许受信任域名的跨域请求</p>
<h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><h5 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h5><h4 id="服务器代理"><a href="#服务器代理" class="headerlink" title="服务器代理"></a>服务器代理</h4><ul>
<li>开发环境webpack-dev-server</li>
<li>生产环境nginx代理服务器部署在同源域名下，转发请求到对应的服务器上（当时配置：某个域名下的某个路径，关联到后端appkey上）</li>
</ul>
]]></content>
      <categories>
        <category>Chore</category>
      </categories>
      <tags>
        <tag>前端安全</tag>
      </tags>
  </entry>
  <entry>
    <title>加密货币的本质</title>
    <url>/2024/11/04/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<h2 id="钱的本质"><a href="#钱的本质" class="headerlink" title="钱的本质"></a>钱的本质</h2><p>共识、可信性</p>
<h3 id="比特币的可信性"><a href="#比特币的可信性" class="headerlink" title="比特币的可信性"></a>比特币的可信性</h3><p>比特币要解决的核心问题，就是创造一种可信的数字凭证。由于这种凭证可信，所以能够当做货币。<br>比特币的技术基础是加密学，因为只有加密学才能保证它的可信性。一旦加密被破解，它就没法当作货币了。这也是这一类数字凭证被称为”加密货币”的原因。<br>技术人员对比特币感兴趣，还有一个重要原因。任何需要可靠的数字凭证的场合，也许都可以用到这种技术。</p>
]]></content>
      <categories>
        <category>Web3/加密货币</category>
      </categories>
      <tags>
        <tag>Web3</tag>
        <tag>比特币</tag>
        <tag>加密货币</tag>
      </tags>
  </entry>
  <entry>
    <title>如何利用css var做一个dark mode方案</title>
    <url>/2022/03/01/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8css%20var%E5%81%9A%E4%B8%80%E4%B8%AAdark%20mode%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ol>
<li>希望利用 css 变量实现 dark 和 light 模式的切换</li>
<li>原有的工程都是 less 形式定义的 css，并且还有 less 的函数，比如 fade 等，不想手动改 less 的函数，希望该插件能支持解析 less 函数</li>
<li>需要支持局部不切换模式，比如某个区域是固定的 light 模式</li>
</ol>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="第一步：less-变量转换成-css-变量"><a href="#第一步：less-变量转换成-css-变量" class="headerlink" title="第一步：less 变量转换成 css 变量"></a>第一步：less 变量转换成 css 变量</h2><p>这一步比较简单，less 已经提供了字段用于转换，只需要添加一个配置项就可以，就是<code>globalVars</code>属性。</p>
<p>可以查看<a href="https://link.juejin.cn/?target=https://codebase.byted.org/repo/lark/dark-mode-css-var/-/blob/example/config/webpack.dm-cssvar.config.js">example 代码</a>参考</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;less-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">globalVars</span>: <span class="title class_">LessGlobalCSSVars</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>LessGlobalCSSVars</code>大概长这个样子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;bg-body&quot;</span>: <span class="string">&quot;var(--bg-body)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;static-white&quot;</span>: <span class="string">&quot;var(--static-white)&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>less 会将<code>LessGlobalCSSVars</code>的映射关系追加到 less 文件前，在进行变量查找的时候就会替换成相应的 css 变量</p>
<p>比如，下面的 less 文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    <span class="attr">color</span>: @bg-body;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>less 实际解析的文件内容是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bg-<span class="attr">body</span>: <span class="string">&quot;var(--bg-body)&quot;</span>;</span><br><span class="line"><span class="keyword">static</span>-<span class="attr">white</span>: <span class="string">&quot;var(--static-white)&quot;</span></span><br><span class="line">div &#123;</span><br><span class="line">    <span class="attr">color</span>: @bg-body;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>最后上面的文件就会被编译成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div &#123; <span class="attr">color</span>: <span class="title function_">var</span>(--bg-body);&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="第二步：less-函数如何解析？【less-插件】"><a href="#第二步：less-函数如何解析？【less-插件】" class="headerlink" title="第二步：less 函数如何解析？【less 插件】"></a>第二步：less 函数如何解析？【less 插件】</h2><p>但是还有一个问题是 less 函数应该如何解析呢？比如<code>fade(``@bg-body, 20%``)</code>，如果不经过任何处理，这个函数会抛出异常，因为<code>var(--bg-body)</code>并不是 less 能够解析的节点类型，会提示<code>var(--bg-body)</code>不能被转换成<code>Color</code>类型（less 的一个节点类型），这是 less 的语法树解析，需要将 fade 函数的第一个参数解析成 Color 节点类型，否则就会抛异常。所以，我们需要对 less 函数进行改写，具体通过 less 插件的方式实现。修改 less-loader 的配置如下，增加一个插件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;less-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">globalVars</span>: <span class="title class_">LessGlobalCSSVars</span>,</span><br><span class="line">      <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LessSkipVarsPlugin</span> ()</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>less 的所有函数会被注册到<code>[functions](https://github.com/less/less.js/blob/master/packages/less/src/less/functions/index.js &quot;functions&quot;)</code>中，插件暴露了该<code>functions</code>，因此可以通过修改响应的 less 函数，实现函数的覆盖。该插件的实现<a href="https://link.juejin.cn/?target=https://codebase.byted.org/repo/lark/dark-mode-css-var/-/blob/example/config/webpack.dm-cssvar.config.js">源代码</a>如下，functions 对象是函数名到函数体的映射，所以我们将需要重写的函数重置成我们自定义的即可。而函数的计算结果通过<code>calc</code>和<code>var</code>两个函数以及 css 变量进行表示，在页面中即可根据 css 变量进行实时计算！</p>
<p>下面只摘出来了我们支持的其中两个函数——fade 和 darken，fade 利用 rgba 的函数表示，而 darken 利用的是 hsl 的函数表示，主要是用 rgba 的表示法无法用 css 支持的函数表示出来，所以我们用了 hsl 函数。这里可以看到我们需要一些特殊的 css 变量，比如<code>--bg-body-SA</code>、<code>--bg-body-raw</code>、<code>--bg-HS</code>、 <code>--bg-body-L</code>.所以我们需要利用原始的色值（<code>bg-body</code>）进行转换</p>
<p>(下面代码做了省略，主要是示意，具体代码可以看源代码)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LessSkipVarsPlugin</span> &#123;</span><br><span class="line">    <span class="title function_">install</span>(<span class="params">less, pluginManager, functions</span>) &#123;</span><br><span class="line">        functions.<span class="title function_">add</span>(<span class="string">&#x27;fade&#x27;</span>, <span class="keyword">function</span> (<span class="params">color, percent</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (color.<span class="property">type</span> === <span class="string">&#x27;Call&#x27;</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (color.<span class="property">name</span> === <span class="string">&#x27;var&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> key = color.<span class="property">args</span>[<span class="number">0</span>].<span class="property">value</span>.<span class="title function_">substring</span>(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">`rgba(var(--<span class="subst">$&#123;key&#125;</span>-raw), calc(var(--<span class="subst">$&#123;key&#125;</span>-SA) * <span class="subst">$&#123;parseLessNumber(percent)&#125;</span>))`</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">`rgba(<span class="subst">$&#123;red&#125;</span>,<span class="subst">$&#123;green&#125;</span>,<span class="subst">$&#123;blue&#125;</span>,<span class="subst">$&#123;alpha * parseLessNumber(percent)&#125;</span>)`</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        functions.<span class="title function_">add</span>(<span class="string">&#x27;darken&#x27;</span>, <span class="keyword">function</span> (<span class="params">color, amount, method</span>) &#123;</span><br><span class="line">            .......</span><br><span class="line">            <span class="keyword">if</span> (color.<span class="property">type</span> !== <span class="string">&#x27;Color&#x27;</span>)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`fade function parameter type error: except Color, get <span class="subst">$&#123;color.type&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">const</span> hsl = (<span class="keyword">new</span> <span class="title class_">Color</span>(color.<span class="property">rgb</span>, color.<span class="property">alpha</span>)).<span class="title function_">toHSL</span>();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> method !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; method.<span class="property">value</span> === <span class="string">&#x27;relative&#x27;</span>) &#123;</span><br><span class="line">                hsl.<span class="property">l</span> = hsl.<span class="property">l</span> * (<span class="number">1</span> - <span class="title function_">parseLessNumber</span>(amount));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hsl.<span class="property">l</span> = hsl.<span class="property">l</span> - <span class="title function_">parseLessNumber</span>(amount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">`hsl(<span class="subst">$&#123;hsl.h&#125;</span>,<span class="subst">$&#123;hsl.s&#125;</span>,<span class="subst">$&#123;hsl.l&#125;</span>)`</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="第三步：局部-light-模式如何支持？【postcss-插件】"><a href="#第三步：局部-light-模式如何支持？【postcss-插件】" class="headerlink" title="第三步：局部 light 模式如何支持？【postcss 插件】"></a>第三步：局部 light 模式如何支持？【postcss 插件】</h2><p>点击<a href="https://link.juejin.cn/?target=https://codebase.byted.org/repo/lark/dark-mode-css-var/-/blob/src/css-loader/plugins/postcss-color.js%23L50">这里</a>可以快速定位到源代码。可以在 dom 节点上添加 classname 前缀，用来标注该 dom 下的样式都使用静态的亮色模式，不随主题切换。这里需要做的主要分为 3 步：</p>
<ol>
<li><h3 id="第-1-步：【添加-dom-前缀-classname】"><a href="#第-1-步：【添加-dom-前缀-classname】" class="headerlink" title="第 1 步：【添加 dom 前缀 classname】"></a>第 1 步：【添加 dom 前缀 classname】</h3></li>
</ol>
<p>在相应的 dom 节点添加 classname 前缀，比如 static-light；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来的dom结构</span></span><br><span class="line">&lt;div className=<span class="string">&quot;test&quot;</span>&gt;aaa&lt;/div&gt;</span><br><span class="line"><span class="comment">// 新的dom结构</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;static-light&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;test&quot;</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li><h3 id="第-2-步：【追加前缀样式】"><a href="#第-2-步：【追加前缀样式】" class="headerlink" title="第 2 步：【追加前缀样式】"></a>第 2 步：【追加前缀样式】</h3><ol>
<li>生成样式时，通过 postcss 为所有的样式添加 static-light 前缀；</li>
</ol>
</li>
</ol>
<p>这一步实际上是在 css-loader 的处理过程中加入了一个 postcss 插件，对每条规则<a href="https://link.juejin.cn/?target=https://www.postcss.com.cn/api/%23rule">rule</a>额外生成一条静态样式。</p>
<p>举个例子,我定义了如下的 less 样式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">test</span> &#123;</span><br><span class="line">    background-<span class="attr">color</span>: @<span class="keyword">static</span>-white;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>经过该 postcss 插件之后，生成的产物会变成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">test</span> &#123;</span><br><span class="line">    background-<span class="attr">color</span>: <span class="title function_">var</span>(--<span class="keyword">static</span>-white);</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">static</span>-light .<span class="property">test</span> &#123;</span><br><span class="line">    background-<span class="attr">color</span>: <span class="title function_">var</span>(--<span class="keyword">static</span>-white);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>所以要怎样才能追加生成这样的 css 呢？</p>
<p>可以看到 css-loader 的<a href="https://link.juejin.cn/?target=https://github.com/webpack-contrib/css-loader/blob/master/src/index.js%23L163">源码</a>中，节点都经过了 postcss 插件的处理，我们只需要在插件列表中，加上我们的插件即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = <span class="keyword">await</span> <span class="title function_">postcss</span>([...plugins, <span class="keyword">new</span> <span class="title function_">colorPlugin</span>(&#123;</span><br><span class="line">  <span class="attr">staticEx</span>: &#123;<span class="attr">prefix</span>:<span class="string">&#x27;.static-light&#x27;</span>&#125;,</span><br><span class="line">&#125;)]).<span class="title function_">process</span>(content, &#123;...&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>所以接下来可以实现我们的 postcss 插件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postcss = <span class="built_in">require</span>(<span class="string">&#x27;postcss&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = postcss.<span class="title function_">plugin</span>(<span class="string">&#x27;postcss-color-and-function&#x27;</span>, <span class="keyword">function</span> (<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; staticEx &#125; = options;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">processNode</span>(<span class="params">node, type</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> staticNode;</span><br><span class="line">        <span class="keyword">switch</span> (node.<span class="property">type</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;rule&#x27;</span>:</span><br><span class="line">                staticNode =  node.<span class="title function_">clone</span>();</span><br><span class="line">                staticNode.<span class="property">selectors</span> = staticNode.<span class="property">selectors</span>.<span class="title function_">map</span>(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;options.staticEx.prefix&#125;</span> <span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> staticNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">css</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> last = [];</span><br><span class="line">        css.<span class="title function_">each</span>(<span class="function">(<span class="params">node, type</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> staticNode = <span class="title function_">processNode</span>(node, type);</span><br><span class="line">            <span class="keyword">if</span> (staticNode) &#123;</span><br><span class="line">                last.<span class="title function_">push</span>(staticNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        css.<span class="property">nodes</span> = css.<span class="property">nodes</span>.<span class="title function_">concat</span>(last);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>主要的实现思路是：</p>
<ul>
<li>通过当前节点克隆一个一样的节点，在最后返回的时候拼接该节点，这样可以生成两份样式；</li>
<li>对于克隆的那份节点，追加选择器，</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">staticNode.<span class="property">selectors</span> = staticNode.<span class="property">selectors</span>.<span class="title function_">map</span>(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;options.staticEx.prefix&#125;</span> <span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这样就可以实现追加节点和局部 css 变量定义了。</p>
<blockquote>
<p>注:css-loader 会校验参数，所以如果需要修改传入的参数格式，还需要修改<a href="https://link.juejin.cn/?target=https://github.com/webpack-contrib/css-loader/blob/master/src/options.json%23L197">options.json</a>和<a href="https://link.juejin.cn/?target=https://github.com/webpack-contrib/css-loader/blob/master/src/utils.js%23L628">normalizeOptions</a>。</p>
</blockquote>
<ol>
<li><h3 id="第-3-步：插入一套制定-classname（这里是-static-light）的-css-var-变量。"><a href="#第-3-步：插入一套制定-classname（这里是-static-light）的-css-var-变量。" class="headerlink" title="第 3 步：插入一套制定 classname（这里是 static-light）的 css var 变量。"></a>第 3 步：插入一套制定 classname（这里是 static-light）的 css var 变量。</h3></li>
</ol>
<p>这里我们借助 webpack 的插件来实现，详细内容看下一部分</p>
<h2 id="第四步：追加全局-css-变量定义【webpack-插件】"><a href="#第四步：追加全局-css-变量定义【webpack-插件】" class="headerlink" title="第四步：追加全局 css 变量定义【webpack 插件】"></a>第四步：追加全局 css 变量定义【webpack 插件】</h2><p>我们可以定义一下 css 变量，就可以生效了，添加@media (prefers-color-scheme: dark)可以在系统模式变化的时候切换 css 变量，就可以实现样式的切换。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line"> <span class="attr">--bg-body</span>: <span class="string">&quot;#1f1f1f&quot;</span>;</span><br><span class="line"> <span class="attr">--static-white</span>: <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme</span>: dark) &#123;</span><br><span class="line">    <span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">     <span class="attr">--bg-body</span>: <span class="string">&quot;#2f2f2f&quot;</span>;</span><br><span class="line">     <span class="attr">--static-white</span>: <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面一小节中，我们还需要追加局部 light 样式对应的 css 变量，需要在上述变量的基础上追加下面的一段代码。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line"> <span class="attr">--bg-body</span>: <span class="string">&quot;#1f1f1f&quot;</span>;</span><br><span class="line"> <span class="attr">--static-white</span>: <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme</span>: dark) &#123;</span><br><span class="line">    <span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">     <span class="attr">--bg-body</span>: <span class="string">&quot;#2f2f2f&quot;</span>;</span><br><span class="line">     <span class="attr">--static-white</span>: <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.static-light</span> &#123;</span><br><span class="line"> <span class="attr">--bg-body</span>: <span class="string">&quot;#1f1f1f&quot;</span>;</span><br><span class="line"> <span class="attr">--static-white</span>: <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这样我们手动追加变量就会变得复杂，并且容易出错，所以我们可以利用 webpack 插件进行追加，webpack 提供了各种钩子，我们可以利用这些生命周期钩子在合适的时机执行相应的逻辑。</p>
<ol>
<li><h3 id="第-1-步：【生成-css-文件】"><a href="#第-1-步：【生成-css-文件】" class="headerlink" title="第 1 步：【生成 css 文件】"></a>第 1 步：【生成 css 文件】</h3><ol>
<li>我们需要保证生成 css 文件只会执行一次，并且保证生成文件在插入 link 标签之前，HtmlWebpackPlugin 插件提供的生命周期钩子函数<a href="https://link.juejin.cn/?target=https://github.com/jantimon/html-webpack-plugin%23alterassettags-hook">alterAssetTags</a>，返回当前所有的资源列表，用户可以在此追加一些资源链接，所以我们可以在此生命周期钩子处，触发生成文件。</li>
</ol>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">compiler.<span class="property">hooks</span>.<span class="property">compilation</span>.<span class="title function_">tap</span>(<span class="string">&#x27;LarkThemePlugin&#x27;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">HtmlWebpackPlugin</span>.<span class="title function_">getHooks</span>(compilation).<span class="property">alterAssetTags</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;LarkThemePlugin&#x27;</span>, <span class="function">(<span class="params">data, cb</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> source = xxx;</span><br><span class="line">        compilation.<span class="property">assets</span>[<span class="string">&#x27;theme.css&#x27;</span>] = &#123; <span class="attr">source</span>: <span class="function">() =&gt;</span> source, <span class="attr">size</span>: <span class="function">() =&gt;</span> <span class="title class_">Buffer</span>.<span class="title function_">byteLength</span>(source, <span class="string">&#x27;utf-8&#x27;</span>)&#125;;</span><br><span class="line">      <span class="title function_">cb</span>(<span class="literal">null</span>,data);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li><h3 id="第-2-步：生成-link-标签引用："><a href="#第-2-步：生成-link-标签引用：" class="headerlink" title="第 2 步：生成 link 标签引用："></a>第 2 步：生成 link 标签引用：</h3><ol>
<li>上一步生成了 css 资源文件，我们需要在 html 中追加一个 link 标签，引用该 css 资源，在实际应用中，我们往往会有很多资源标签插入到 html 中，而我们又希望该标签可以插入到所有资源文件之前进行加载</li>
</ol>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">compiler.<span class="property">hooks</span>.<span class="property">compilation</span>.<span class="title function_">tap</span>(<span class="string">&#x27;LarkThemePlugin&#x27;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">HtmlWebpackPlugin</span>.<span class="title function_">getHooks</span>(compilation).<span class="property">alterAssetTags</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;LarkThemePlugin&#x27;</span>, <span class="function">(<span class="params">data, cb</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">assetTags</span>: &#123; styles &#125;&#125; = data;</span><br><span class="line">      styles.<span class="title function_">unshift</span>(&#123;</span><br><span class="line">        <span class="attr">tagName</span>: <span class="string">&#x27;link&#x27;</span>,</span><br><span class="line">        <span class="attr">voidTag</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">attributes</span>: &#123;</span><br><span class="line">          <span class="attr">href</span>: <span class="string">&#x27;theme.css&#x27;</span>,</span><br><span class="line">          <span class="attr">rel</span>: <span class="string">&#x27;stylesheet&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="title function_">cb</span>(<span class="literal">null</span>,data);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>完整的 webpack 插件代码在下方：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; getRootCSSVarMap &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../util&#x27;</span>);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InjectThemeWebpackPlugin</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">&#123; lessVarsSet, darkTokens, lightTokens &#125;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">darkTokens</span> = darkTokens;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">lightTokens</span> = lightTokens;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成css变量的css样式</span></span><br><span class="line">    <span class="title function_">generateResult</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">generateCss</span> = (<span class="params">cssObj</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> css = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> cssObj) &#123;</span><br><span class="line">            <span class="keyword">const</span> value = cssObj[key];</span><br><span class="line">            css += <span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>;`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`:root&#123;<span class="subst">$&#123;css&#125;</span>&#125;`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> darkCSSObj = <span class="title function_">getRootCSSVarMap</span>(<span class="variable language_">this</span>.<span class="property">darkTokens</span>, <span class="string">&#x27;DARK&#x27;</span>);</span><br><span class="line">      <span class="keyword">const</span> lightCSSObj = <span class="title function_">getRootCSSVarMap</span>(<span class="variable language_">this</span>.<span class="property">lightTokens</span>, <span class="string">&#x27;LIGHT&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;generateCss(lightCSSObj)&#125;</span>\n@media (prefers-color-scheme: dark) &#123;<span class="subst">$&#123;generateCss(darkCSSObj)&#125;</span>&#125;`</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">      <span class="comment">// 追加link标签</span></span><br><span class="line">      compiler.<span class="property">hooks</span>.<span class="property">compilation</span>.<span class="title function_">tap</span>(<span class="string">&#x27;LarkThemePlugin&#x27;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">HtmlWebpackPlugin</span>.<span class="title function_">getHooks</span>(compilation).<span class="property">alterAssetTags</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;LarkThemePlugin&#x27;</span>, <span class="function">(<span class="params">data, cb</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> source = <span class="variable language_">this</span>.<span class="title function_">generateResult</span>();</span><br><span class="line">          compilation.<span class="property">assets</span>[<span class="string">&#x27;theme.css&#x27;</span>] = &#123; <span class="attr">source</span>: <span class="function">() =&gt;</span> source, <span class="attr">size</span>: <span class="function">() =&gt;</span> <span class="title class_">Buffer</span>.<span class="title function_">byteLength</span>(source, <span class="string">&#x27;utf-8&#x27;</span>)&#125;;</span><br><span class="line">          <span class="keyword">const</span> &#123; <span class="attr">assetTags</span>: &#123; styles &#125;&#125; = data;</span><br><span class="line">          styles.<span class="title function_">unshift</span>(&#123;</span><br><span class="line">            <span class="attr">tagName</span>: <span class="string">&#x27;link&#x27;</span>,</span><br><span class="line">            <span class="attr">voidTag</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">attributes</span>: &#123;</span><br><span class="line">              <span class="attr">href</span>: <span class="string">&#x27;theme.css&#x27;</span>,</span><br><span class="line">              <span class="attr">rel</span>: <span class="string">&#x27;stylesheet&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="title function_">cb</span>(<span class="literal">null</span>,data);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">InjectThemeWebpackPlugin</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：这里需要注意，需要保证<code>html-webpack-plugin</code>插件一直是一个，不然会出现无法追加上 link 标签的情况</p>
</blockquote>
]]></content>
      <categories>
        <category>Chore</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>序 / Intro</title>
    <url>/2024/09/30/%E5%BA%8F%E8%A8%80/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
    <p><b>循着无私与弃绝之念走在自我修行的道路上</b></p>
    <!-- <p>[英]威廉·萨默塞特·毛姆 《刀锋》</p> -->
</blockquote>

<!-- 为什么要写博客？
> http://nathanmarz.com/blog/you-should-blog-even-if-you-have-no-readers.html
- 1、锻炼表达能力；
- 2、积累知识点；
- 3、帮助自己快速找回曾经熟悉的内容；
- 4、逼迫自己思考一些问题，将知识从点变成线或者网；
- 5、增强自己在圈子内的影响力。 -->]]></content>
  </entry>
  <entry>
    <title>微信小程序</title>
    <url>/2025/03/12/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
    <p><b>狗都不用</b></p>
</blockquote>

<h2 id="练手项目："><a href="#练手项目：" class="headerlink" title="练手项目："></a>练手项目：</h2><h2 id="微信小程序UI组件库"><a href="#微信小程序UI组件库" class="headerlink" title="微信小程序UI组件库"></a>微信小程序UI组件库</h2><ul>
<li><a href="https://juejin.cn/post/7185079118126383141?searchId=202504191028103A7CC0AB11CE0627E38B">https://juejin.cn/post/7185079118126383141?searchId=202504191028103A7CC0AB11CE0627E38B</a></li>
</ul>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>站点更新日志 / ChangeLog</title>
    <url>/2024/10/28/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<!-- ### 前言
兜兜转转终于是有时间把这个站点建起来了;D，本文主要是记录下站点更新日志，会按月进行归档，还会简单写一下后续更新的一些想法和计划

想法还有很多

功能上非常想做的是个一言主题的页面，还有日间/夜间模式切换，日程表、sitemap功能
内容上可以补充的还有个人简介
工程上能做的有域名简化（自定义域名），blog自动化部署（借助一些Github Webhooks），CDN加速（腾讯云），页面SEO相关优化

那么，拭目以待吧~

------ -->

<!-- ### 后续更新计划
**自定义域名（SSL证书、地址映射）**
**日间/夜间模式切换**
**添加一言主题页面**
**添加个人简介**
**blog自动化部署**
**日程表、sitemap探索**

------ -->

<h3 id="2024-11、2024-12更新"><a href="#2024-11、2024-12更新" class="headerlink" title="2024-11、2024-12更新"></a>2024-11、2024-12更新</h3><p>主要是之前前端相关知识的文章整理、比特币相关学习</p>
<ul>
<li><a href="http://localhost:4000/2024/11/05/%E6%AF%94%E7%89%B9%E5%B8%81/">比特币</a></li>
<li><a href="http://localhost:4000/2021/10/01/React%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">React最佳实践</a></li>
<li><a href="http://localhost:4000/2024/11/05/%E6%AF%94%E7%89%B9%E5%B8%81/">Redux</a></li>
<li><a href="http://localhost:4000/2021/09/20/HTTP/">HTTP</a></li>
<li><a href="http://localhost:4000/2021/09/18/HTTP%E7%BC%93%E5%AD%98/">HTTP缓存</a></li>
</ul>
<hr>
<h3 id="2024-10更新"><a href="#2024-10更新" class="headerlink" title="2024-10更新"></a>2024-10更新</h3><p><strong>腾讯云托管站点</strong><br>主要是解决Github Page部署后国内内网无法访问的问题（搜了下是DNS污染的问题，不太好解决，暂时先迁到腾讯云上去托管站点了）</p>
<p><strong>部分文章重新整理一版</strong><br>整理了一系列陈年老文章，主要是一些文章之前的格式在博客里不太兼容，还有部分内容在迁移的过程中有丢失，都加以补充了</p>
<p><strong>文章置顶、排序、显隐功能</strong><br>引了个<code>hexo-generator-index-custom</code>插件来置顶、排序文章</p>
<span id="more"></span>

<hr>
<h3 id="2024-9更新"><a href="#2024-9更新" class="headerlink" title="2024-9更新"></a>2024-9更新</h3><p><strong>Hexo+Next建站</strong><br>基于Hexo V7.3 + Next V8.2 搭建了个人博客站点</p>
<p><strong>搜索功能</strong><br>加入了文章搜索功能。会很好用吧？(大概</p>
<!-- ![](../assets/blog-search-example.png) -->

<p><strong>标签、分类功能</strong><br>所有文章整理了一版，对所有文章分标签、分类展示</p>
<p><strong>文章显示字数统计、浏览时间</strong><br>引入<code>hexo-word-counter</code>这个插件来实现的，还会统计代码字数，算是个锦上添花的功能吧^^</p>
]]></content>
  </entry>
  <entry>
    <title>微信小程序开发</title>
    <url>/2025/06/05/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="微信小程序开发"><a href="#微信小程序开发" class="headerlink" title="微信小程序开发"></a>微信小程序开发</h2>]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币</title>
    <url>/2024/11/05/%E6%AF%94%E7%89%B9%E5%B8%81/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
    <p><b>不要被学术界的思维限制了头脑，不要被程序员的思维限制了想象力。</b></p>
</blockquote>

<h2 id="比特币中的密码学"><a href="#比特币中的密码学" class="headerlink" title="比特币中的密码学"></a>比特币中的密码学</h2><h3 id="比特币中的哈希特性"><a href="#比特币中的哈希特性" class="headerlink" title="比特币中的哈希特性"></a>比特币中的哈希特性</h3><!-- > 容易验证，不容易计算 -->
<h4 id="Collision-resistance-抗哈希碰撞"><a href="#Collision-resistance-抗哈希碰撞" class="headerlink" title="Collision resistance (抗哈希碰撞)"></a>Collision resistance (抗哈希碰撞)</h4><blockquote>
<p>没有高效的方法来人为的制造哈希碰撞</p>
</blockquote>
<ul>
<li><strong>Collision resistance的定义</strong>：给定X，没有高效的方法找到Y，使得H(X) &#x3D; H(Y)</li>
<li><strong>Collision resistance的特性</strong>：无法用数学证明</li>
<li><strong>MD5哈希函数</strong>：以前认为是Collision resistance，后来被鉴定为不安全的哈希函数，可通过人为的方式制造哈希碰撞</li>
<li><strong>比特币中使用的哈希函数</strong>：SHA-256（Secure Hash Algorithm）</li>
</ul>
<h4 id="Hiding"><a href="#Hiding" class="headerlink" title="Hiding"></a>Hiding</h4><blockquote>
<p>哈希的过程单向不可逆</p>
</blockquote>
<ul>
<li><strong>Hiding的定义</strong>：输入值的空间够大，且分布均匀，取值可能性相同<br>实际场景如何实现Hiding（保证分布均匀）：输入值 + 随机数（输入X || nonce随机数）后经过Hash</li>
</ul>
<h4 id="Puzzle-friendly"><a href="#Puzzle-friendly" class="headerlink" title="Puzzle friendly"></a>Puzzle friendly</h4><blockquote>
<p>事先无法知道什么样的输入能得到一个什么样的哈希值，只能一个个尝试</p>
</blockquote>
<p>比如挖矿，H(nonce + block header) &lt;&#x3D; target，没有捷径，只能去尝试多个nonce来找到解 &#x3D;&gt; proof of work</p>
<h3 id="比特币中的账户管理"><a href="#比特币中的账户管理" class="headerlink" title="比特币中的账户管理"></a>比特币中的账户管理</h3><p>非对称加密（asymmetric encryption algorithm）：加密解密不用同一个密钥，加密用公钥，解密用私钥<br>去中心化，每个用户本地自己生成一组公钥和私钥，公钥相当于银行账号，私钥相当于账号密码<br>比特币交易过程中，为了能知道交易是由谁发起，需要用私钥将交易签名，公钥验证</p>
<p>两个人生成的公钥私钥相同怎么办（256位的值，产生两组相同公钥私钥的概率微乎其微）</p>
<p>message取hash-&gt;hash取签名</p>
<span id="more"></span>

<h2 id="比特币的数据结构"><a href="#比特币的数据结构" class="headerlink" title="比特币的数据结构"></a>比特币的数据结构</h2><h3 id="Block-chain（区块链）"><a href="#Block-chain（区块链）" class="headerlink" title="Block chain（区块链）"></a>Block chain（区块链）</h3><blockquote>
<p>本质上是一个链表，通过Hash pointers相连</p>
</blockquote>
<h4 id="Hash-pointers（哈希指针）"><a href="#Hash-pointers（哈希指针）" class="headerlink" title="Hash pointers（哈希指针）"></a>Hash pointers（哈希指针）</h4><p>当前区块的地址<br>前一个哈希指针 + 当前区块计算出的哈希值 </p>
<h4 id="Genesis-block（创始区块）"><a href="#Genesis-block（创始区块）" class="headerlink" title="Genesis block（创始区块）"></a>Genesis block（创始区块）</h4><p>区块链中的第一个区块</p>
<h4 id="Most-recent-block（最近使用区块）"><a href="#Most-recent-block（最近使用区块）" class="headerlink" title="Most recent block（最近使用区块）"></a>Most recent block（最近使用区块）</h4><p>区块链末尾的区块，指的是最近被添加到区块链的区块</p>
<h4 id="Block（区块）"><a href="#Block（区块）" class="headerlink" title="Block（区块）"></a>Block（区块）</h4><p>每一个区块构成：</p>
<h5 id="Block-header"><a href="#Block-header" class="headerlink" title="Block header"></a>Block header</h5><blockquote>
<p>只有Block header会用Hash pointer串联</p>
</blockquote>
<ul>
<li>Version（用的是比特币哪个版本的协议）</li>
<li>Hash of previous block header（前一个区块头的hash）</li>
<li>Merkle root hash（merkle tree的根哈希，能保证Block body里的Transaction list没有被篡改）</li>
<li>Target（挖矿的难度目标阈值, H(block header) &lt;&#x3D; target, block header这里存的是目标阈值的编码nbits）</li>
<li>Nonce（随机数）</li>
</ul>
<h5 id="Block-body"><a href="#Block-body" class="headerlink" title="Block body"></a>Block body</h5><ul>
<li>Transaction list（交易列表）</li>
</ul>
<h3 id="Merkle-tree（默克尔树）"><a href="#Merkle-tree（默克尔树）" class="headerlink" title="Merkle tree（默克尔树）"></a>Merkle tree（默克尔树）</h3><p>比特币中各个区块用Hash Pointer连接在一起，各个区块包含的交易信息是组织成Merkle tree的形式<br>Merkle tree结构：二叉树的形式，最底层是交易记录，中间层都是下一层哈希值计算出的结果，树中的root hash可以用来判断是否有一个节点发生变更，因为任何一个节点的变更都会导致root hash发生变化<br><img src="/../assets/merkle-tree.png" alt="image-20241105"></p>
<p>比特币节点分类</p>
<ul>
<li>Full node（全节点）：保存区块的全部信息，Block header + Block body，用于验证每一个交易，又叫 Fully validating node</li>
<li>Light node（轻节点）：手机上的比特币钱包，只保存Block header（也就是只保存了Merkle tree的Root hash），无法独立验证交易的可靠性，系统中大部分节点是轻节点</li>
</ul>
<p>如何向轻节点证明某个交易已经被写入区块链？<br>用户A，用户B（轻节点），转账 A –&gt; B，A需要向B证明已经转账，如何证明：Merkle proof&#x2F;Proof of menbership：证明Merkle tree包含了某个交易，时间复杂度为 O(logn)<br>过程详见：<br><img src="/../assets/merkle-proof.png" alt="image-20241105"></p>
<blockquote>
<p>全节点把缺失信息发给轻节点，轻节点通过计算验证Root Hash相同，则代表交易已被写入到区块里</p>
</blockquote>
<p>全节点发送的哈希值可能被伪造吗，来保持上层的哈希值符合要求？<br>不行，因为哈希满足<strong>Collision resistance</strong>的特性，无法人为制造哈希碰撞</p>
<p>Proof of non-menbership（证明交易记录不在树里）：</p>
<ul>
<li>全节点发送整颗merkle tree给轻节点，轻节点验证各个节点、各层有没有出现问题，如果都没问题，证明只有这些叶子节点，则只需要判断叶子节点有没有包含该交易记录。复杂度 O(n)</li>
<li>假定叶子结点</li>
</ul>
<p>无环的数据结构都可以用hash pointer代替普通指针</p>
<h2 id="比特币的共识协议"><a href="#比特币的共识协议" class="headerlink" title="比特币的共识协议"></a>比特币的共识协议</h2><p>比特币的交易过程<br><img src="/../assets/bitcon-trading-process.png" alt="image-20241105"></p>
<p>比特币中区块的指针</p>
<ul>
<li>指向前一个区块</li>
<li>指向币的来源：证明钱不是凭空捏造，是有记录的，防止Double spending</li>
</ul>
<p>转账：A -&gt; B A需要知道B的公钥，B也需要知道A的公钥，<br>签名验证的过程？不太理解<br>交易记录通过A的私钥加密后 – 接收方通过A的公钥解密</p>
<p>如何写入区块链？</p>
<p>账本内容需要取得分布式的共识（distributed consensus）：一致性<br>Cap Theorem: 只能同时满足其中两个特性<br>Consistency（一致性）<br>Availability（可用性）<br>Partition tolerance（分区容错性：</p>
<p>Paxos协议：</p>
<p>Consensus in Bitcoin（解决的问题：存在恶意节点，假设大多数节点好的，少部分恶意节点，如何设计一个共识协议）</p>
<ul>
<li>直接投票是否可行？女巫攻击–恶意节点生成超过半数以上的账号，获取投票权</li>
</ul>
]]></content>
      <categories>
        <category>Web3/加密货币</category>
      </categories>
      <tags>
        <tag>Web3</tag>
        <tag>比特币</tag>
        <tag>加密货币</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器架构和事件循环</title>
    <url>/2021/10/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h3 id="chrome浏览器架构"><a href="#chrome浏览器架构" class="headerlink" title="chrome浏览器架构"></a>chrome浏览器架构</h3><p>Chrome 采用多进程架构，其顶层存在一个 Browser process 用以协调浏览器的其它进程。</p>
<ul>
<li>Browser Process：</li>
</ul>
<ol>
<li><p>负责包括地址栏，书签栏，前进后退按钮等部分的工作；</p>
</li>
<li><p>负责处理浏览器的一些不可见的底层操作，比如网络请求和文件访问；</p>
</li>
</ol>
<ul>
<li>Renderer Process：</li>
</ul>
<ol>
<li>负责一个 tab 内关于网页呈现的所有事情</li>
</ol>
<ul>
<li>Plugin Process：</li>
</ul>
<ol>
<li>负责控制一个网页用到的所有插件，如 flash</li>
</ol>
<ul>
<li>GPU Process</li>
</ul>
<ol>
<li>负责处理 GPU 相关的任务</li>
</ol>
<p><img src="/../assets/image-20210930012419754.png" alt="image-20210930012419754"></p>
<p>由于一个tab标签页都有一个独立的渲染进程，所以一个tab异常崩溃后，其他tab不会受到影响。</p>
<p>一个渲染进程包括</p>
<ul>
<li>JS引擎线程</li>
<li>HTTP请求线程</li>
<li>定时触发线程</li>
<li>事件触发线程</li>
<li>GUI线程</li>
</ul>
<h3 id="浏览器JS异步执行原理"><a href="#浏览器JS异步执行原理" class="headerlink" title="浏览器JS异步执行原理"></a>浏览器JS异步执行原理</h3><p>执行JS代码的线程只有一个，是浏览器提供的JS引擎线程，浏览器中还有</p>
<p><img src="/../image/image-20210930012033902.png" alt="image-20210930012033902"></p>
<span id="more"></span>

<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p><img src="/../image/image-20210930190158487.png" alt="image-20210930190158487"></p>
<p>js引擎解析代码时，遇到同步任务-&gt;放入执行栈直接执行，遇到异步任务（比如ajax），交给网络线程处理，完成后将对应回调放入异步任务队列，<strong>当执行栈清空时，循环检测异步任务队列，将异步队列中的回调放入执行栈中执行。</strong></p>
<h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><p><strong>Dom渲染会在微任务结束后，宏任务执行前</strong></p>
<h4 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h4><table>
<thead>
<tr>
<th>#</th>
<th>浏览器</th>
<th>Node</th>
</tr>
</thead>
<tbody><tr>
<td><code>I/O</code></td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><code>setTimeout</code></td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><code>setInterval</code></td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><code>setImmediate</code></td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><code>requestAnimationFrame</code></td>
<td>✅</td>
<td>❌</td>
</tr>
</tbody></table>
<h4 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h4><table>
<thead>
<tr>
<th>#</th>
<th>浏览器</th>
<th>Node</th>
</tr>
</thead>
<tbody><tr>
<td><code>process.nextTick</code></td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><code>MutationObserver</code></td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td><code>Promise.then catch finally</code></td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody></table>
<h3 id="事件循环加入宏任务微任务"><a href="#事件循环加入宏任务微任务" class="headerlink" title="事件循环加入宏任务微任务"></a>事件循环加入宏任务微任务</h3><ol>
<li>Call Stack调用栈清空</li>
<li><strong>清空</strong>当前微任务队列</li>
<li>尝试DOM渲染</li>
<li>执行event loop </li>
<li>取出任务队列里的一个宏任务，入栈执行</li>
<li>返回1</li>
</ol>
<p>对于以下demo</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">r</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">r</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 1 4 2 5 3 6</span></span><br></pre></td></tr></table></figure>

<p><code>Promise.prototype.then()</code> 会隐式返回一个新 Promise</p>
<p>如果 Promise 的状态是 pending，那么 <code>then</code> 会在该 Promise 上注册一个回调，当其状态发生变化时，对应的回调将作为一个微任务被推入微任务队列</p>
<p>如果 Promise 的状态已经是 fulfilled 或 rejected，那么 <code>then()</code> 会立即创建一个微任务，将传入的对应的回调推入微任务队列</p>
<p>对于以下demo：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise in timeout&#x27;</span>);</span><br><span class="line">            <span class="title function_">resolve</span>();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise after timeout&#x27;</span>);</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise4&#x27;</span>);</span><br><span class="line">        <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;7777&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise5&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;99999&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise3&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// promise after timeout</span></span><br><span class="line"><span class="comment">// end</span></span><br><span class="line"><span class="comment">// promise3</span></span><br><span class="line"><span class="comment">// promise in timeout</span></span><br><span class="line"><span class="comment">// promise4</span></span><br><span class="line"><span class="comment">// 7777</span></span><br><span class="line"><span class="comment">// promise5</span></span><br><span class="line"><span class="comment">// 99999</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Chore</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
</search>
