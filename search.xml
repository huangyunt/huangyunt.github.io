<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS</title>
    <url>/2021/02/07/CSS/</url>
    <content><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近看了两本书《CSS揭秘》和《CSS权威指南》恶补一下CSS（自己真是菜到天际），记录一些有意思的问题</p>
<span id="more"></span>

<h3 id="1-CSS高度由什么决定？"><a href="#1-CSS高度由什么决定？" class="headerlink" title="1. CSS高度由什么决定？"></a>1. CSS高度由什么决定？</h3><h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4><p>一个块级元素div的高度一般是与自身的<strong>CSS样式</strong>和<strong>内部元素的高度总和</strong>有关</p>
<ul>
<li><code>div</code>设置了height后，整个盒模型的高度基本确定，其内部元素再高也无法改变<code>div</code>的高度</li>
<li>当<code>div</code>不设置height时，其高度和内部文档流元素高度的总和有关</li>
</ul>
<h5 id="块级元素不设置高度，内有块级元素时"><a href="#块级元素不设置高度，内有块级元素时" class="headerlink" title="块级元素不设置高度，内有块级元素时"></a>块级元素不设置高度，内有块级元素时</h5><p>会被子元素的height、padding、border撑起来</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    *&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.parent</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">outline</span>: <span class="number">5px</span> solid red;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.child</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>:<span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">5px</span> solid green;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如图，父级元素不设高度，高度为子元素height+border</p>
<div style="display: flex; justify-content: center; align-items: center;">
    <img src="C:\Users\H\AppData\Roaming\Typora\typora-user-images\image-20211120195130235.png"
        alt="image-20211120195130235" style="zoom:50%;" />
    <img src="C:\Users\H\AppData\Roaming\Typora\typora-user-images\image-20211120195056819.png"
        alt="image-20211120195056819" style="zoom:50%;" />
</div>



<h5 id="子元素设置margin时"><a href="#子元素设置margin时" class="headerlink" title="子元素设置margin时"></a>子元素设置margin时</h5><p>父元素高度无法被子元素垂直方向上margin撑开</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    * &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">outline</span>: <span class="number">5px</span> solid red;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">5px</span> solid green;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div style="display: flex; justify-content: center; align-items: center;">
    <img src="C:\Users\H\AppData\Roaming\Typora\typora-user-images\image-20211120202203417.png"
        alt="image-20211120202203417" style="zoom:50%;" />
    <img src="C:\Users\H\AppData\Roaming\Typora\typora-user-images\image-20211120202344779.png"
        alt="image-20211120202344779" style="zoom:50%;" />
</div>

<p><strong>解决方案：父元素设置border&#x2F;padding&#x2F;overflow：hidden</strong></p>
<p><strong>总结：父元素高度能被子元素的height、border、padding撑开，如果父元元素在垂直方向上有<code>border</code>,<code>padding</code>（只要在逻辑上存在，不论大小）以及<code>overflow:hidden</code>，都能被子元素的<code>margin</code>撑开，否则只能撑开父元素的宽度</strong></p>
<h3 id="2-CSS宽度由什么决定？"><a href="#2-CSS宽度由什么决定？" class="headerlink" title="2. CSS宽度由什么决定？"></a>2. CSS宽度由什么决定？</h3><h4 id="行内-行内块元素"><a href="#行内-行内块元素" class="headerlink" title="行内&#x2F;行内块元素"></a>行内&#x2F;行内块元素</h4><p>行内元素&#x2F;行内块的宽度是由它的内容决定的，行内元素不能设置宽高</p>
<h4 id="块级元素-1"><a href="#块级元素-1" class="headerlink" title="块级元素"></a>块级元素</h4><p>一个块级元素宽度当不设置样式时默认为父级元素的100%<strong>（这个100%是自适应的，并不相当于width：100%）</strong></p>
<h3 id="3-为什么margin-top-padding-top设置百分比基于父元素的宽度计算的？"><a href="#3-为什么margin-top-padding-top设置百分比基于父元素的宽度计算的？" class="headerlink" title="3. 为什么margin-top&#x2F;padding-top设置百分比基于父元素的宽度计算的？"></a>3. 为什么margin-top&#x2F;padding-top设置百分比基于父元素的宽度计算的？</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">5px</span> solid red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.child</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin-top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="C:\Users\H\AppData\Roaming\Typora\typora-user-images\image-20211120194334386.png" alt="image-20211120194334386" style="zoom:50%;" />

<p>这里利用margin-top：50%将子元素挤到最下方贴底，然而这里的百分比是相对于父级宽度计算的。</p>
<p>CSS权威指南中的解释：若是相对于父元素的高度计算会形成死循环。<br><em><strong>“我们认为，正常流中的大多数元素都会足够高以包含其后代元素（包括外边距），如果一个元素的上下外边距是父元素的height的百分数，就可能导致一个无限循环，父元素的height会增加，以适应后代元素上下外边距的增加，而相应的，上下外边距因为父元素height的增加也会增加，形成无限循环。”</strong></em></p>
<p><strong>本质上是因为css中高度是可以自适应的，基于父级高度的百分比计算会导致无限循环的问题</strong>。</p>
<h3 id="4-flex：1"><a href="#4-flex：1" class="headerlink" title="4. flex：1"></a>4. flex：1</h3><p><code>flex：x</code> 相当于 <code>flex-grow: x，flex-shrink：1，flex-basis：0%；</code></p>
<p><code> flex-grow: 定义项目的放大比例,0为不放大</code></p>
<p><code>flex-shrink: 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 </code></p>
<p><code>flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。   </code></p>
<figure class="highlight plaintext"><figcaption><span>``` 的含义是分配**主轴**方向上的剩余空间！</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">所以对于竖直的两栏布局，只需要改变一下主轴方向即可</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    body &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">        width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    .f-box &#123;</span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">        border: 5px solid gray;</span><br><span class="line">        height: 100%;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .top &#123;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .bot &#123;</span><br><span class="line">        flex: 1;</span><br><span class="line">        background-color:blue;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;f-box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;bot&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>



<h3 id="5-display：none，visibility：hidden，opacity：0-的区别"><a href="#5-display：none，visibility：hidden，opacity：0-的区别" class="headerlink" title="5. display：none，visibility：hidden，opacity：0  的区别"></a>5. <code>display：none，visibility：hidden，opacity：0</code>  的区别</h3><h4 id="display-none"><a href="#display-none" class="headerlink" title="display: none;"></a>display: none;</h4><ol>
<li>DOM 结构：浏览器不会渲染 display 属性为 none 的元素，不占据空间；</li>
<li><strong>事件监听：无法进行 DOM 事件监听；</strong></li>
<li>性能：动态改变此属性时会引起重排，性能较差；</li>
<li>继承：不会被子元素继承，毕竟子类也不会被渲染；</li>
<li>transition：transition 不支持 display。</li>
</ol>
<h4 id="visibility-hidden"><a href="#visibility-hidden" class="headerlink" title="visibility: hidden;"></a>visibility: hidden;</h4><ol>
<li>DOM 结构：元素被隐藏，但是会被渲染不会消失，占据空间；</li>
<li><strong>事件监听：无法进行 DOM 事件监听；</strong></li>
<li>性 能：动态改变此属性时会引起重绘，性能较高；</li>
<li>继 承：会被子元素继承，子元素可以通过设置 visibility: visible; 来取消隐藏；</li>
<li>transition：visibility 会立即显示，隐藏时会延时</li>
</ol>
<h4 id="opacity-0"><a href="#opacity-0" class="headerlink" title="opacity: 0;"></a>opacity: 0;</h4><ol>
<li>DOM 结构：透明度为 100%，元素隐藏，占据空间；</li>
<li><strong>事件监听：可以进行 DOM 事件监听；</strong></li>
<li>性 能：提升为合成层，不会触发重绘，性能较高；</li>
<li>继 承：会被子元素继承,且，子元素并不能通过 opacity: 1 来取消隐藏；</li>
<li>transition：opacity 可以延时显示和隐藏</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hooks</title>
    <url>/2021/10/12/Hooks/</url>
    <content><![CDATA[<h3 id="hooks的作用"><a href="#hooks的作用" class="headerlink" title="hooks的作用"></a>hooks的作用</h3><p><strong>钩子（hook）就是 React 函数组件的副效应解决方案，用来为函数组件引入副效应。</strong> 函数组件的主体只应该用来返回组件的 HTML 代码，所有的其他操作（副效应）都必须通过钩子引入。</p>
<p>由于副效应非常多，所以钩子有许多种。React 为许多常见的操作（副效应），都提供了专用的钩子。</p>
<ul>
<li><code>useState()</code>：保存状态</li>
<li><code>useContext()</code>：保存上下文</li>
<li><code>useRef()</code>：保存引用</li>
<li>……</li>
</ul>
<p>上面这些钩子，都是引入某种特定的副效应，而 <strong><code>useEffect()</code>是通用的副效应钩子</strong> 。找不到对应的钩子时，就可以用它。其实，从名字也可以看出来，它跟副效应（side effect）直接相关。</p>
<span id="more"></span>

<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p><code>useEffect()</code>本身是一个函数，由 React 框架提供，在函数组件内部调用即可。</p>
<p>例如：</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;加载完成&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面例子中，<code>useEffect()</code>的参数是一个函数，它就是所要完成的副效应（改变网页标题）。组件加载以后，React 就会执行这个函数。</p>
<p><code>useEffect()</code>的作用就是指定一个副效应函数，组件每渲染一次，该函数就执行一次。<strong>组件首次在网页 DOM 加载后，副效应函数也会执行。</strong></p>
<h5 id="useEffect指定依赖项"><a href="#useEffect指定依赖项" class="headerlink" title="useEffect指定依赖项"></a>useEffect指定依赖项</h5><p>有时候，我们不希望<code>useEffect()</code>每次渲染都执行，这时可以使用它的第二个参数，使用一个数组指定副效应函数的依赖项，只有依赖项发生变化，才会执行。</p>
<p>如果上例改为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;加载完成&#x27;</span>;</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>便只会在组件首次挂载时执行函数，相当于class component中的componentDidMount</p>
<h5 id="useEffect-的用途"><a href="#useEffect-的用途" class="headerlink" title="useEffect() 的用途"></a>useEffect() 的用途</h5><p>只要是副效应，都可以使用<code>useEffect()</code>引入。它的常见用途有下面几种。</p>
<ul>
<li>获取数据（data fetching）</li>
<li>事件监听或订阅（setting up a subscription）</li>
<li>改变 DOM（changing the DOM）</li>
<li>输出日志（logging）</li>
</ul>
<h5 id="useEffect返回值"><a href="#useEffect返回值" class="headerlink" title="useEffect返回值"></a>useEffect返回值</h5><p>副效应是随着组件加载而发生的，那么组件卸载时，可能需要清理这些副效应。</p>
<p><code>useEffect()</code>允许返回一个函数，在组件卸载时，执行该函数，清理副效应。如果不需要清理副效应，<code>useEffect()</code>就不用返回任何值。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = props.<span class="property">source</span>.<span class="title function_">subscribe</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    subscription.<span class="title function_">unsubscribe</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [props.<span class="property">source</span>]);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面例子中，<code>useEffect()</code>在组件加载时订阅了一个事件，并且返回一个清理函数，在组件卸载时取消订阅。</p>
<p><strong>实际使用中，由于副效应函数默认是每次渲染都会执行，所以清理函数不仅会在组件卸载时执行一次，每次副效应函数重新执行之前，也会执行一次，用来清理上一次渲染的副效应。</strong></p>
<h5 id="useEffect常见问题"><a href="#useEffect常见问题" class="headerlink" title="useEffect常见问题"></a>useEffect常见问题</h5><p><strong>使用useEffect应该在依赖的变量中指明定义的函数会用到哪些state或者props</strong></p>
<p>effect 可能会使用一些频繁变化的值。可能会忽略依赖列表中 state，但这通常会引起 Bug：<span name = "233"> </span></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">      <span class="title function_">setCount</span>(count + <span class="number">1</span>); <span class="comment">// 这个 effect 依赖于 `count` state    </span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, []); <span class="comment">// 🔴 Bug: `count` 没有被指定为依赖</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入空的依赖数组 <code>[]</code>，意味着该 hook 只在组件挂载时运行一次，并非重新渲染时。但如此会有问题，在 <code>setInterval</code> 的回调中，<code>count</code> 的值不会发生变化。因为当 effect 执行时，<strong>react会创建一个闭包，并将 <code>count</code> 的值被保存在该闭包当中，且初值为 <code>0</code>。每隔一秒，回调就会执行 <code>setCount(0 + 1)</code>，因此，<code>count</code> 永远不会超过 1。</strong></p>
<p>指定 <code>[count]</code> 作为依赖列表就能修复这个 Bug，但会导致每次改变发生时定时器都被重置。事实上，每个 <code>setInterval</code> 在被清除前都会调用一次（等于说直接使用 <code>setTimeout</code>就行了）。要解决这个问题，可以使用类似setState函数式更新的操作，不依赖外部count变量，它允许我们指定 state 该如何改变而不用引用state或者props</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount</span>(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>); <span class="comment">// ✅ 在这不依赖于外部的 `count` 变量    &#125;, 1000);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, []); <span class="comment">// ✅ 我们的 effect 不使用组件作用域中的任何变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="useLayoutEffect-vs-useEffect"><a href="#useLayoutEffect-vs-useEffect" class="headerlink" title="useLayoutEffect vs. useEffect"></a>useLayoutEffect vs. useEffect</h5><p>useLayoutEffect 和 useEffect 的传参一致，但有以下区别</p>
<ol>
<li>执行时机不同。useLayoutEffect 的入参函数会在 react 更新 DOM 树后同步调用（<strong>其实就是dom树更新，浏览器重绘前会执行useLayoutEffect里的函数，此时比如去拿 style 或者 dom 尺寸，都是游览器即将渲染的那一次的尺寸，而不是现在页面上展示的尺寸</strong>），useEffect 为异步调用（useEffect 则肯定是在游览器渲染完后才执行），所以应该尽可能使用标准的 <code>useEffect</code> 以避免阻塞视觉更新</li>
<li>useLayoutEffect 在 development 模式下 SSR 会有警告⚠️</li>
</ol>
<p>通常情况下 useLayoutEffect 会用在做动效和记录 layout 的一些特殊场景（比如防止渲染闪烁，在渲染前再给你个机会去改 DOM）。一般不需要使用 useLayoutEffect。</p>
<p>React 组件是一个树形结构，且每个节点都是懒计算的（类似于 Thunk 的概念）。当一个节点不需要重新计算（重绘）时，他的子树都不会计算（重绘）。<strong>所以我们做性能优化的目标，就是在尽量离根节点近的位置，拦截不必要的节点重算，从而减少重绘的计算量。</strong></p>
<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p>当需要存放一个数据，需要无论在哪里都取到最新状态时，需要使用 useRef，<strong>ref 是一种可变数据。</strong><br>如上文提到的代码段中，因为存在闭包问题，count永远会为1，log永远为0；<br>可以引入<code>useRef</code>解决这个问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> currentCount = <span class="title function_">useRef</span>(count);</span><br><span class="line">  <span class="comment">// 这里在每一次组件重新渲染后更新ref的值</span></span><br><span class="line">  currentCount.<span class="property">current</span> = count;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(currentCount.<span class="property">current</span>)</span><br><span class="line">      <span class="title function_">setCount</span>(currentCount.<span class="property">current</span> + <span class="number">1</span>); <span class="comment">// 这个 effect 依赖于 `count` state    </span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(id);</span><br><span class="line">  &#125;, []); <span class="comment">// 🔴 Bug: `count` 没有被指定为依赖</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useRef、useState如何决策用哪种来维护状态"><a href="#useRef、useState如何决策用哪种来维护状态" class="headerlink" title="useRef、useState如何决策用哪种来维护状态"></a>useRef、useState如何决策用哪种来维护状态</h3><p>useRef 生成的可变对象，因为使用起来就跟普通对象一样，赋值时候 React 是无法感知到值变更的，所以也不会触发组件重绘。利用其与 useState 的区别，我们一般这样区分使用：</p>
<ul>
<li>维护与 UI 相关的状态，使用 useState</li>
</ul>
<blockquote>
<p>确保更改时刷新 UI</p>
</blockquote>
<ul>
<li>值更新不需要触发重绘时，使用 useRef</li>
<li>不需要变更的数据、函数，使用 useState</li>
</ul>
<blockquote>
<p>比如，需要声明一个不可变的值时，可以这样：</p>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [immutable] = <span class="title function_">useState</span>(someState);</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>不返回变更入口函数。useRef 虽然可以借助 TypeScript 达到语法检测上的 immutable，但实际还是 mutable 的。</p>
</blockquote>
<h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><h5 id="context简介："><a href="#context简介：" class="headerlink" title="context简介："></a>context简介：</h5><p><code>React.createContext</code> 新建context</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(defaultValue);</span><br></pre></td></tr></table></figure>

<p>创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 <code>Provider</code> 中读取到当前的 context 值。</p>
<p><strong>只有</strong>当组件所处的树中没有匹配到 Provider 时，其 <code>defaultValue</code> 参数才会生效。此默认值有助于在不使用 Provider 包装组件的情况下对组件进行测试。<strong>注意：将 <code>undefined</code> 传递给 Provider 的 value 时，消费组件的 <code>defaultValue</code> 不会生效。</strong></p>
<p><code>Context.Provider</code></p>
<p>每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。</p>
<h5 id="useContext使用"><a href="#useContext使用" class="headerlink" title="useContext使用"></a>useContext使用</h5><p>接收一个 context 对象（<code>React.createContext</code> 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 <code>value</code> prop 决定。</p>
<p>当组件上层最近的 <code>&lt;MyContext.Provider&gt;</code> 更新时，该 Hook 会触发重渲染，并使用最新传递给 <code>MyContext</code> provider 的 context <code>value</code> 值。即使祖先使用 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo"><code>React.memo</code></a> 或 <a href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate</code></a>，也会在组件本身使用 <code>useContext</code> 时重新渲染。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ThemeContext</span>, themes &#125; <span class="keyword">from</span> <span class="string">&quot;./utils/index&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [theme, setTheme] = <span class="title function_">useState</span>(themes.<span class="property">light</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">value</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">theme</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">toggle:</span> () =&gt;</span></span></span><br><span class="line"><span class="language-xml">                    setTheme(</span></span><br><span class="line"><span class="language-xml">                        theme === themes.light ? themes.dark : themes.light</span></span><br><span class="line"><span class="language-xml">                    ),</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        &gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Toolbar</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Toolbar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ThemedButton</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ThemedButton</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">background:</span> <span class="attr">context.theme.background</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">color:</span> <span class="attr">context.theme.foreground</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onClick</span>=<span class="string">&#123;context.toggle&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span></span></span><br><span class="line"><span class="language-xml">            I am styled by theme context!</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><p>useMemo 主要有两个作用：</p>
<ol>
<li>缓存一些耗时计算，通过声明计算结果的依赖是否变更，来重用上次计算结果</li>
<li>保证引用不变，针对下游使用 React.memo 的组件进行性能优化（useCallback 也有一样的作用）</li>
</ol>
<p>比如，计算耗时的 fibonacci 数列，就可以用 useMemo 来优化在 n 不变的情况下，二次渲染的性能</p>
<p><code>useMemo(() =&gt; &#123;  return fibonacci(props.n) &#125;, [props.n]); </code></p>
<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>useCallback 是简化版的 useMemo，方便缓存函数引用。下面的代码是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoCallback = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// DO SOMETHING</span></span><br><span class="line">&#125;, [...deps]);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoCallback = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// DO SOMETHING</span></span><br><span class="line">&#125;, [...deps]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在没有遇到性能问题时，不要使用 useCallback 和 useMemo，性能优化先交给框架处理解决。手工的微优化在没有对框架和业务场景有深入了解时，可能出现性能劣化。</p>
</blockquote>
<blockquote>
<p><a href="https://bytedance.feishu.cn/docs/doccnKcSsW0lazRObCmw3GlGkmd">致命的 useCallback&#x2F;useMemo（翻译）</a> </p>
</blockquote>
<blockquote>
<p><a href="https://bytedance.feishu.cn/docs/doccn9SDGhQJ6mM58BxjfRJFs3d">useCallback hell问题总结</a> </p>
</blockquote>
<blockquote>
<p>关于如何减少 useCallback 看 <strong><a href="https://bytedance.feishu.cn/docs/doccnmgIb5KcV3F0zeE47o6PvCh#KQKJ2M">第二天</a></strong></p>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Hooks</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + Next + GitHub Page搭建个人博客</title>
    <url>/2024/09/21/Hexo%20+%20Next%20+%20GitHub%20Page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="Hexo介绍"><a href="#Hexo介绍" class="headerlink" title="Hexo介绍"></a>Hexo介绍</h3><p>Hexo是一款基于Node.js的开源静态博客框架，用于快速、简单且高效地搭建静态博客网站。本质上是一个静态网站生成器，新增文章只需要编辑md文件，通过运行命令再生成像html的静态文件。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全局安装hexo脚手架</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一blog项目</span></span><br><span class="line">hexo init blog</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入项目</span></span><br><span class="line">cd blog</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装依赖包</span></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">右键 Git Bush，用户项目自动化部署</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h3 id="项目预览"><a href="#项目预览" class="headerlink" title="项目预览"></a>项目预览</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清理旧的静态文件</span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成静态文件</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行预览项目</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<h3 id="Hexo配置文件详解（-config-yml）"><a href="#Hexo配置文件详解（-config-yml）" class="headerlink" title="Hexo配置文件详解（_config.yml）"></a>Hexo配置文件详解（_config.yml）</h3><h3 id="Next主题样式"><a href="#Next主题样式" class="headerlink" title="Next主题样式"></a>Next主题样式</h3><blockquote>
<p>官方文档：<a href="https://theme-next.js.org/docs/getting-started/configuration.html">https://theme-next.js.org/docs/getting-started/configuration.html</a></p>
</blockquote>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/next-theme/theme-next-docs</span><br><span class="line">cd theme-next-docs</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><ol>
<li>Hexo版本&gt;&#x3D;5.0</li>
<li>在Hexo项目根目录下创建Next配置文件，命名为_config.next.yml</li>
<li>首次创建Next配置文件时，可以直接复制theme-next-docs目录下的next默认配置文化<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Installed through npm</span></span><br><span class="line">cp node_modules/hexo-theme-next/_config.yml _config.next.yml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Installed through Git</span></span><br><span class="line">cp themes/next/_config.yml _config.next.yml</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="站点中的icon替换"><a href="#站点中的icon替换" class="headerlink" title="站点中的icon替换"></a>站点中的icon替换</h5><blockquote>
<p>Next默认引了fontawsome样式，大部分直接替换即可 <a href="https://fontawesome.dashgame.com/">https://fontawesome.dashgame.com/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Chore</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Http2/Http3</title>
    <url>/2021/09/18/Http2Http3/</url>
    <content><![CDATA[<h4 id="为什么Http-1-1无法并发的发送多个请求（同时发多个请求，再同时接收）"><a href="#为什么Http-1-1无法并发的发送多个请求（同时发多个请求，再同时接收）" class="headerlink" title="为什么Http 1.1无法并发的发送多个请求（同时发多个请求，再同时接收）"></a>为什么Http 1.1无法并发的发送多个请求（同时发多个请求，再同时接收）</h4><p>因为http1.1是基于文本的协议，比如客户端向服务器发送了两个请求 <code>GET /query?q=A</code> 和 <code>GET /query?q=B</code>，服务器返回了两个结果，客户端是没有办法根据响应结果来判断响应对应于哪一个请求的，而http2基于二进制分帧实现多路复用，数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，<strong>因为根据帧首部的流标识可以重新组装。</strong></p>
<span id="more"></span>





]]></content>
      <categories>
        <category>计算机网络协议</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>Http</tag>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title>Https</title>
    <url>/2021/09/13/Https/</url>
    <content><![CDATA[<h3 id="为什么需要加密？"><a href="#为什么需要加密？" class="headerlink" title="为什么需要加密？"></a><strong>为什么需要加密？</strong></h3><p>因为http的内容是明文传输的，明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了。劫持者还可以篡改传输的信息且不被双方察觉，这就是“中间人攻击”。</p>
<h3 id="用对称加密可行吗？"><a href="#用对称加密可行吗？" class="headerlink" title="用对称加密可行吗？"></a><strong>用对称加密可行吗？</strong></h3><p>对称加密最大的问题就是密钥的传输，而密钥的传输又需要加密（反复套娃），故而单纯的对称加密是无法解决问题的。</p>
<span id="more"></span>


<h3 id="用非对称加密可行吗？"><a href="#用非对称加密可行吗？" class="headerlink" title="用非对称加密可行吗？"></a>用非对称加密可行吗？</h3><p>鉴于非对称加密的机制，我们可能会有这种思路：服务器先把公钥以明文方式传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，这条数据的安全似乎可以保障了！<strong>因为只有服务器有相应的私钥能解开公钥加密的数据</strong>。</p>
<p>然而反过来<strong>由服务器到浏览器的这条路怎么保障安全？</strong>如果服务器用它的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而这个公钥是一开始通过明文传输给浏览器的，若这个公钥被中间人劫持到了，那他也能用该公钥解密服务器传来的信息了。所以<strong>目前似乎只能保证由浏览器向服务器传输数据的安全性</strong></p>
<h3 id="那用两组公钥私钥，是否就能保证双向传输都安全了？"><a href="#那用两组公钥私钥，是否就能保证双向传输都安全了？" class="headerlink" title="那用两组公钥私钥，是否就能保证双向传输都安全了？"></a>那用两组公钥私钥，是否就能保证双向传输都安全了？</h3><ol>
<li>某网站服务器拥有公钥A与对应的私钥A’；浏览器拥有公钥B与对应的私钥B’。</li>
<li>浏览器把公钥B明文传输给服务器。</li>
<li>服务器把公钥A明文给传输浏览器。</li>
<li>之后浏览器向服务器传输的内容都用公钥A加密，服务器收到后用私钥A’解密。由于只有服务器拥有私钥A’，所以能保证这条数据的安全。</li>
<li>同理，服务器向浏览器传输的内容都用公钥B加密，浏览器收到后用私钥B’解密。同上也可以保证这条数据的安全。</li>
</ol>
<p>然而这又引出了一个新的问题，非对称加密非常耗时，如何解决？（见RSA算法）而且这种方法真的安全了吗？</p>
<h3 id="非对称加密-对称加密"><a href="#非对称加密-对称加密" class="headerlink" title="非对称加密 + 对称加密"></a>非对称加密 + 对称加密</h3><ol>
<li>某网站拥有用于非对称加密的公钥A、私钥A’。</li>
<li>浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。</li>
<li>浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。</li>
<li>服务器拿到后用私钥A’解密得到密钥X。</li>
<li>这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。</li>
</ol>
<p>这基本上就是https采用的方案了，但仍然还是有漏洞。</p>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>中间人攻击（MITMA，man in the middle attack）<br>中间人攻击是一种网络攻击类型 ，应用与LAN局域网中。这种攻击的方式是 hacker 置身于两个通信 paties 之间，窃取数据。</p>
<p>中间人攻击允许黑客截获双方之间的数据，它可能是服务器和客户端或客户端到客户端或服务器到服务器。</p>
<p><img src="/../assets/image-20210513212400962.png" alt="image-20210513212400962"></p>
<p>如果在数据传输过程中，中间人劫持到了数据，此时他的确无法得到浏览器生成的密钥X，这个密钥本身被公钥A加密了，只有服务器才有私钥A’解开它，然而中间人却完全不需要拿到私钥A’就能干坏事了。请看：</p>
<ol>
<li>某网站有用于非对称加密的公钥A、私钥A’。</li>
<li>浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。</li>
<li><strong>中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）</strong>。</li>
<li>浏览器生成一个用于对称加密的密钥X，用<strong>公钥B</strong>（浏览器无法得知公钥被替换了）加密后传给服务器。</li>
<li><strong>中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器</strong>。</li>
<li>服务器拿到后用私钥A’解密得到密钥X。</li>
</ol>
<p>这样在双方都不会发现异常的情况下，中间人掉包了服务器传来的公钥，进而得到了密钥X。<strong>根本原因是浏览器无法确认收到的公钥是不是网站自己的，</strong>因为公钥本身是明文传输的，难道还得对公钥的传输进行加密？这似乎变成鸡生蛋、蛋生鸡的问题了。解法是什么？</p>
<h3 id="如何证明浏览器收到的公钥一定是该网站的公钥？"><a href="#如何证明浏览器收到的公钥一定是该网站的公钥？" class="headerlink" title="如何证明浏览器收到的公钥一定是该网站的公钥？"></a><strong>如何证明浏览器收到的公钥一定是该网站的公钥？</strong></h3><p>网站是否有个‘身份证’来证明自己的公钥合法？这个‘身份证’又由谁来颁发？</p>
<p><strong>CA机构</strong>，它是如今互联网世界正常运作的前提，而CA机构颁发的“身份证”就是<strong>数字证书</strong>。</p>
<h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a><strong>数字证书</strong></h4><p>网站在使用HTTPS前，需要向<strong>CA机构</strong>申领一份<strong>数字证书</strong>，数字证书里含有证书持有者信息、公钥信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，证书就如身份证，证明“该公钥对应该网站”。</p>
<p>而这里又有一个显而易见的问题，“<strong>证书本身的传输过程中，如何防止被篡改”</strong>？即如何证明证书本身的真实性？身份证运用了一些防伪技术，而数字证书怎么防伪呢？</p>
<h3 id="如何放防止数字证书被篡改？"><a href="#如何放防止数字证书被篡改？" class="headerlink" title="如何放防止数字证书被篡改？"></a><strong>如何放防止数字证书被篡改？</strong></h3><p>我们把证书原本的内容生成一份“签名”，比对证书内容和签名是否一致就能判别是否被篡改。这就是数字证书的“防伪技术”，这里的“签名”就叫<code>数字签名</code>：</p>
<p>数字签名的制作过程：</p>
<ol>
<li>CA机构拥有非对称加密的私钥和公钥。</li>
<li>CA机构对证书明文数据T进行hash。</li>
<li>对hash后的值用私钥加密，得到数字签名S。</li>
</ol>
<p>明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。<br>那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）</p>
<p>浏览器验证过程：</p>
<ol>
<li>拿到证书，得到明文T，签名S。</li>
<li>用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。</li>
<li>用证书里指明的hash算法对明文T进行hash得到T’。</li>
<li>显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。所以此时比较S’是否等于T’，等于则表明证书可信。</li>
</ol>
<p><img src="/../assets/image-20210513214044731.png" alt="image-20210513214044731"></p>
<h3 id="中间人有可能篡改该证书吗？"><a href="#中间人有可能篡改该证书吗？" class="headerlink" title="中间人有可能篡改该证书吗？"></a><strong>中间人有可能篡改该证书吗？</strong></h3><p>假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信</p>
<h3 id="中间人有可能把证书掉包吗？"><a href="#中间人有可能把证书掉包吗？" class="headerlink" title="中间人有可能把证书掉包吗？"></a><strong>中间人有可能把证书掉包吗？</strong></h3><p>假设有另一个网站B也拿到了CA机构认证的证书，它想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了。</p>
<p>其实这并不会发生，因为证书一定是无法被篡改的，所以网站B掉包的一定也是正规的证书，而证书黎里包含了网站的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。</p>
<h3 id="为什么制作数字签名时需要hash一次？"><a href="#为什么制作数字签名时需要hash一次？" class="headerlink" title="为什么制作数字签名时需要hash一次？"></a><strong>为什么制作数字签名时需要hash一次？</strong></h3><p>最显然的是性能问题，非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加解密就快很多。</p>
<h3 id="怎么证明CA机构的公钥是可信的？"><a href="#怎么证明CA机构的公钥是可信的？" class="headerlink" title="怎么证明CA机构的公钥是可信的？"></a><strong>怎么证明CA机构的公钥是可信的？</strong></h3><p>“浏览器保有它的公钥”，这是个什么保有法？怎么证明这个公钥是否可信？</p>
<p>让我们回想一下数字证书到底是干啥的？没错，为了证明某公钥是可信的，即“该公钥是否对应该网站”，那CA机构的公钥是否也可以用数字证书来证明？没错，操作系统、浏览器本身会预装一些它们信任的根证书，如果其中会有CA机构的根证书，这样就可以拿到它对应的可信公钥了。</p>
<p>实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做<code>信任链</code>或<code>数字证书链</code>。也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。</p>
<p>另外，不知你们是否遇到过网站访问不了、提示需安装证书的情况？这里安装的就是根证书。说明浏览器不认给这个网站颁发证书的机构，那么你就得手动下载安装该机构的根证书（风险自己承担XD）。安装后，你就有了它的公钥，就可以用它验证服务器发来的证书是否可信了。</p>
<h3 id="每次进行HTTPS请求时都必须在SSL-TLS层进行握手传输密钥吗？"><a href="#每次进行HTTPS请求时都必须在SSL-TLS层进行握手传输密钥吗？" class="headerlink" title="每次进行HTTPS请求时都必须在SSL&#x2F;TLS层进行握手传输密钥吗？"></a><strong>每次进行HTTPS请求时都</strong>必须<strong>在SSL&#x2F;TLS层进行握手传输密钥吗？</strong></h3><p>显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？</p>
<p>服务器会为每个浏览器（或客户端软件）维护一个session ID，在TLS握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>可以看下这张图，梳理一下整个流程（SSL、TLS握手有一些区别，不同版本间也有区别，不过大致过程就是这样）：</p>
]]></content>
      <categories>
        <category>计算机网络协议</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSrcipt原型</title>
    <url>/2021/02/17/JavaScript%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<p>首先，要明确几个点：</p>
<ol>
<li><p>在JS里，万物皆对象。方法（Function）是对象，方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。<br>即：对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。</p>
</li>
<li><p>方法(Function)<br>方法这个特殊的对象，除了和其他对象一样有上述_proto_属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。</p>
</li>
</ol>
<p>好啦，知道了这两个基本点，我们来看看上面这副图。</p>
<ol>
<li><p>构造函数Foo()<br>构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。</p>
</li>
<li><p>原型对象Foo.prototype<br>Foo.prototype保存着实例共享的方法，有一个指针constructor指回构造函数。</p>
</li>
<li><p>实例<br>f1和f2是Foo这个对象的两个实例，这两个对象也有属性__proto__，指向构造函数的原型对象，这样子就可以像上面1所说的访问原型对象的所有方法啦。</p>
<p><img src="/../assets/Snipaste_2021-08-08_20-48-18.png" alt="image-20210808204737157"></p>
</li>
</ol>
<span id="more"></span>

<p>另外：<br>构造函数Foo()除了是方法，也是对象啊，它也有__proto__属性，指向谁呢？<br>指向它的构造函数的原型对象呗。函数的构造函数不就是Function嘛，因此这里的__proto__指向了Function.prototype。<br>其实除了Foo()，Function(), Object()也是一样的道理。</p>
<p>原型对象也是对象啊，它的__proto__属性，又指向谁呢？<br>同理，指向它的构造函数的原型对象呗。这里是Object.prototype.</p>
<p>最后，Object.prototype的__proto__属性指向null（原型链的终点）</p>
<p>总结：</p>
<ol>
<li>对象有属性__proto__,指向该对象的构造函数的原型对象。</li>
<li>方法除了有属性__proto__,还有属性prototype，prototype指向该方法的原型对象。</li>
<li>标准化获取对象的构造函数的原型：不要用obj.__proto__，用Object.getPrototypeof(obj)。</li>
</ol>
<h2 id="原型对象中的constructor"><a href="#原型对象中的constructor" class="headerlink" title="原型对象中的constructor"></a>原型对象中的constructor</h2><p>看一段代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript原理</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript垃圾回收</title>
    <url>/2021/02/18/JavaStript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="javascript垃圾回收主要分成两种方法："><a href="#javascript垃圾回收主要分成两种方法：" class="headerlink" title="javascript垃圾回收主要分成两种方法："></a>javascript垃圾回收主要分成两种方法：</h3><h3 id="1-引用计数"><a href="#1-引用计数" class="headerlink" title="1. 引用计数"></a>1. 引用计数</h3><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><p>垃圾回收算法主要依赖于引用的概念。</p>
</li>
<li><p>在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。</p>
</li>
<li><p>例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。</p>
</li>
<li><p>在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域。</p>
</li>
</ul>
<h3 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="headerlink" title="引用计数垃圾收集"></a>引用计数垃圾收集</h3><p>这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span></span><br><span class="line"><span class="comment">// 很显然，没有一个可以被垃圾收集</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = o; <span class="comment">// o2变量是第二个对“这个对象”的引用</span></span><br><span class="line"></span><br><span class="line">o = <span class="number">1</span>;      <span class="comment">// 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oa = o2.<span class="property">a</span>; <span class="comment">// 引用“这个对象”的a属性</span></span><br><span class="line">               <span class="comment">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span></span><br><span class="line"></span><br><span class="line">o2 = <span class="string">&quot;yo&quot;</span>; <span class="comment">// 虽然最初的对象现在已经是零引用了，可以被垃圾回收了</span></span><br><span class="line">           <span class="comment">// 但是它的属性a的对象还在被oa引用，所以还不能回收</span></span><br><span class="line"></span><br><span class="line">oa = <span class="literal">null</span>; <span class="comment">// a属性的那个对象现在也是零引用了</span></span><br><span class="line">           <span class="comment">// 它可以被垃圾回收了</span></span><br></pre></td></tr></table></figure>



<h3 id="2-标记清除"><a href="#2-标记清除" class="headerlink" title="2. 标记清除"></a>2. 标记清除</h3><p>JavaScript 中最常用的垃圾收集方式是标记清除。它的具体工作步骤如下：</p>
<ol>
<li>给存储在内存中的所有变量加上标记（当然可以使用任何标记方式）</li>
<li>去掉当前执行环境中的变量，以及被执行环境中的变量引用的变量的标记</li>
<li>第二步结束后仍被标记的变量将被视为准备删除的变量，因为此时的执行环境中的变量已经无法访问到这些变量了。</li>
<li>完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</li>
</ol>
<p>对于如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> d = <span class="number">4</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test1</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">test2</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设执行到test2()时，垃圾回收开始执行</p>
<p>对于此时，内存情况为</p>
<p><img src="/../assets/image-20210412150846546.png" alt="image-20210412150846546"></p>
<p>开始第一步，将内存中的所有变量加上标记</p>
<p><img src="/../assets/image-20210412151850990.png" alt="image-20210412151850990"></p>
<p>去掉当前执行环境中的变量，以及被执行环境中的变量引用的变量的标记。简单分析一下，此时执行环境中可以访问的变量有 d ,然后我们通过作用域链可以访问到全局变量对象，因此 a 和 b 我们也是可以访问到的</p>
<p><img src="/../assets/image-20210412152201055.png" alt="image-20210412152201055"></p>
<p>此时只有 c 变量还保留有标记，说明 c 变量通过此时的环境已经访问不到了，所以 c 变量需要被清除掉来释放内存。</p>
<p>最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</p>
<p><img src="/../assets/image-20210412152245827.png" alt="image-20210412152245827"></p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li>标记清除法的第一个问题就是效率不高，因为在标记清除-阶段，整个程序将会等待，所有如果程序出现卡顿的情况你，那么就有可能是收集垃圾的情况。</li>
<li>标记清除法的第二个问题是，从上面的例子我们可以看出，在清除之后内存空间不是连续的，即出现了内存碎片。如果后面需要一个比较大的连续的内存空间时，那将不能满足要求。而标记-整理方法可以有效地解决这个问题。与标记清除法相比，标记阶段没有什么不同，只是标记结束后，标记-整理方法会将活着的对象向内存的一边移动，最后清理掉边界的内存。不过可以想象，这种做法的效率没有标记-清除高。</li>
</ol>
<p>对比一下官方文档的解释:</p>
<div><i>标记清除这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象

<h4 id="这里的‘根’指的应该是上下文对象"><a href="#这里的‘根’指的应该是上下文对象" class="headerlink" title="这里的‘根’指的应该是上下文对象"></a>这里的‘根’指的应该是上下文对象</h4><p>因为通过当前的执行上下文对象可以访问到当前环境中的变量，也可以通过作用域链去访问到其他上下文中的活动对象，从而可以判断得到所有可以获得的对象和所有不能获得的对象</p>
]]></content>
      <categories>
        <category>JavaScript原理</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript手写题</title>
    <url>/2021/03/02/Javascript%E6%89%8B%E5%86%99%E9%A2%98/</url>
    <content><![CDATA[<h4 id="实现一个new"><a href="#实现一个new" class="headerlink" title="实现一个new"></a>实现一个new</h4><p><strong>new的具体步骤</strong></p>
<ol>
<li>内存中创建一个新对象</li>
<li>新建对象的 _ <em>proto</em> _指向构造函数的prototype</li>
<li>调用构造函数，函数的this指向新创建的对象</li>
<li>执行构造函数内部的代码（给新对象添加属性）</li>
<li><strong>如果构造函数返回非空对象，则返回该对象，否则，返回新创建的对象</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">age, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 修改obj.__proto__ = fn.prototype，如果直接obj = &#123;&#125;会出现没有对象标识的问题（对象标识为Object），还会使得方法没有被创建</span></span><br><span class="line">    <span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(fn.<span class="property"><span class="keyword">prototype</span></span>)  <span class="comment">//fn.prototype代表 用当前对象的原型去创建</span></span><br><span class="line">    <span class="comment">//现在obj就代表Dog了,但是参数和this指向没有修改</span></span><br><span class="line">    <span class="keyword">const</span> rel = fn.<span class="title function_">apply</span>(obj,args)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       正常规定,如何fn返回的是null或undefined(也就是不返回内容),我们返回的是obj,否则返回rel</span></span><br><span class="line"><span class="comment">       因为比如下面这个构造函数</span></span><br><span class="line"><span class="comment">       function Person(name, age) &#123;</span></span><br><span class="line"><span class="comment">            this.name = name;</span></span><br><span class="line"><span class="comment">            this.age = age;</span></span><br><span class="line"><span class="comment">            return &#123;</span></span><br><span class="line"><span class="comment">                a: 1,</span></span><br><span class="line"><span class="comment">                b: 2,</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        const p = new Person(&#x27;h&#x27;, &#x27;y&#x27;);</span></span><br><span class="line"><span class="comment">        这里new会优先为构造函数的返回值</span></span><br><span class="line"><span class="comment">        所以p的值为&#123;a: 1,b: 2&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> rel <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? rel : obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title function_">myNew</span>(<span class="title class_">Person</span>, <span class="number">19</span>, <span class="string">&#x27;hyz&#x27;</span>);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="实现一个Object-create"><a href="#实现一个Object-create" class="headerlink" title="实现一个Object.create"></a>实现一个Object.create</h4><p>Object.create(proto)创建一个空对象，proto为空对象的”<em><strong>proto</strong></em>“</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// Object.create(null) 返回一个__proto__指向空的干净对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 非对象非null，抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> <span class="title class_">Object</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="虾皮笔试题"><a href="#虾皮笔试题" class="headerlink" title="虾皮笔试题"></a>虾皮笔试题</h4><p>十分有水平的一道题，综合了new原理，原型链+instanceof原理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;ee&#x27;</span>,</span><br><span class="line">    <span class="attr">sayName</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// Person 的 prototype 已经改变，而 person1.__proto__ 指向一开始的 Person.prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person1 instanceof Person: &#x27;</span>, person1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>) <span class="comment">// 为啥是false</span></span><br><span class="line"><span class="comment">// 所有的对象都继承自 Object，除了 null 或者你把最顶层的 prototype 也给改了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person1 instanceof Object: &#x27;</span>, person1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">// 为啥是true</span></span><br><span class="line"><span class="comment">// person1 本身没有 constructor, 会沿着原型链找，</span></span><br><span class="line"><span class="comment">// person1.constructor === person1.__proto__.constructor</span></span><br><span class="line"><span class="comment">// 而上面也说了 person1.__proto__ 并没有因为 Person.prototype 改变而改变</span></span><br><span class="line"><span class="comment">// 这里需要注意的是：</span></span><br><span class="line"><span class="comment">// Person 本身就是 constructor</span></span><br><span class="line"><span class="comment">// 初始情况下</span></span><br><span class="line"><span class="comment">// Person.prototype =&gt; Person.prototype</span></span><br><span class="line"><span class="comment">// Person.prototype.constructor =&gt; Person</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person1.constructor == Person: &#x27;</span>, person1.<span class="property">constructor</span> == <span class="title class_">Person</span>) <span class="comment">// 为啥是true</span></span><br><span class="line"><span class="comment">// 上面是 true, 下面就好说了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person1.constructor == Object: &#x27;</span>, person1.<span class="property">constructor</span> == <span class="title class_">Object</span>) <span class="comment">// 为啥是false</span></span><br></pre></td></tr></table></figure>

<h4 id="实现消息订阅"><a href="#实现消息订阅" class="headerlink" title="实现消息订阅"></a>实现消息订阅</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventCenter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Map&lt;string, Array&lt;Function&gt;</span>&#125; <span class="variable">handlers</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">handlers=<span class="keyword">new</span> <span class="built_in">Map</span>()</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handlers</span> = handlers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; <span class="variable">handler</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">type</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="title function_">addEventListener</span>(<span class="params">type, newHandler</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> hanlder = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">has</span>(type);</span><br><span class="line">        <span class="keyword">if</span> (hanlder) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">set</span>(type, [...<span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">get</span>(type), newHandler]) </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">set</span>(type, [newHandler]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">type</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">params</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="title function_">dispatchEvent</span>(<span class="params">type, params=[]</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> handler = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">get</span>(type);</span><br><span class="line">        handler &amp;&amp; handler.<span class="title function_">forEach</span>(<span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">callback</span>(...params);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; type </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; delHandler </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">removeEventListener</span>(<span class="params">type, delHandler</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">has</span>(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Errow</span>(<span class="string">&quot;Unable to delete&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delHanlder) &#123;</span><br><span class="line">            <span class="keyword">const</span> oldHandlers = <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">get</span>(type);</span><br><span class="line">            <span class="keyword">const</span> ind = oldHandlers.<span class="title function_">indexOf</span>(delHandler);</span><br><span class="line">            <span class="keyword">if</span> (ind === -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Errow</span>(<span class="string">&quot;Unable to delete&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            oldHandlers.<span class="title function_">splice</span>(ind, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">delete</span>(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现一个JSONP"><a href="#实现一个JSONP" class="headerlink" title="实现一个JSONP"></a>实现一个JSONP</h4><p>前端部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">url, options</span>) &#123;</span><br><span class="line">    <span class="comment">// 超时处理</span></span><br><span class="line">    <span class="keyword">const</span> &#123; timeout &#125; = options;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 防止函数名冲突</span></span><br><span class="line">        <span class="keyword">let</span> funcName = <span class="string">`jsonp<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">let</span> time = <span class="literal">null</span>, scriptNode;</span><br><span class="line">        <span class="comment">// 定义callback</span></span><br><span class="line">        <span class="variable language_">window</span>[funcName] = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(time);</span><br><span class="line">            <span class="title function_">resolve</span>(data);</span><br><span class="line">            <span class="comment">// 很重要的性能优化点</span></span><br><span class="line">            <span class="comment">// 清除本次请求产生的回调函数和script标签</span></span><br><span class="line">            <span class="keyword">delete</span> <span class="variable language_">window</span>[funcName];</span><br><span class="line">            <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(scriptNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建script标签</span></span><br><span class="line">        scriptNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        <span class="comment">// 给script标签添加src属性</span></span><br><span class="line">        scriptNode.<span class="property">src</span> = <span class="string">`<span class="subst">$&#123;url&#125;</span>?callback=<span class="subst">$&#123;funcName&#125;</span>`</span>;</span><br><span class="line">        <span class="comment">// 发出请求</span></span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(scriptNode);</span><br><span class="line">        time = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;network err, timeout&#x27;</span>)</span><br><span class="line">        &#125;, timeout)</span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        scriptNode.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">jsonp</span>(<span class="string">&#x27;http://localhost:9090/api&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">callBack</span>: <span class="string">&#x27;res1&#x27;</span>,</span><br><span class="line">    <span class="comment">// 超时处理</span></span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br><span class="line">    <span class="comment">// 请求成功</span></span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;jsonp-&gt;&#x27;</span>, res);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 请求失败</span></span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;network err!&quot;</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>后端部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后端</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// /api?callback=onResponse</span></span><br><span class="line">  <span class="comment">// 解析前端请求url中的callback名</span></span><br><span class="line">  <span class="keyword">if</span>(req.<span class="property">url</span>.<span class="title function_">includes</span>(<span class="string">&#x27;/api&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> myurl = url.<span class="title function_">parse</span>(req.<span class="property">url</span>);</span><br><span class="line">    <span class="keyword">let</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(myurl.<span class="property">query</span>)</span><br><span class="line">    <span class="keyword">let</span> posts = [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;php&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> mathodName = params.<span class="title function_">get</span>(<span class="string">&#x27;callback&#x27;</span>);</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">`<span class="subst">$&#123;mathodName&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(posts)&#125;</span>)`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">listen</span>(<span class="number">9090</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">9090</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript执行上下文</title>
    <url>/2021/02/17/Javascript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><h4 id="在看js垃圾回收时遇到相关问题，感觉自己对上下文对象理解的还是不够透彻（实在是太菜了）这就回来恶补。"><a href="#在看js垃圾回收时遇到相关问题，感觉自己对上下文对象理解的还是不够透彻（实在是太菜了）这就回来恶补。" class="headerlink" title="在看js垃圾回收时遇到相关问题，感觉自己对上下文对象理解的还是不够透彻（实在是太菜了）这就回来恶补。"></a>在看js垃圾回收时遇到相关问题，感觉自己对上下文对象理解的还是不够透彻（实在是太菜了）这就回来恶补。</h4><h4 id="执行上下文（Execution-Context）"><a href="#执行上下文（Execution-Context）" class="headerlink" title="执行上下文（Execution Context）"></a>执行上下文（Execution Context）</h4><ul>
<li><p><strong>执行上下文可以理解为当前代码的运行环境。</strong>在 JavaScript 中，运行环境主要包含了<strong>全局环境</strong>和<strong>函数环境</strong>。</p>
</li>
<li><p>在 JavaScript 代码运行过程中，最先进入的是全局环境，而在函数被调用时则进入相应的函数环境。全局环境和函数环境所对应的执行上下文我们分别称为<strong>全局上下文</strong>和<strong>函数上下文</strong>。</p>
</li>
<li><p>在一个 JavaScript 文件中，经常会有多个函数被调用，也就是说在 JavaScript 代码运行过程中很可能会产生多个执行上下文，那么如何去管理这多个执行上下文呢？</p>
</li>
<li><p>执行上下文是以栈（一种 LIFO 的数据结构）的方式被存放起来的，我们称之为<strong>执行上下文栈（Execution Context Stack）</strong>。</p>
</li>
<li><p><strong>在 JavaScript 代码开始执行时，首先进入全局环境，此时全局上下文被创建并入栈，之后当调用函数时则进入相应的函数环境，此时相应函数上下文被创建并入栈，当处于栈顶的执行上下文代码执行完毕后，则会将其出栈。</strong></p>
</li>
<li><p>所以在执行上下文栈中，栈底永远是全局上下文，而栈顶则是当前正在执行的函数上下文。</p>
</li>
</ul>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn1&#x27;</span>)</span><br><span class="line">  <span class="title function_">fn2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>();</span><br></pre></td></tr></table></figure>

<p>对于如上代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 伪代码 以数组来表示执行上下文栈 ECStack=[] */</span></span><br><span class="line"><span class="comment">// 代码执行时最先进入全局环境，全局上下文被创建并入栈</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(global_EC);</span><br><span class="line"><span class="comment">// fn1 被调用，fn1 函数上下文被创建并入栈</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(fn1_EC);</span><br><span class="line"><span class="comment">// fn1 中调用 fn2，fn2 函数上下文被创建并入栈</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">push</span>(fn2_EC);</span><br><span class="line"><span class="comment">// fn2 执行完毕，fn2 函数上下文出栈</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br><span class="line"><span class="comment">// fn1 执行完毕，fn1 函数上下文出栈</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br><span class="line"><span class="comment">// 代码执行完毕，全局上下文出栈</span></span><br><span class="line"><span class="title class_">ECStack</span>.<span class="title function_">pop</span>();</span><br></pre></td></tr></table></figure>

<p><img src="/../assets%5Cimage-20210414214146564.png" alt="image-20210414214146564"></p>
<p>在一个执行上下文中，最重要的三个属性分别是<strong>变量对象（Variable Object）</strong>、<strong>作用域链（Scope Chain）</strong>和 <strong>this 指向</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">EC</span> = &#123;</span><br><span class="line">  <span class="variable constant_">VO</span>,</span><br><span class="line">  <span class="variable constant_">SC</span>,</span><br><span class="line">  <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个执行上下文的生命周期分为<strong>创建</strong>和<strong>执行</strong>阶段。创建阶段主要工作是<strong>生成变量对象</strong>、<strong>建立作用域链</strong>和<strong>确定 this 指向</strong>。而执行阶段主要工作是变量赋值以及执行其它代码等。</p>
<h4 id="变量对象（Variable-Object）"><a href="#变量对象（Variable-Object）" class="headerlink" title="变量对象（Variable Object）"></a>变量对象（Variable Object）</h4><p>生成变量有三个过程：</p>
<p><strong>1. 检索当前上下文中的函数参数</strong>。该过程生成 Arguments 对象（函数参数），并建立以形参变量名为属性名，形参变量值为属性值的属性；</p>
<p><strong>2. 检索当前上下文中的函数声明</strong>。该过程建立以函数名为属性名，函数所在内存地址引用为属性值的属性；</p>
<p><strong>3. 检索当前上下文中的变量声明</strong>。该过程建立以变量名为属性名，undefined 为属性值的属性（如果变量名跟已声明的形参变量名或函数名相同，则<strong>该变量声明</strong>不会干扰已经存在的这类属性）。</p>
<p>伪代码表示变量对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">VO</span> = &#123;</span><br><span class="line">  <span class="title class_">Arguments</span>: &#123;&#125;, </span><br><span class="line">  <span class="title class_">ParamVariable</span>: 具体值,  <span class="comment">//形参变量</span></span><br><span class="line">  <span class="title class_">Function</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">function</span> <span class="attr">reference</span>&gt;</span>,</span></span><br><span class="line"><span class="language-xml">  Variable:undefined</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>当执行上下文进入执行阶段后，变量对象会变为<strong>活动对象（Active Object）</strong>。此时原先声明的变量会被赋值。</p>
<p><strong>变量对象和活动对象都是指同一个对象，只是处于执行上下文的不同阶段</strong>。</p>
<p>我们可以通过以下伪代码来表示活动对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">AO</span> = &#123;</span><br><span class="line">  <span class="title class_">Arguments</span>: &#123;&#125;,</span><br><span class="line">  <span class="title class_">ParamVariable</span>: 具体值,  <span class="comment">//形参变量</span></span><br><span class="line">  <span class="title class_">Function</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">function</span> <span class="attr">reference</span>&gt;</span>,</span></span><br><span class="line"><span class="language-xml">  Variable:具体值</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>实际例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>当 fn1 函数被调用时，fn1 执行上下文被创建（创建阶段）并入栈，其变量对象如下所示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn1_EC = &#123;</span><br><span class="line">  <span class="variable constant_">VO</span> = &#123;</span><br><span class="line">    <span class="title class_">Arguments</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">length</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">a</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">fn2</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">function</span> <span class="attr">fn2</span> <span class="attr">reference</span>&gt;</span>,</span></span><br><span class="line"><span class="language-xml">    c:undefined</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>执行阶段：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn1_EC = &#123;</span><br><span class="line">  <span class="variable constant_">AO</span> = &#123;</span><br><span class="line">    <span class="title class_">Arguments</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">length</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">a</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">fn2</span>: &lt;function fn2 reference&gt;,</span><br><span class="line">    c:&lt;function express c reference&gt;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于全局上下文来说，由于其不会有参数传递，所以在生成变量对象的过程中只有检索当前上下文中的函数声明和检索当前上下文中的变量声明两个步骤。</p>
<p>在浏览器环境中，全局上下文中的变量对象（全局对象）即我们熟悉的 window 对象，通过该对象可以使用其预定义的变量和函数，在全局环境中所声明的变量和函数，也会成为全局对象的属性。</p>
<h5 id="函数提升和变量提升"><a href="#函数提升和变量提升" class="headerlink" title="函数提升和变量提升"></a>函数提升和变量提升</h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">0</span>); <span class="comment">// fn</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局上下文的创建阶段</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">VO</span> = &#123;</span><br><span class="line">  <span class="title class_">Arguments</span>: &#123;&#125;, </span><br><span class="line">  <span class="title class_">ParamVariable</span>: 具体值,  <span class="comment">//形参变量</span></span><br><span class="line">  <span class="title class_">Function</span>: <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn&#x27;</span>)&#125;</span><br><span class="line">  <span class="title class_">Variable</span>: a = <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>个人理解：每执行一行，AO都会更新一次（给变量赋值），比如执行到<code>console.log(a) // undefined</code>此时由于AO中的a还未更新，所以输出undefined</p>
<p>所以实际执行过程：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">undefined</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">0</span>); <span class="comment">// fn</span></span><br><span class="line">a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h4 id="作用域链（Scope-Chain）"><a href="#作用域链（Scope-Chain）" class="headerlink" title="作用域链（Scope Chain）"></a>作用域链（Scope Chain）</h4><ul>
<li><p><strong>作用域链是指由当前上下文和上层上下文的一系列变量对象组成的层级链</strong>。它保证了当前执行环境对符合访问权限的变量和函数的有序访问。</p>
</li>
<li><p>我们已经知道，执行上下文分为创建和执行两个阶段，在执行上下文的执行阶段，当需要查找某个变量或函数时，会在当前上下文的变量对象（活动对象）中进行查找，若是没有找到，则会沿着上层上下文的变量对象进行查找，直到全局上下文中的变量对象（全局对象）。</p>
</li>
<li><p>那么当前上下文是如何有序地去查找它所需要的变量或函数的呢？答案就是依靠当前上下文中的作用域链，其包含了当前上下文和上层上下文中的变量对象，以便其一层一层地去查找其所需要的变量和函数。</p>
</li>
<li><p>执行上下文中的作用域链又是怎么建立的呢？我们都知道，JavaScript 中主要包含了全局作用域和函数作用域，而<strong>函数作用域是在函数被声明的时候确定的</strong>。</p>
</li>
<li><p>每一个函数都会包含一个 [[scope]] 内部属性，在函数被声明的时候，该函数的 [[scope]] 属性会保存其上层上下文的变量对象，形成包含上层上下文变量对象的层级链。**[[scope]] 属性的值是在函数被声明的时候确定的**。</p>
</li>
<li><p>当函数被调用的时候，其执行上下文会被创建并入栈。<strong>在创建阶段生成其变量对象后，会将该变量对象添加到作用域链的顶端并将 [[scope]] 添加进该作用域链中</strong>。而在执行阶段，变量对象会变为活动对象，其相应属性会被赋值。</p>
</li>
<li><p>所以，作用域链是由当前上下文变量对象及上层上下文变量对象组成的</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">SC</span> = <span class="variable constant_">AO</span> + [[scope]]</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fn2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>();</span><br></pre></td></tr></table></figure>

<p>在 fn1 函数上下文中，fn2 函数被声明，所以</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn2.[[scope]]=[fn1_EC.<span class="property">VO</span>, globalObj]</span><br></pre></td></tr></table></figure>

<p>当 fn2 被调用的时候，其执行上下文被创建并入栈，此时会将生成的变量对象添加进作用域链的顶端，并且将 [[scope]] 添加进作用域链</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn2_EC.<span class="property">SC</span>=[fn2_EC.<span class="property">VO</span>].<span class="title function_">concat</span>(fn2.[[scope]])</span><br><span class="line">=&gt;</span><br><span class="line">fn2_EC.<span class="property">SC</span>=[fn2_EC.<span class="property">VO</span>, fn1_EC.<span class="property">VO</span>, globalObj]</span><br></pre></td></tr></table></figure>



<h4 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h4><p><strong>this 的指向，是在函数被调用的时候确定的。</strong>也就是执行上下文被创建时确定的。</p>
<p>关于 this 的指向，其实最主要的是三种场景，分别是<strong>全局上下文中 this</strong>、<strong>函数中 this</strong> 和<strong>构造函数中 this</strong>。</p>
<h6 id="全局上下文中-this"><a href="#全局上下文中-this" class="headerlink" title="全局上下文中 this"></a>全局上下文中 this</h6><p>在全局上下文中，this 指代全局对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在浏览器环境中，全局对象是 window 对象：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>); <span class="comment">// true</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">b</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h6 id="函数中-this"><a href="#函数中-this" class="headerlink" title="函数中 this"></a>函数中 this</h6><p>函数中的 this 指向是怎样一种情况呢？</p>
<p><strong>如果被调用的函数，被某一个对象所拥有，那么其内部的 this 指向该对象；如果该函数被独立调用，那么其内部的 this 指向 undefined（非严格模式下指向 window）。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">fn</span>: fn</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">fn</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h6 id="构造函数中-this"><a href="#构造函数中-this" class="headerlink" title="构造函数中 this"></a>构造函数中 this</h6><p>要清楚构造函数中 this 的指向，则必须先了解通过 new 操作符调用构造函数时所经历的阶段。</p>
<p>通过 new 操作符调用构造函数时所经历的阶段如下：</p>
<ol>
<li>创建一个新对象；</li>
<li>将构造函数的 this 指向这个新对象；</li>
<li>执行构造函数内部代码；</li>
<li>返回这个新对象。</li>
</ol>
<p>所以从上述流程可知，<strong>对于构造函数来说，其内部 this 指向新创建的对象实例</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ttsy = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;ttsy&#x27;</span>, <span class="number">24</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ttsy.<span class="property">name</span>);  <span class="comment">// ttsy</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ttsy.<span class="property">age</span>);  <span class="comment">// 24</span></span><br></pre></td></tr></table></figure>

<h5 id="需要注意的是，在-ES6-中箭头函数中，this-是在函数声明的时候确定的-箭头函数不绑定this，会捕获上下文的this"><a href="#需要注意的是，在-ES6-中箭头函数中，this-是在函数声明的时候确定的-箭头函数不绑定this，会捕获上下文的this" class="headerlink" title="需要注意的是，在 ES6 中箭头函数中，this 是在函数声明的时候确定的(箭头函数不绑定this，会捕获上下文的this)"></a>需要注意的是，在 ES6 中箭头函数中，this 是在函数声明的时候确定的(箭头函数不绑定this，会捕获上下文的this)</h5>]]></content>
      <categories>
        <category>JavaScript原理</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSrcipt知识点</title>
    <url>/2021/02/17/Javascript%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h4 id="1-script标签中async和defer的区别"><a href="#1-script标签中async和defer的区别" class="headerlink" title="1. script标签中async和defer的区别"></a>1. script标签中async和defer的区别</h4><p><img src="/../assets/Snipaste_2021-12-13_03-23-58.png" alt="image-20211025190555184"></p>
<ul>
<li>普通script标签：下载和执行都会阻塞Dom渲染</li>
<li>defer：立即进行异步下载，等到HTML完全解析完后开始执行，有多个defer的标签时，会按照顺序下载执行</li>
<li>async：立即进行异步下载，下载完后会立即执行同时阻塞Dom渲染，因为是下载完立即执行，不能保证多个加载时的先后顺序。</li>
</ul>
<span id="more"></span>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Jira项目</title>
    <url>/2022/03/02/Jira%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h4 id="代码自动格式化工具：prettier"><a href="#代码自动格式化工具：prettier" class="headerlink" title="代码自动格式化工具：prettier"></a>代码自动格式化工具：prettier</h4><p>配置过程：<a href="https://prettier.io/docs/en/precommit.html">https://prettier.io/docs/en/precommit.html</a></p>
<p><code>yarn add --dev --exact prettier</code></p>
<p>新建<code>.prettierrc.json，.prettierignore</code>文件</p>
<p>设置git commit预提交钩子</p>
<p><code>npx mrm@2 lint-staged </code></p>
<h4 id="规范git-commit工具：commitlint"><a href="#规范git-commit工具：commitlint" class="headerlink" title="规范git commit工具：commitlint"></a>规范git commit工具：commitlint</h4><p>配置过程：<a href="https://github.com/conventional-changelog/commitlint">https://github.com/conventional-changelog/commitlint</a></p>
<p><code>yarn add --save-dev @commitlint/config-conventional @commitlint/cli</code></p>
<p>新建 commitlint.config.js文件，引入规则module.exports &#x3D; {extends: [‘@commitlint&#x2F;config-conventional’]}</p>
<span id="more"></span>

<h4 id="常见MOCK方案"><a href="#常见MOCK方案" class="headerlink" title="常见MOCK方案"></a>常见MOCK方案</h4><h5 id="1-代码侵入（直接在代码中写死Mock数据，或请求本地的JSON文件"><a href="#1-代码侵入（直接在代码中写死Mock数据，或请求本地的JSON文件" class="headerlink" title="1. 代码侵入（直接在代码中写死Mock数据，或请求本地的JSON文件"></a>1. 代码侵入（直接在代码中写死Mock数据，或请求本地的JSON文件</h5><p>​	优点：无</p>
<p>​	缺点：与真实server环境的切换比较麻烦（需要修改请求地址），一切需要侵入代码切换环境的行为都是不好的</p>
<h5 id="2-请求拦截"><a href="#2-请求拦截" class="headerlink" title="2. 请求拦截"></a>2. 请求拦截</h5><p>​	代表：<a href="http://mockjs.com/">Mock.js</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Mock</span>.<span class="title function_">mock</span>(<span class="regexp">/\\\\/</span>api\\\\/visitor\\\\/list/, <span class="string">&#x27;get&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="number">2000</span>,</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;ok&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;data|10&#x27;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&#x27;id|+1&#x27;</span>: <span class="number">6</span>,</span><br><span class="line">      <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;@csentence(5)&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;tag&#x27;</span>: <span class="string">&#x27;@integer(6, 9)-@integer(10, 14)岁 @cword(&quot;零有&quot;, 1)基础&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;lesson_image&#x27;</span>: <span class="string">&quot;&lt;https://images.pexels.com/3737094/pexels-photo-3737094.jpeg&gt;&quot;</span>,</span><br><span class="line">      <span class="string">&#x27;lesson_package&#x27;</span>: <span class="string">&#x27;L1基础指令课&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;done&#x27;</span>: <span class="string">&#x27;@integer(10000, 99999)&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ol>
<li>与前端代码分离</li>
<li>可生成随机数据</li>
</ol>
<p>缺点：</p>
<ol>
<li>数据都是动态生成的假数据，无法真实模拟增删改查的情况</li>
<li>只支持ajax，不支持fetch（本质上是重写了ajax方法，两者的差别见：<a href="https://zhuanlan.zhihu.com/p/24594294">AJAX 之 XHR, Fetch 的对比</a>）</li>
</ol>
<h5 id="3-接口管理工具"><a href="#3-接口管理工具" class="headerlink" title="3. 接口管理工具"></a>3. 接口管理工具</h5><p>代表：rap，swagger，moco，yapi</p>
<p>优点：</p>
<p>​	1.配置功能强大，接口管理与Mock一体，后端修改接口Mock也跟着更改，可靠</p>
<p>缺点：</p>
<p>​	1.配置复杂，依赖后端</p>
<p>​	2.一般会作为大团队的基础建设而存在</p>
<h5 id="4-本地node服务器"><a href="#4-本地node服务器" class="headerlink" title="4. 本地node服务器"></a>4. 本地node服务器</h5><p>代表：<a href="https://github.com/typicode/json-server">json-server</a></p>
<p>优点：</p>
<p>​	1.配置简单，json-server甚至可以0代码30s启动一个REST API Server</p>
<p>​	2.自定义程度高</p>
<p>​	3.增删改查真是模拟</p>
<h5 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h5><p>一句话总结：URI 代表 资源&#x2F;对象，METHOD 代表行为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /tickets // 列表</span><br><span class="line">GET /tickets/12 // 详情</span><br><span class="line">POST /tickets  // 增加</span><br><span class="line">PUT /tickets/12 // 替换</span><br><span class="line">PATCH /tickets/12 // 修改</span><br><span class="line">DELETE /tickets/12 // 删除</span><br></pre></td></tr></table></figure>



<h4 id="d-ts类型文件"><a href="#d-ts类型文件" class="headerlink" title="d.ts类型文件"></a>d.ts类型文件</h4><p>改造js文件为ts文件后，引入的qs库报错</p>
<p><img src="/../assets/image-20211110193223804.png" alt="image-20211110193223804"></p>
<p><code>yarn add @types/qs --save-dev   </code> 安装对应的ts补丁文件</p>
<p><strong>d.ts文件的作用：说明书文件</strong></p>
<p>JS 文件 + .d.ts 文件   &#x3D;&#x3D;&#x3D; ts 文件</p>
<p>.d.ts 文件可以让 JS 文件继续维持自己JS文件的身份，而拥有TS的类型保护</p>
<p>一般写业务代码不会用到，但是点击类型跳转一般会跳转到 .d.ts文件</p>
]]></content>
      <categories>
        <category>Chore</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Mini-React</title>
    <url>/2022/03/04/Mini-React/</url>
    <content><![CDATA[<h4 id="项目拆解："><a href="#项目拆解：" class="headerlink" title="项目拆解："></a>项目拆解：</h4><ol>
<li><p>Jsx 和虚拟 DOM</p>
</li>
<li><p>组件和生命周期</p>
</li>
<li><p>Diff</p>
</li>
<li><p>异步的setState</p>
</li>
<li><p>hook支持</p>
</li>
</ol>
<h4 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h4><h5 id="将jsx经过babel转成React-createElement的形式"><a href="#将jsx经过babel转成React-createElement的形式" class="headerlink" title="将jsx经过babel转成React.createElement的形式"></a>将jsx经过babel转成React.createElement的形式</h5><p>例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hem</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">A</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">B</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">C</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">div</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">span</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">C</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">D</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">B</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">E</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">F</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">A</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过babel转义后</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">_createClass</span>(<span class="title class_">Hem</span>, [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">key</span>: <span class="string">&quot;render&quot;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">                A,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                <span class="comment">// A组件的亲儿子组件B</span></span><br><span class="line">                <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">                    B,</span><br><span class="line">                    <span class="literal">null</span>,</span><br><span class="line">                    <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">                        C,</span><br><span class="line">                        <span class="literal">null</span>,</span><br><span class="line">                        <span class="comment">// C组件的亲儿子 div</span></span><br><span class="line">                        <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>),</span><br><span class="line">                        <span class="comment">// C组件的亲儿子 span</span></span><br><span class="line">                        <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>)</span><br><span class="line">                    ),</span><br><span class="line">                    <span class="title class_">React</span>.<span class="title function_">createElement</span>(D, <span class="literal">null</span>)</span><br><span class="line">                ),</span><br><span class="line">                <span class="comment">// A组件的亲儿子组件E</span></span><br><span class="line">                <span class="title class_">React</span>.<span class="title function_">createElement</span>(E, <span class="literal">null</span>),</span><br><span class="line">                <span class="comment">// A组件的亲儿子组件F</span></span><br><span class="line">                <span class="title class_">React</span>.<span class="title function_">createElement</span>(F, <span class="literal">null</span>)</span><br><span class="line">            );</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h5 id="createElement生成虚拟dom"><a href="#createElement生成虚拟dom" class="headerlink" title="createElement生成虚拟dom"></a>createElement生成虚拟dom</h5>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Node中的process.env</title>
    <url>/2022/03/11/Node%E4%B8%AD%E7%9A%84process.env/</url>
    <content><![CDATA[<h4 id="process-env"><a href="#process-env" class="headerlink" title="process.env"></a>process.env</h4><p><code>process</code> 是 <code>Node.js</code> 中的 一个全局变量，提供来有关当前 Node.js 进程的信息并对其进行控制。而<code>process</code> 中的 <code>env</code> 则是返回包含用户环境的对象。可以通过 <code>process.env</code> 拿到当前项目运行环境的信息。</p>
<h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><h5 id="通过cli的方式进行设置"><a href="#通过cli的方式进行设置" class="headerlink" title="通过cli的方式进行设置"></a>通过cli的方式进行设置</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js中</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(process.<span class="property">env</span>.<span class="property">PROT</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Windows (cmd.exe)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> PROT=10086 &amp;&amp; node index.js</span><br></pre></td></tr></table></figure>

<p><strong>Linux, macOS (Bash)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PROT=10086 node index.js</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h5 id="env文件"><a href="#env文件" class="headerlink" title=".env文件"></a><a name="env">.env文件</a></h5><ul>
<li>创建</li>
</ul>
<p>直接在项目根目录中创建 <code>.env</code> 文件，然后键入环境变量及其值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NDOE_ENV=development</span><br><span class="line">PROT=10086</span><br><span class="line">APP_KEY=***********</span><br><span class="line">HOST_URL=**********</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>⚠️注意</strong>：不要把<code>.env</code>文入放入代码版本管理中，因为这些环境变量都是项目中的隐私数据。</p>
<ul>
<li>读取</li>
</ul>
<p><strong>在cra创建的项目中，自带了dotenv解析.env，所以创建.env文件后即可</strong>。</p>
<p>创建 <code>.env</code> 文件后，可以自己编写代码来查找解析文件并将其写入到你的项目中，或者利用第三方的<code>npm</code>包，比如 <a href="https://link.juejin.cn/?target=https://github.com/motdotla/dotenv"><code>dotenv</code></a> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add dotenv</span><br><span class="line"></span><br><span class="line"><span class="comment">// .env</span></span><br><span class="line"><span class="variable constant_">PROT</span>=<span class="number">10086</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> dotenv = <span class="built_in">require</span>(<span class="string">&#x27;dotenv&#x27;</span>);</span><br><span class="line">dotenv.<span class="title function_">config</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(process.<span class="property">env</span>.<span class="property">PROT</span>); <span class="comment">// 10086</span></span><br></pre></td></tr></table></figure>

<p>现在当你执行命令脚本的时候就不用传入环境变量及其值了，在 <code>.env</code> 文件里也能更直观的看到和管理各环境变量的配置。</p>
<h5 id="更好的组织"><a href="#更好的组织" class="headerlink" title="更好的组织"></a>更好的组织</h5><p>一旦环境变量变多，就需要对所有环境变量进行集中式的管理，因为在所有需要使用的地直接引用变量与集中管理相比，重构和维护会更加困难。</p>
<p>所以<strong>创建一个负责收集环境变量的模块</strong>是一个更好的方式，这样可以轻松地一次查看环境变量并将它们映射为可读的名称。</p>
<ul>
<li>手动整理</li>
</ul>
<p>创建一个名为 <code>config.js</code> 的文件，然后写入变量，将其命名为具有良好可读性的属性进行并导出它们。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dotenv = <span class="built_in">require</span>（<span class="string">&#x27;dotenv&#x27;</span>）; </span><br><span class="line"></span><br><span class="line">dotenv.<span class="property">config</span>（）; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123; </span><br><span class="line">  hostUrl：process.<span class="property">env</span>.<span class="property">HOST_URL</span>，</span><br><span class="line">  secretKey：process.<span class="property">env</span>.<span class="property">API_KEY</span>，</span><br><span class="line">  port：process.<span class="property">env</span>.<span class="property">PORT</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后就可以这样进行使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;port&#125; = <span class="built_in">require</span>（<span class="string">&#x27;./ config&#x27;</span>）; </span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span>（<span class="string">`端口为：$ &#123;port&#125;`</span>）; <span class="comment">// 10086</span></span><br></pre></td></tr></table></figure>

<p>这样有什么好处呢？</p>
<ol>
<li><p>项目文件组织更为直观合理</p>
</li>
<li><p>清楚的知道环境变量的映射关系</p>
</li>
<li><p>变量重命名为更具可读性的属性</p>
</li>
<li><p>可以添加其他非环境变量的配置属性</p>
</li>
</ol>
<p>但是如果要添加新的环境变量时，就必须将其添加到<code>config</code>模块中。</p>
<ul>
<li>自动整理</li>
</ul>
<p>前面提到的第三方 <code>NPM</code> 包 <code>dotenv</code> 就可以做到。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config.js </span></span><br><span class="line"><span class="keyword">const</span> dotenv = <span class="built_in">require</span>(<span class="string">&#x27;dotenv&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> result = dotenv.<span class="title function_">config</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result.<span class="property">error</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> result.<span class="property">error</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">parsed</span>: envs &#125; = result;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(envs);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = envs;</span><br></pre></td></tr></table></figure>

<p>然后就可以其他模块中这样引用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="variable constant_">HOST_URL</span>, <span class="variable constant_">API_KEY</span>, <span class="variable constant_">PROT</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./config&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="CRA创建的项目使用环境变量"><a href="#CRA创建的项目使用环境变量" class="headerlink" title="CRA创建的项目使用环境变量"></a>CRA创建的项目使用环境变量</h4><p>必须以 <code>REACT_APP_</code> 开头创建自定义环境变量，环境变量在构建期间嵌入。</p>
<h5 id="设置临时环境变量"><a href="#设置临时环境变量" class="headerlink" title="设置临时环境变量"></a>设置临时环境变量</h5><p><strong>Windows (cmd.exe)</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="string">&quot;REACT_APP_SECRET_CODE=abcdef&quot;</span> &amp;&amp; npm <span class="built_in">start</span></span><br></pre></td></tr></table></figure>

<p>（注意：变量赋值需要用引号包裹，以避免尾随空格。）</p>
<p><strong>Windows (Powershell)</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(<span class="variable">$env:REACT_APP_SECRET_CODE</span> = <span class="string">&quot;abcdef&quot;</span>) <span class="operator">-and</span> (npm <span class="built_in">start</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Linux, macOS (Bash)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">REACT_APP_SECRET_CODE=abcdef npm start</span><br></pre></td></tr></table></figure>



<h5 id="env-中添加环境变量"><a href="#env-中添加环境变量" class="headerlink" title=".env 中添加环境变量"></a><code>.env</code> 中添加环境变量</h5><p>见<a href="#env">上文</a>设置。</p>
<h5 id="其他-env-文件"><a href="#其他-env-文件" class="headerlink" title="其他 .env 文件"></a>其他 <code>.env</code> 文件</h5><blockquote>
<p>注意：此功能 <strong>适用于 <code>react-scripts@1.0.0</code> 及更高版本</strong>。</p>
</blockquote>
<ul>
<li><code>.env</code>：默认。</li>
<li><code>.env.local</code>：本地覆盖。<strong>除 test 之外的所有环境都加载此文件</strong>。</li>
<li><code>.env.development</code>, <code>.env.test</code>, <code>.env.production</code>：设置特定环境。</li>
<li><code>.env.development.local</code>, <code>.env.test.local</code>, <code>.env.production.local</code>：设置特定环境的本地覆盖。</li>
</ul>
<p>左侧的文件比右侧的文件具有更高的优先级：</p>
<ul>
<li><code>npm start</code>: <code>.env.development.local</code>, <code>.env.development</code>, <code>.env.local</code>, <code>.env</code></li>
<li><code>npm run build</code>: <code>.env.production.local</code>, <code>.env.production</code>, <code>.env.local</code>, <code>.env</code></li>
<li><code>npm test</code>: <code>.env.test.local</code>, <code>.env.test</code>, <code>.env</code> (注意没有 <code>.env.local</code> )</li>
</ul>
<h5 id="NODE-ENV-的特殊内置环境变量"><a href="#NODE-ENV-的特殊内置环境变量" class="headerlink" title="NODE_ENV 的特殊内置环境变量"></a><code>NODE_ENV</code> 的特殊内置环境变量</h5><p>有一个名为 <code>NODE_ENV</code> 的特殊内置环境变量。可以从 <code>process.env.NODE_ENV</code> 中读取。运行 <code>npm start</code> 时，它总是等于 <code>&#39;development&#39;</code> ，运行 <code>npm test</code> 它总是等于 <code>&#39;test&#39;</code> ，运行 <code>npm run build</code> 来生成一个生产 bundle(包) 时，它总是等于 <code>&#39;production&#39;</code> 。**<code>NODE_ENV</code>无法手动覆盖。** </p>
]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2021/09/11/Promise/</url>
    <content><![CDATA[<h3 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h3><p>感觉promise的思想非常有意思，为了代码的可读性和可维护性提供了一种新的异步编程方法，接触了一段时间的工程代码也让我体会到代码可维护，可拓展的必要性。</p>
<h3 id="为什么要用Promise？"><a href="#为什么要用Promise？" class="headerlink" title="为什么要用Promise？"></a>为什么要用Promise？</h3><p>对于异步操作，例如文件读取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./a.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./b.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./c.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<p>输出结果：</p>
<p><img src="/../assets/image-20210324010746141.png" alt="image-20210324010746141"></p>
<p>由于读取文件为异步操作，输出的结果不确定。</p>
<p>为了a -&gt; b -&gt; c依次读取文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./src/a.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./src/b.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./src/c.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="keyword">throw</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>回调函数嵌套回调函数，导致了回调地狱，带来的问题也很明显，不便于维护，阅读，异常处理。</p>
<p>使用promise：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myReadFile</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(url, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">resolve</span>(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">myReadFile</span>(<span class="string">&#x27;./a.txt&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">myReadFile</span>(<span class="string">&#x27;./b.txt&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">myReadFile</span>(<span class="string">&#x27;./c.txt&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reason&#x27;</span>, reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>由于异常穿透，异常只需要在最后捕获，代码的可读性和维护性也更高，解决了回调地狱的问题。</p>
<h3 id="Promise的工作流程"><a href="#Promise的工作流程" class="headerlink" title="Promise的工作流程"></a>Promise的工作流程</h3><p><img src="/../assets/image-20210321164956018.png" alt="image-20210321164956018"></p>
<h3 id="如何改变promise对象的状态？"><a href="#如何改变promise对象的状态？" class="headerlink" title="如何改变promise对象的状态？"></a>如何改变promise对象的状态？</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//1. resolve 函数</span></span><br><span class="line">    <span class="comment">// resolve(&#x27;&#x27;); // pending   =&gt; fulfilled (resolved)</span></span><br><span class="line">    <span class="comment">//2. reject 函数</span></span><br><span class="line">    <span class="comment">// reject(&quot;&quot;);// pending  =&gt;  rejected </span></span><br><span class="line">    <span class="comment">//3. 抛出错误</span></span><br><span class="line">    <span class="comment">//throw &#x27;出问题了&#x27;;// pending  =&gt;  rejected</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>Promise对象初始状态</li>
</ul>
<p><img src="/../assets/image-20210321172121084.png" alt="image-20210321172121084"></p>
<ul>
<li>Promise对象成功状态</li>
</ul>
<p><img src="/../assets/image-20210322004628047.png" alt="image-20210322004628047"></p>
<ul>
<li>Promise对象失败状态</li>
</ul>
<p><img src="/../assets/image-20210322004718603.png" alt="image-20210322004718603"></p>
<h3 id="Promise-Api"><a href="#Promise-Api" class="headerlink" title="Promise Api"></a>Promise Api</h3><h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h4><figure class="highlight plaintext"><figcaption><span>方法返回一个 ```Promise```。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### Promise.prototype.then()返回的新 promise 的结果状态由什么决定?</span><br><span class="line"></span><br><span class="line">​       **由 then()指定的回调函数执行的结果决定**</span><br><span class="line"></span><br><span class="line">1. 如果抛出异常, 新 promise 变为 rejected, *[[PromiseResult]]*为抛出的异常 </span><br><span class="line"></span><br><span class="line">2. 如果返回的是非 promise 的任意值, 或者没有返回值（相当于返回undefined），新 promise 变为 resolved, *[[PromiseResult]]*为返回的值 </span><br><span class="line"></span><br><span class="line">3. ***如果返回的是另一个新 promise, 此promise的状态成为新promise的状态，此 promise 的[[PromiseResult]]就会成为新 promise 的[[PromiseResult]]***</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">let result = p.then(value =&gt; &#123;</span><br><span class="line">    // console.log(value);</span><br><span class="line">    //1. 抛出错误</span><br><span class="line">    // throw &#x27;出了问题&#x27;;</span><br><span class="line">    //2. 返回结果是非 Promise 类型的对象</span><br><span class="line">    // return 521;</span><br><span class="line">    //3. 返回结果是 Promise 对象</span><br><span class="line">    // return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    //     // resolve(&#x27;success&#x27;);</span><br><span class="line">    //     reject(&#x27;error&#x27;);</span><br><span class="line">    // &#125;);</span><br><span class="line">&#125;, reason =&gt; &#123;</span><br><span class="line">    console.warn(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="then的链式调用"><a href="#then的链式调用" class="headerlink" title="then的链式调用"></a>then的链式调用</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 链式调用</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);<span class="comment">//输出undefine，原因：上一次的then方法返回值为undefine，所以上一次返回一个参数为undefine，状态为resolve的promise对象</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h4><ul>
<li>如果传入的参数为 非Promise类型的对象, 则返回的结果为成功promise对象</li>
<li>如果传入的参数为 Promise 对象, 则参数的结果决定了 resolve 的结果</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">521</span>);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// resolve(&#x27;OK&#x27;);</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// console.log(p2);</span></span><br><span class="line">p2.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h4><p>Promise.reject(reason)方法返回一个失败的promise对象（无论reason是什么）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="/../assets/image-20210321171102762.png" alt="image-20210321171102762"></p>
<h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h4><p><strong>catch()</strong> 方法返回一个Promise，只处理拒绝的情况。它的行为与调用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"><code>Promise.prototype.then(undefined, onRejected)</code></a>相同。</p>
<h3 id="Promise关键问题"><a href="#Promise关键问题" class="headerlink" title="Promise关键问题"></a>Promise关键问题</h3><h4 id="Promise可以执行多个成功-失败的回调"><a href="#Promise可以执行多个成功-失败的回调" class="headerlink" title="Promise可以执行多个成功&#x2F;失败的回调"></a>Promise可以执行多个成功&#x2F;失败的回调</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">///指定回调 - 1</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//指定回调 - 2</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="异常穿透"><a href="#异常穿透" class="headerlink" title="异常穿透"></a>异常穿透</h4><ol>
<li><p>当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调。</p>
</li>
<li><p>前面任何操作出了异常, 都会传到最后失败的回调中处理</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//resolve(&#x27;OK&#x27;);</span></span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&#x27;Err&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(111);</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;失败啦!&#x27;</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason); <span class="comment">// 如果前面then有设置失败的回调，则会在前面就被捕获</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hyz&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Err</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// hyz</span></span><br></pre></td></tr></table></figure>

<h4 id="如何中断Promise链？"><a href="#如何中断Promise链？" class="headerlink" title="如何中断Promise链？"></a>如何中断Promise链？</h4><p>添加一个pendding状态的promise</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">    <span class="comment">//有且只有一个方式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Async与Await"><a href="#Async与Await" class="headerlink" title="Async与Await"></a>Async与Await</h3><p>Async&#x2F;Await 是js异步编程的终极解决方案</p>
<h4 id="Async函数"><a href="#Async函数" class="headerlink" title="Async函数"></a>Async函数</h4><p>返回值规则与Promise.prototype.then()相同</p>
<ul>
<li>函数的返回值为 promise 对象</li>
<li>promise 对象的结果由 async 函数执行的返回值决定</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//1. 如果返回值是一个非Promise类型的数据</span></span><br><span class="line">    <span class="comment">// return 521;</span></span><br><span class="line">    <span class="comment">//2. 如果返回的是一个Promise对象</span></span><br><span class="line">    <span class="comment">// return new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     // resolve(&#x27;OK&#x27;);</span></span><br><span class="line">    <span class="comment">//     reject(&#x27;Error&#x27;);</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line">    <span class="comment">//3. 抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;Oh NO&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Await表达式"><a href="#Await表达式" class="headerlink" title="Await表达式"></a>Await表达式</h4><ul>
<li>await 右侧的表达式一般为 promise 对象, 但也可以是其它的值</li>
<li>如果表达式是 promise 对象, await 返回的是 promise 成功的值([[PromiseResult]])</li>
<li>如果表达式是其它值, 直接将此值作为 await 的返回值</li>
</ul>
<h4 id="mentoon："><a href="#mentoon：" class="headerlink" title="mentoon："></a>mentoon：</h4><ol>
<li>await 必须写在 async 函数中, 但 async 函数中可以没有 await</li>
<li>如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// resolve(&#x27;OK&#x27;);</span></span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//1. 右侧为promise的情况</span></span><br><span class="line">    <span class="comment">// let res = await p;</span></span><br><span class="line">    <span class="comment">//2. 右侧为其他类型的数据</span></span><br><span class="line">    <span class="comment">// let res2 = await 20;</span></span><br><span class="line">    <span class="comment">//3. 如果promise是失败的状态</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res3 = <span class="keyword">await</span> p;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure>

<h3 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./resource/1.html&#x27;</span>, <span class="function">(<span class="params">err, data1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./resource/2.html&#x27;</span>, <span class="function">(<span class="params">err, data2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./resource/3.html&#x27;</span>, <span class="function">(<span class="params">err, data3</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data1 + data2 + data3);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//async 与 await</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//读取第一个文件的内容</span></span><br><span class="line">        <span class="keyword">let</span> data1 = <span class="keyword">await</span> <span class="title function_">mineReadFile</span>(<span class="string">&#x27;./resource/1x.html&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> data2 = <span class="keyword">await</span> <span class="title function_">mineReadFile</span>(<span class="string">&#x27;./resource/2.html&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> data3 = <span class="keyword">await</span> <span class="title function_">mineReadFile</span>(<span class="string">&#x27;./resource/3.html&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data1 + data2 + data3);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="async-await-封装ajax"><a href="#async-await-封装ajax" class="headerlink" title="async await 封装ajax"></a>async await 封装ajax</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点击获取段子<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//axios</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">sendAJAX</span>(<span class="params">url</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="property">responseType</span> = <span class="string">&#x27;json&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url);</span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//处理结果</span></span></span><br><span class="line"><span class="language-javascript">                xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">//判断成功</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="comment">//成功的结果</span></span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">resolve</span>(xhr.<span class="property">response</span>);</span></span><br><span class="line"><span class="language-javascript">                        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="title function_">reject</span>(xhr.<span class="property">status</span>);</span></span><br><span class="line"><span class="language-javascript">                        &#125;</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//段子接口地址 https://api.apiopen.top/getJoke</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#btn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//获取段子信息</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> duanzi = <span class="keyword">await</span> <span class="title function_">sendAJAX</span>(<span class="string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(duanzi);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>React Router</title>
    <url>/2021/09/11/React-Router/</url>
    <content><![CDATA[<h3 id="SPA的理解"><a href="#SPA的理解" class="headerlink" title="SPA的理解"></a>SPA的理解</h3><ol>
<li><p>单页Web应用（single page web application，SPA）。</p>
</li>
<li><p>整个应用只有<strong>一个完整的页面</strong>。</p>
</li>
<li><p>点击页面中的链接<strong>不会刷新</strong>页面，只会做页面的<strong>局部更新。</strong></p>
</li>
<li><p>数据都需要通过ajax请求获取, 并在前端异步展现。</p>
</li>
</ol>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h5 id="后端路由"><a href="#后端路由" class="headerlink" title="后端路由"></a>后端路由</h5><ul>
<li><p>注册路由： router.get(path, function(req, res))</p>
</li>
<li><p>工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据</p>
</li>
</ul>
<h5 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h5><ul>
<li><p>注册路由: <code>&lt;Route path=&quot;/test&quot; component=&#123;Test&#125;&gt;</code></p>
</li>
<li><p>工作过程：当浏览器的path变为&#x2F;test时, 当前路由组件就会变为Test组件</p>
</li>
</ul>
<span id="more"></span>

<h3 id="React-router-dom相关API"><a href="#React-router-dom相关API" class="headerlink" title="React-router-dom相关API"></a>React-router-dom相关API</h3><h4 id="1-内置API"><a href="#1-内置API" class="headerlink" title="1.内置API"></a>1.内置API</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;BrowserRouter&gt; &lt;/BrowserRouter&gt;</span><br><span class="line"></span><br><span class="line">&lt;HashRouter&gt; &lt;/HashRouter&gt;</span><br><span class="line"></span><br><span class="line">&lt;Route&gt; &lt;/Route&gt;</span><br><span class="line"></span><br><span class="line">&lt;Redirect&gt; &lt;/Redirect&gt;</span><br><span class="line"></span><br><span class="line">&lt;Link&gt; &lt;/Link&gt;</span><br><span class="line"></span><br><span class="line">&lt;NavLink&gt; &lt;/NavLink&gt;</span><br><span class="line"></span><br><span class="line">&lt;Switch&gt; &lt;/Switch&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-其他"><a href="#2-其他" class="headerlink" title="2. 其他"></a>2. 其他</h4><ul>
<li><p>history对象</p>
</li>
<li><p>match对象</p>
</li>
<li><p>withRouter函数</p>
</li>
</ul>
<h3 id="路由组件与一般组件"><a href="#路由组件与一般组件" class="headerlink" title="路由组件与一般组件"></a>路由组件与一般组件</h3><h5 id="1-写法不同："><a href="#1-写法不同：" class="headerlink" title="1. 写法不同："></a>1. 写法不同：</h5><p>一般组件： <code>&lt;Demo/&gt;</code><br>路由组件： <code>&lt;Route path=&quot;/demo&quot; component=&#123;Demo&#125;/&gt;</code></p>
<h5 id="2-存放位置不同："><a href="#2-存放位置不同：" class="headerlink" title="2. 存放位置不同："></a>2. 存放位置不同：</h5><p>一般组件：components<br>路由组件：pages</p>
<h5 id="3-接收到的props不同："><a href="#3-接收到的props不同：" class="headerlink" title="3. 接收到的props不同："></a>3. 接收到的props不同：</h5><p>一般组件：写组件标签时传递了什么，就能收到什么<br>路由组件：接收到三个固定的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">history</span>:</span><br><span class="line">	<span class="attr">go</span>: ƒ <span class="title function_">go</span>(n)</span><br><span class="line">	<span class="attr">goBack</span>: ƒ <span class="title function_">goBack</span>()</span><br><span class="line">	<span class="attr">goForward</span>: ƒ <span class="title function_">goForward</span>()</span><br><span class="line">	<span class="attr">push</span>: ƒ <span class="title function_">push</span>(path, state)</span><br><span class="line">	<span class="attr">replace</span>: ƒ <span class="title function_">replace</span>(path, state)</span><br><span class="line"><span class="attr">location</span>:</span><br><span class="line">	<span class="attr">pathname</span>: <span class="string">&quot;/about&quot;</span></span><br><span class="line">	<span class="attr">search</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="attr">state</span>: <span class="literal">undefined</span></span><br><span class="line"><span class="attr">match</span>:</span><br><span class="line">	<span class="attr">params</span>: &#123;&#125;</span><br><span class="line">	<span class="attr">path</span>: <span class="string">&quot;/about&quot;</span></span><br><span class="line">	<span class="attr">url</span>: <span class="string">&quot;/about&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="NavLink与封装NavLink"><a href="#NavLink与封装NavLink" class="headerlink" title="NavLink与封装NavLink"></a>NavLink与封装NavLink</h3><ul>
<li>NavLink可以实现路由链接的高亮，通过activeClassName指定样式名</li>
</ul>
<h3 id="Switch的使用"><a href="#Switch的使用" class="headerlink" title="Switch的使用"></a>Switch的使用</h3><ul>
<li>通常情况下，path和component是一一对应的关系。</li>
<li>Switch可以提高路由匹配效率(单一匹配)。</li>
</ul>
<h3 id="解决多级路径刷新页面样式丢失的问题"><a href="#解决多级路径刷新页面样式丢失的问题" class="headerlink" title="解决多级路径刷新页面样式丢失的问题"></a>解决多级路径刷新页面样式丢失的问题</h3><ul>
<li>public&#x2F;index.html 中 引入样式时不写 .&#x2F; 写 &#x2F; （常用）</li>
<li>public&#x2F;index.html 中 引入样式时不写 .&#x2F; 写 %PUBLIC_URL% （常用）</li>
<li>使用HashRouter</li>
</ul>
<h3 id="路由的严格匹配与模糊匹配"><a href="#路由的严格匹配与模糊匹配" class="headerlink" title="路由的严格匹配与模糊匹配"></a>路由的严格匹配与模糊匹配</h3><ul>
<li>默认使用的是模糊匹配（简单记：【输入的路径】必须包含要【匹配的路径】，且顺序要一致）</li>
<li>开启严格匹配：<code>&lt;Route exact=&#123;true&#125; path=&quot;/about&quot; component=&#123;About&#125;/&gt;</code></li>
<li>严格匹配不要随便开启，需要再开，有些时候开启会导致无法继续匹配二级路由</li>
</ul>
<h3 id="Redirect的使用"><a href="#Redirect的使用" class="headerlink" title="Redirect的使用"></a>Redirect的使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>一般写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到<span class="title class_">Redirect</span>指定的路由</span><br><span class="line"><span class="number">2.</span>具体编码：</span><br><span class="line">&lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;/</span>&gt;</span></span></span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>/&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Switch</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><ul>
<li>注册子路由时要写上父路由的path值</li>
<li>路由的匹配是按照注册路由的顺序进行的</li>
</ul>
<h3 id="向路由组件传递参数"><a href="#向路由组件传递参数" class="headerlink" title="向路由组件传递参数"></a>向路由组件传递参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>params参数</span><br><span class="line">	路由链接(携带参数)：&lt;<span class="title class_">Link</span> to=<span class="string">&#x27;/demo/test/tom/18&#x27;</span>&#125;&gt;详情&lt;/<span class="title class_">Link</span>&gt;</span><br><span class="line">	注册路由(声明接收)：&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/demo/test/:name/:age&quot;</span> component=&#123;<span class="title class_">Test</span>&#125;/&gt;</span><br><span class="line">	接收参数：<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">match</span>.<span class="property">params</span></span><br><span class="line"><span class="number">2.</span>search参数</span><br><span class="line">	路由链接(携带参数)：&lt;<span class="title class_">Link</span> to=<span class="string">&#x27;/demo/test?name=tom&amp;age=18&#x27;</span>&#125;&gt;详情&lt;/<span class="title class_">Link</span>&gt;</span><br><span class="line">	注册路由(无需声明，正常注册即可)：&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/demo/test&quot;</span> component=&#123;<span class="title class_">Test</span>&#125;/&gt;</span><br><span class="line">	接收参数：<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">location</span>.<span class="property">search</span></span><br><span class="line">	备注：获取到的search是urlencoded编码字符串，需要借助querystring解析</span><br><span class="line"><span class="number">3.</span>state参数</span><br><span class="line">	路由链接(携带参数)：&lt;<span class="title class_">Link</span> to=&#123;&#123;<span class="attr">pathname</span>:<span class="string">&#x27;/demo/test&#x27;</span>,<span class="attr">state</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;&#125;&#125;&gt;详情&lt;/<span class="title class_">Link</span>&gt;</span><br><span class="line">	注册路由(无需声明，正常注册即可)：&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/demo/test&quot;</span> component=&#123;<span class="title class_">Test</span>&#125;/&gt;</span><br><span class="line">	接收参数：<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">location</span>.<span class="property">state</span></span><br><span class="line">	备注：刷新也可以保留住参数</span><br></pre></td></tr></table></figure>



<h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">借助<span class="variable language_">this</span>.<span class="property">prosp</span>.<span class="property">history</span>对象上的<span class="variable constant_">API</span>对操作路由跳转、前进、后退</span><br><span class="line">	-<span class="variable language_">this</span>.<span class="property">prosp</span>.<span class="property">history</span>.<span class="title function_">push</span>()</span><br><span class="line">	-<span class="variable language_">this</span>.<span class="property">prosp</span>.<span class="property">history</span>.<span class="title function_">replace</span>()</span><br><span class="line">	-<span class="variable language_">this</span>.<span class="property">prosp</span>.<span class="property">history</span>.<span class="title function_">goBack</span>()</span><br><span class="line">	-<span class="variable language_">this</span>.<span class="property">prosp</span>.<span class="property">history</span>.<span class="title function_">goForward</span>()</span><br><span class="line">	-<span class="variable language_">this</span>.<span class="property">prosp</span>.<span class="property">history</span>.<span class="title function_">go</span>()</span><br></pre></td></tr></table></figure>



<h3 id="BrowserRouter与HashRouter的区别"><a href="#BrowserRouter与HashRouter的区别" class="headerlink" title="BrowserRouter与HashRouter的区别"></a>BrowserRouter与HashRouter的区别</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>底层原理不一样：</span><br><span class="line">	<span class="title class_">BrowserRouter</span>使用的是<span class="variable constant_">H5</span>的history <span class="variable constant_">API</span>，不兼容<span class="title class_">IE9</span>及以下版本。</span><br><span class="line">	<span class="title class_">HashRouter</span>使用的是<span class="variable constant_">URL</span>的哈希值。</span><br><span class="line"><span class="number">2.</span>path表现形式不一样</span><br><span class="line">	<span class="title class_">BrowserRouter</span>的路径中没有#,例如：<span class="attr">localhost</span>:<span class="number">3000</span>/demo/test</span><br><span class="line">	<span class="title class_">HashRouter</span>的路径包含#,例如：<span class="attr">localhost</span>:<span class="number">3000</span>/#/demo/test</span><br><span class="line"><span class="number">3.</span>刷新后对路由state参数的影响</span><br><span class="line">	(<span class="number">1</span>).<span class="property">BrowserRouter</span>没有任何影响，因为state保存在history对象中。</span><br><span class="line">	(<span class="number">2</span>).<span class="property">HashRouter</span>刷新后会导致路由state参数的丢失！！！</span><br><span class="line"><span class="number">4.</span>备注：<span class="title class_">HashRouter</span>可以用于解决一些路径错误相关的问题。</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React</title>
    <url>/2021/09/27/React/</url>
    <content><![CDATA[<p>React用于编写SPA（单页应用）</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><h4 id="回调形式Ref调用次数"><a href="#回调形式Ref调用次数" class="headerlink" title="回调形式Ref调用次数"></a>回调形式Ref调用次数</h4><p>如果 <code>ref</code> 回调函数是以内联函数的方式定义</p>
<p>例如：</p>
<p><code>&lt;input ref=&#123;(c)=&gt;&#123;this.input1 = c;console.log(&#39;@&#39;,c);&#125;&#125; type=&quot;text&quot;/&gt;</code></p>
<p>在更新过程中它会被执行两次，第一次传入参数 <code>null</code>，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。</p>
<h4 id="createRef创建ref容器"><a href="#createRef创建ref容器" class="headerlink" title="createRef创建ref容器"></a>createRef创建ref容器</h4><p>React.createRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点,该容器是“专人专用”的</p>
<p><code>myRef = React.createRef()</code></p>
<p><code>&lt;input ref = &#123;this.myRef&#125;/&gt;</code></p>
<span id="more"></span>

<h2 id="React事件处理"><a href="#React事件处理" class="headerlink" title="React事件处理"></a>React事件处理</h2><ol>
<li>通过onXxx属性指定事件处理函数(注意大小写)</li>
</ol>
<p> a.React使用的是自定义(合成)事件, 而不是使用的原生DOM事件 —— 为了更好的兼容性</p>
<p> b.React中的事件是通过事件委托方式处理的(委托给组件最外层的元素)——为了的高效</p>
<ol start="2">
<li>通过event.target得到发生事件的DOM元素对象——不要过度使用ref</li>
</ol>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><ol>
<li><p>若A函数，接收的参数是一个函数，那么A就可以称之为高阶函数。</p>
</li>
<li><p>若A函数，调用的返回值依然是一个函数，那么A就可以称之为高阶函数。</p>
</li>
</ol>
<p>  常见的高阶函数有：Promise、setTimeout、arr.map()等等</p>
<h4 id="函数的柯里化："><a href="#函数的柯里化：" class="headerlink" title="函数的柯里化："></a>函数的柯里化：</h4><p>通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function">(<span class="params">b</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> a + b + c</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res = <span class="title function_">sum</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>高阶函数用例(统一函数编码形式，username,password函数统一写）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Login extends React.Component&#123;</span><br><span class="line">	//初始化状态</span><br><span class="line">	state = &#123;</span><br><span class="line">		username:&#x27;&#x27;, //用户名</span><br><span class="line">		password:&#x27;&#x27; //密码</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//保存表单数据到状态中</span><br><span class="line">	saveFormData = (dataType)=&gt;&#123;</span><br><span class="line">		return (event)=&gt;&#123;</span><br><span class="line">			this.setState(&#123;[dataType]:event.target.value&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//表单提交的回调</span><br><span class="line">	handleSubmit = (event)=&gt;&#123;</span><br><span class="line">		event.preventDefault() //阻止表单提交</span><br><span class="line">		const &#123;username,password&#125; = this.state</span><br><span class="line">		alert(`你输入的用户名是：$&#123;username&#125;,你输入的密码是：$&#123;password&#125;`)</span><br><span class="line">	&#125;</span><br><span class="line">	render()&#123;</span><br><span class="line">		return(</span><br><span class="line">			&lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">          用户名：&lt;input onChange=&#123;this.saveFormData(&#x27;username&#x27;)&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt;</span><br><span class="line">				密码：&lt;input onChange=&#123;this.saveFormData(&#x27;password&#x27;)&#125; type=&quot;password&quot; name=&quot;password&quot;/&gt;</span><br><span class="line">				&lt;button&gt;登录&lt;/button&gt;</span><br><span class="line">			&lt;/form&gt;</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不用柯里化实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input onChange=&#123;event =&gt; this.saveFormData(&#x27;username&#x27;,event) &#125; type=&quot;text&quot; name=&quot;username&quot;/&gt;</span><br><span class="line">&lt;input onChange=&#123;event =&gt; this.saveFormData(&#x27;password&#x27;,event) &#125; type=&quot;password&quot; name=&quot;password&quot;/&gt;</span><br></pre></td></tr></table></figure>



<h2 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h2><p>旧版本：</p>
<p><img src="/../assets/image-20210504015401966.png" alt="image-20210504015401966"></p>
<p>​    <strong>1.</strong> <strong>初始化阶段:</strong> 由ReactDOM.render()触发—初次渲染</p>
<ul>
<li><p><code> constructor()</code></p>
</li>
<li><p><code>componentWillMount()</code></p>
</li>
<li><p><code>render()</code></p>
</li>
<li><p><code>componentDidMount()</code></p>
</li>
</ul>
<p>​    <strong>2.</strong> <strong>更新阶段:</strong> 由组件内部this.setSate()或父组件重新render触发</p>
<ul>
<li><p><code>shouldComponentUpdate()</code></p>
</li>
<li><p><code>componentWillUpdate()</code></p>
</li>
<li><p><code>render()</code></p>
</li>
<li><p><code>componentDidUpdate()</code></p>
</li>
</ul>
<p>​    <strong>3.</strong> <strong>卸载组件:</strong> 由<code>ReactDOM.unmountComponentAtNode()</code>触发</p>
<ul>
<li><code>componentWillUnmount()</code></li>
</ul>
<p>不想对状态更改也想更新 – <code>forceUpdate()</code>(不受阀门shouldComponentUpdate控制)</p>
<p>componentWillReceiveProps：组件将要接收新的props，第一次传入props不会调用，实际上钩子名字为componentWillReceiveNewProps</p>
<p>新版本：</p>
<p><img src="/../assets/image-20210504015321638.png" alt="image-20210504015321638"></p>
<h2 id="DOM的Diffing算法"><a href="#DOM的Diffing算法" class="headerlink" title="DOM的Diffing算法"></a>DOM的Diffing算法</h2><p><img src="/../assets/image-20210504231622840.png" alt="image-20210504231622840"></p>
<ol>
<li><p>react&#x2F;vue中的key有什么作用？（key的内部原理是什么？）</p>
<p>虚拟DOM中key的作用：</p>
</li>
</ol>
<ul>
<li><p>简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。</p>
</li>
<li><p>详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】,</p>
</li>
</ul>
<p>​       随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：</p>
<p>​      a. 旧虚拟DOM中找到了与新虚拟DOM相同的key：</p>
<p>​          若虚拟DOM中内容没变, 直接使用之前的真实DOM </p>
<p>​          若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM</p>
<p>​      b. 旧虚拟DOM中未找到与新虚拟DOM相同的key</p>
<p>​          根据数据创建新的真实DOM，随后渲染到到页面</p>
<ol start="2">
<li>为什么遍历列表时，key最好不要用index?</li>
</ol>
<p>​      用index作为key可能会引发的问题：</p>
<ul>
<li>若对数据进行：逆序添加、逆序删除等破坏顺序操作:</li>
</ul>
<p>​       会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题, 但效率低。</p>
<ul>
<li>如果结构中还包含输入类的DOM：</li>
</ul>
<p>​        会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题。</p>
<ul>
<li>如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，</li>
</ul>
<p>​      仅用于渲染列表用于展示，使用index作为key是没有问题的。</p>
<p>​                  </p>
<ol start="3">
<li>开发中如何选择key?:</li>
</ol>
<ul>
<li><p>最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。</p>
</li>
<li><p>如果确定只是简单的展示数据，用index也是可以的。</p>
</li>
</ul>
<h2 id="React-Staging"><a href="#React-Staging" class="headerlink" title="React-Staging"></a>React-Staging</h2><p>React-Staging项目结构</p>
<p><img src="/../assets/image-20210505001602936.png" alt="image-20210505001602936"></p>
<h2 id="React拓展"><a href="#React拓展" class="headerlink" title="React拓展"></a>React拓展</h2><h2 id="1-setState"><a href="#1-setState" class="headerlink" title="1. setState"></a>1. setState</h2><h3 id="setState更新状态的2种写法"><a href="#setState更新状态的2种写法" class="headerlink" title="setState更新状态的2种写法"></a>setState更新状态的2种写法</h3><p>setState这个动作实际上是异步的（setState函数在js中同步执行，执行后react异步更新），所以有setState第二个参数，传入一个回调，异步更新后调用。</p>
<ul>
<li><p>setState(stateChange, [callback])——对象式的setState</p>
<ol>
<li>stateChange为状态改变对象(该对象可以体现出状态的更改)</li>
<li>callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用</li>
</ol>
</li>
<li><p>setState(updater, [callback])——函数式的setState</p>
<ol>
<li>updater为返回stateChange对象的函数。</li>
<li>updater可以接收到state和props。</li>
<li>callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数式的setState</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>( <span class="function"><span class="params">state</span> =&gt;</span> ( &#123; <span class="attr">count</span>: state.<span class="property">count</span>+<span class="number">1</span> &#125; ) )</span><br></pre></td></tr></table></figure>



<hr/>



<h2 id="2-lazyLoad"><a href="#2-lazyLoad" class="headerlink" title="2. lazyLoad"></a>2. lazyLoad</h2><h3 id="路由组件的lazyLoad"><a href="#路由组件的lazyLoad" class="headerlink" title="路由组件的lazyLoad"></a>路由组件的lazyLoad</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.通过React的lazy函数配合import()函数动态加载路由组件 ===&gt; 路由组件代码会被分开打包</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Login</span> = <span class="title function_">lazy</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;@/pages/Login&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通过&lt;Suspense&gt;指定在加载得到路由打包文件前显示一个自定义loading界面</span></span><br><span class="line">&lt;<span class="title class_">Suspense</span> fallback=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>loading.....<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125;&gt;</span><br><span class="line">       <span class="language-xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/xxx&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Xxxx&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/login&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line">   &lt;/<span class="title class_">Suspense</span>&gt;</span><br></pre></td></tr></table></figure>



<hr/>



<h2 id="3-Hooks"><a href="#3-Hooks" class="headerlink" title="3. Hooks"></a>3. Hooks</h2><h4 id="1-React-Hook-Hooks是什么"><a href="#1-React-Hook-Hooks是什么" class="headerlink" title="1. React Hook&#x2F;Hooks是什么?"></a>1. React Hook&#x2F;Hooks是什么?</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). Hook是React 16.8.0版本增加的新特性/新语法</span><br><span class="line">(2). 可以让你在函数组件中使用 state 以及其他的 React 特性</span><br></pre></td></tr></table></figure>

<h4 id="2-三个常用的Hook"><a href="#2-三个常用的Hook" class="headerlink" title="2. 三个常用的Hook"></a>2. 三个常用的Hook</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). State Hook: React.useState()</span><br><span class="line">(2). Effect Hook: React.useEffect()</span><br><span class="line">(3). Ref Hook: React.useRef()</span><br></pre></td></tr></table></figure>

<h4 id="3-State-Hook"><a href="#3-State-Hook" class="headerlink" title="3. State Hook"></a>3. State Hook</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作</span><br><span class="line">(2). 语法: const [xxx, setXxx] = React.useState(initValue)  </span><br><span class="line">(3). useState()说明:</span><br><span class="line">        参数: 第一次初始化指定的值在内部作缓存</span><br><span class="line">        返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数</span><br><span class="line">(4). setXxx()2种写法:</span><br><span class="line">        setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值</span><br><span class="line">        setXxx(value =&gt; newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值</span><br></pre></td></tr></table></figure>

<h4 id="4-Effect-Hook"><a href="#4-Effect-Hook" class="headerlink" title="4. Effect Hook"></a>4. Effect Hook</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)</span><br><span class="line">(2). React中的副作用操作:</span><br><span class="line">        发ajax请求数据获取</span><br><span class="line">        设置订阅 / 启动定时器</span><br><span class="line">        手动更改真实DOM</span><br><span class="line">(3). 语法和说明: </span><br><span class="line">        useEffect(() =&gt; &#123; </span><br><span class="line">          // 在此可以执行任何带副作用操作</span><br><span class="line">          return () =&gt; &#123; // 在组件卸载前执行</span><br><span class="line">            // 在此做一些收尾工作, 比如清除定时器/取消订阅等</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行</span><br><span class="line">    </span><br><span class="line">(4). 可以把 useEffect Hook 看做如下三个函数的组合</span><br><span class="line">        componentDidMount()</span><br><span class="line">        componentDidUpdate()</span><br><span class="line">    	componentWillUnmount() </span><br></pre></td></tr></table></figure>

<h4 id="5-Ref-Hook"><a href="#5-Ref-Hook" class="headerlink" title="5. Ref Hook"></a>5. Ref Hook</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据</span><br><span class="line">(2). 语法: const refContainer = useRef()</span><br><span class="line">(3). 作用:保存标签对象,功能与React.createRef()一样</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="4-Fragment"><a href="#4-Fragment" class="headerlink" title="4. Fragment"></a>4. Fragment</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>&lt;Fragment&gt;&lt;Fragment&gt;
&lt;&gt;&lt;/&gt;
</code></pre>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><blockquote>
<p>可以不用必须有一个真实的DOM根标签了</p>
</blockquote>
<hr/>

<h2 id="5-Context"><a href="#5-Context" class="headerlink" title="5. Context"></a>5. Context</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><blockquote>
<p>一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信</p>
</blockquote>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) 创建<span class="title class_">Context</span>容器对象：</span><br><span class="line">	<span class="keyword">const</span> <span class="title class_">XxxContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>()  </span><br><span class="line">	</span><br><span class="line"><span class="number">2</span>) 渲染子组时，外面包裹xxxContext.<span class="property">Provider</span>, 通过value属性给后代组件传递数据：</span><br><span class="line">	&lt;xxxContext.<span class="property">Provider</span> value=&#123;数据&#125;&gt;</span><br><span class="line">		子组件</span><br><span class="line">    &lt;/xxxContext.<span class="property">Provider</span>&gt;</span><br><span class="line">    </span><br><span class="line"><span class="number">3</span>) 后代组件读取数据：</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种方式:仅适用于类组件 </span></span><br><span class="line">	  <span class="keyword">static</span> contextType = xxxContext  <span class="comment">// 声明接收context</span></span><br><span class="line">	  <span class="variable language_">this</span>.<span class="property">context</span> <span class="comment">// 读取context中的value数据</span></span><br><span class="line">	  </span><br><span class="line">	<span class="comment">//第二种方式: 函数组件与类组件都可以</span></span><br><span class="line">	  &lt;xxxContext.<span class="property">Consumer</span>&gt;</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="function"><span class="params">value</span> =&gt;</span> ( <span class="comment">// value就是context中的value数据</span></span><br><span class="line">	        要显示的内容</span><br><span class="line">	      )</span><br><span class="line">	    &#125;</span><br><span class="line">	  &lt;/xxxContext.<span class="property">Consumer</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><pre><code>在应用开发中一般不用context, 一般都用它的封装react插件
</code></pre>
<hr/>


<h2 id="6-组件优化"><a href="#6-组件优化" class="headerlink" title="6. 组件优化"></a>6. 组件优化</h2><h3 id="Component的2个问题"><a href="#Component的2个问题" class="headerlink" title="Component的2个问题"></a>Component的2个问题</h3><blockquote>
<ol>
<li><p>只要执行setState(),即使不改变状态数据, 组件也会重新render() &#x3D;&#x3D;&gt; 效率低</p>
</li>
<li><p>只当前组件重新render(), 就会自动重新render子组件，纵使子组件没有用到父组件的任何数据 &#x3D;&#x3D;&gt; 效率低</p>
</li>
</ol>
</blockquote>
<h3 id="效率高的做法"><a href="#效率高的做法" class="headerlink" title="效率高的做法"></a>效率高的做法</h3><blockquote>
<p> 只有当组件的state或props数据发生改变时才重新render()</p>
</blockquote>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><blockquote>
<p> Component中的shouldComponentUpdate()总是返回true</p>
</blockquote>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><pre><code>办法1: 
    重写shouldComponentUpdate()方法
    比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false
办法2:  
    使用PureComponent
    PureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true
    注意: 
        只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false  
        不要直接修改state数据, 而是要产生新数据
项目中一般使用PureComponent来优化
</code></pre>
<hr/>



<h2 id="7-render-props"><a href="#7-render-props" class="headerlink" title="7. render props"></a>7. render props</h2><h3 id="如何向组件内部动态传入带内容的结构-标签"><a href="#如何向组件内部动态传入带内容的结构-标签" class="headerlink" title="如何向组件内部动态传入带内容的结构(标签)?"></a>如何向组件内部动态传入带内容的结构(标签)?</h3><pre><code>React中:
    使用children props: 通过组件标签体传入结构
    使用render props: 通过组件标签属性传入结构,而且可以携带数据，一般用render函数属性
</code></pre>
<h3 id="children-props"><a href="#children-props" class="headerlink" title="children props"></a>children props</h3><pre><code>&lt;A&gt;
  &lt;B&gt;xxxx&lt;/B&gt;
&lt;/A&gt;
&#123;this.props.children&#125;
问题: 如果B组件需要A组件内的数据, ==&gt; 做不到 
</code></pre>
<h3 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h3><pre><code>&lt;A render=&#123;(data) =&gt; &lt;C data=&#123;data&#125;&gt;&lt;/C&gt;&#125;&gt;&lt;/A&gt;
A组件: &#123;this.props.render(内部state数据)&#125;
C组件: 读取A组件传入的数据显示 &#123;this.props.data&#125; 
</code></pre>
<hr/>

<h2 id="8-错误边界"><a href="#8-错误边界" class="headerlink" title="8. 错误边界"></a>8. 错误边界</h2><h4 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h4><p>错误边界(Error boundary)：用来捕获后代组件错误，渲染出备用页面</p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误</p>
<h5 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h5><p>getDerivedStateFromError配合componentDidCatch</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生命周期函数，一旦后台组件报错，就会触发</span></span><br><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">    <span class="comment">// 在render之前触发</span></span><br><span class="line">    <span class="comment">// 返回新的state</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">hasError</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123;</span><br><span class="line">    <span class="comment">// 统计页面的错误。发送请求发送到后台去</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr/>



<h2 id="9-组件通信方式总结"><a href="#9-组件通信方式总结" class="headerlink" title="9. 组件通信方式总结"></a>9. 组件通信方式总结</h2><h4 id="组件间的关系："><a href="#组件间的关系：" class="headerlink" title="组件间的关系："></a>组件间的关系：</h4><ul>
<li>父子组件</li>
<li>兄弟组件（非嵌套组件）</li>
<li>祖孙组件（跨级组件）</li>
</ul>
<h4 id="几种通信方式："><a href="#几种通信方式：" class="headerlink" title="几种通信方式："></a>几种通信方式：</h4><pre><code>    1.props：		(1).children props		(2).render props	2.消息订阅-发布：		pubs-sub、event等等	3.集中式管理：		redux、dva等等	4.conText:		生产者-消费者模式
</code></pre>
<h4 id="比较好的搭配方式："><a href="#比较好的搭配方式：" class="headerlink" title="比较好的搭配方式："></a>比较好的搭配方式：</h4><pre><code>    父子组件：props
    兄弟组件：消息订阅-发布、集中式管理
    祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(开发用的少，封装插件用的多)
</code></pre>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React生态</title>
    <url>/2021/09/30/React%E7%94%9F%E6%80%81/</url>
    <content><![CDATA[<h3 id="React-DevTools"><a href="#React-DevTools" class="headerlink" title="React DevTools"></a>React DevTools</h3><h5 id="General-设置"><a href="#General-设置" class="headerlink" title="General 设置"></a>General 设置</h5><img src="../assets/image-20220222024702149.png" alt="image-20220222024702149" style="zoom:33%;" />

<p>General 面板中最重要的功能就是 **”Highlight updates when components render”**。勾选上之后，可以查看 React 重绘时，页面哪些部分有更新。在遇到性能问题时，可以快速帮助决策在哪部分不需要重绘的组件部分添加 React.memo 阻止重绘。</p>
<h5 id="Debugging-设置"><a href="#Debugging-设置" class="headerlink" title="Debugging 设置"></a>Debugging 设置</h5><img src="..\assets\image-20220222024832097.png" alt="image-20220222024832097" style="zoom:33%;" />

<p><strong>“Append components stacks to console warnings and errors.”</strong></p>
<p>可以帮助我们定位 React 报错信息来自哪个组件</p>
<span id="more"></span>


<h5 id="Components-设置"><a href="#Components-设置" class="headerlink" title="Components 设置"></a>Components 设置</h5><img src="..\assets\image-20220222024936104.png" alt="image-20220222024936104" style="zoom:33%;" />

<p><strong>“Hide components where…”</strong></p>
<p>此项在过滤组件树时有用。比如，大多数应用可能会在顶层有很多 Context.Provider，就可以过滤 Context 类型、不显示。当我们只关心业务逻辑层的组件时，可以过滤掉 DOM 组件，减少树的节点</p>
<h5 id="Profiler-设置"><a href="#Profiler-设置" class="headerlink" title="Profiler 设置"></a>Profiler 设置</h5><img src="..\assets\image-20220222025024293.png" alt="image-20220222025024293" style="zoom:33%;" />

<p><strong>“Record why each component rendered while profiling”</strong></p>
<img src="..\assets\image-20220222025054509.png" alt="image-20220222025054509" style="zoom:33%;" />

<p>勾选之后会在渲染火焰图的 hover 面板中看到 **”Why did this render”**。</p>
<h5 id="现在有哪些-render-原因呢？"><a href="#现在有哪些-render-原因呢？" class="headerlink" title="现在有哪些 render 原因呢？"></a>现在有哪些 render 原因呢？</h5><ul>
<li><p><strong>Props changed</strong></p>
<p>​     顾名思义，传入组件的 props 变更</p>
</li>
<li><p><strong>The parent component rendered</strong></p>
<p>​	父组件渲染导致的子组件渲染。一般要做性能优化都是找这类重绘原因的组件。但是要注意，如果组件中有用到 useContext，Provider 的 value 变更导致的重绘也是被标记为 The parent component rendered，需要注意</p>
</li>
<li><p><strong>Hooks changed</strong></p>
<p>​	Hook 状态变更导致的重绘，一般就是指 useState 返回的更新函数被调用了</p>
</li>
<li><p><strong>State changed</strong></p>
<p>​	这个只会在 class component 中有，大家忽略</p>
</li>
<li><p><strong>“Hide commits below xx (ms)”</strong></p>
<p>​	设置一个更新耗时的阈值，低于该阈值的渲染不显示。用来快速过滤哪些渲染有性能问题</p>
</li>
</ul>
<h5 id="React-组件检视器"><a href="#React-组件检视器" class="headerlink" title="React 组件检视器"></a>React 组件检视器</h5><p>用法和 DevTools 的元素面板类似，可以直接在页面上定位到元素对应的 React Component。并且可以实时查看当前组件内部的 hooks 状态，返回的组件树</p>
<img src="..\assets\image-20220222025129591.png" alt="image-20220222025129591" style="zoom:33%;" />

<p>右上角的四个图标</p>
<img src="..\assets\image-20220222025154916.png" alt="image-20220222025154916" style="zoom:33%;" />

<p>分别作用如下：</p>
<ul>
<li>模拟 ReactLazy 懒加载组件 Suspense 状态</li>
<li>定位组件所渲染的 DOM 节点</li>
<li>在 Console 中打印 Component 内部状态</li>
<li>跳转到组件所在源文件（配合 sourcemap）</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React的设计和实现</title>
    <url>/2021/09/29/React%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="本篇笔记的目的：站在更高的角度看待React"><a href="#本篇笔记的目的：站在更高的角度看待React" class="headerlink" title="本篇笔记的目的：站在更高的角度看待React"></a>本篇笔记的目的：站在更高的角度看待React</h4><h4 id="React的设计思路"><a href="#React的设计思路" class="headerlink" title="React的设计思路"></a>React的设计思路</h4><ul>
<li><p>解决UI编程的痛点</p>
<ol>
<li><p>状态更新，UI不会自动更新，需要手动调dom api进行更新</p>
<ol start="2">
<li>欠缺基本代码的封装和隔离，代码层面没有组件化</li>
<li>UI之间数据依赖，需要手动维护，如果依赖链路过长，会有 callback hell的问题</li>
</ol>
</li>
</ol>
</li>
<li><p>响应式编程</p>
</li>
</ul>
<p><img src="/../assets/image-20220210203412954.png" alt="image-20220210203412954"></p>
<ul>
<li><p>期望能</p>
<pre><code>1. 状态更新，UI自动更新
2. 前端代码组件化，可复用，可封装
3. 状态之间的依赖关系，只需要声明即可
</code></pre>
</li>
<li><p>组件化</p>
<pre><code>1. 组件是组件的组合/原子组件
2. 组件内拥有状态，外部不可见
3. 父组件可将状态传入组件内部
</code></pre>
</li>
<li><p>状态归属问题</p>
<pre><code>1. react是单向数据流，只能父组件将状态传递给子组件（但可以将改变父组件状态的方法传递给子组件实现父子组件通信）
2. 如何解决不合理的状态上升问题？
3. 组件状态改变后，如何更新dom
</code></pre>
</li>
</ul>
<span id="more"></span>


<h4 id="React的实现"><a href="#React的实现" class="headerlink" title="React的实现"></a>React的实现</h4><ul>
<li>DIff算法</li>
</ul>
<img src="../assets/image-20220210212319207.png" alt="image-20220210212319207" style="zoom:40%;" />



<h3 id="React解决状态管理问题"><a href="#React解决状态管理问题" class="headerlink" title="React解决状态管理问题"></a>React解决状态管理问题</h3><p>先说结论：使用状态管理库</p>
<ul>
<li><p>状态管理库核心思想：将状态抽离到ui外部进行统一管理。</p>
</li>
<li><p>将状态抽离到ui外部的问题：降低了组件复用性，组件跟外部状态强耦合</p>
</li>
</ul>
<p><strong>何时使用状态管理库？</strong></p>
<p><strong>判断一个状态是不是只属于组件本身，如若是则不需要状态管理库</strong></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React组件性能优化</title>
    <url>/2021/10/14/React%E7%BB%84%E4%BB%B6%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="React-性能优化思路"><a href="#React-性能优化思路" class="headerlink" title="React 性能优化思路"></a>React 性能优化思路</h3><p>我觉得React 性能优化的理念的主要方向就是这两个：</p>
<ol>
<li><strong>减少重新 render 的次数。因为在 React 里最重(花时间最长)的一块就是 reconciliation(简单的可以理解为 diff)，如果不 render，就不会 reconciliation。</strong></li>
<li><strong>减少计算的量。主要是减少重复计算，对于函数式组件来说，每次 render 都会重新从头开始执行函数调用。</strong></li>
</ol>
<p>在使用类组件的时候，使用的 React 优化 API 主要是：<code>shouldComponentUpdate</code>和  <code>PureComponent</code>，这两个 API 所提供的解决思路都是为了<strong>减少重新 render 的次数</strong>，主要是减少父组件更新而子组件也更新的情况。</p>
<p>但是在函数式组件里面没有声明周期也没有类，那如何来做性能优化呢？</p>
<p><strong>先分个类，组件什么时候会重新执行？</strong></p>
<ol>
<li><strong>组件自己的状态改变</strong></li>
<li><strong>父组件重新渲染，导致子组件重新渲染，但是父组件的 props 没有改变</strong></li>
<li><strong>父组件重新渲染，导致子组件重新渲染，但是父组件传递的 props 改变</strong></li>
</ol>
<p>针对第二点，在FC中，可以通过memo减少rerender</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params">props</span>) &#123;</span><br><span class="line">   <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponent</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">Component</span>);</span><br></pre></td></tr></table></figure>

<p>通过 <code>React.memo</code> 包裹的组件在 props 不变的情况下，这个被包裹的组件是不会重新渲染的(相当于PureComonent)</p>
<p>默认情况下其只会对 props 的复杂对象做浅层对比(浅层对比就是只会对比前后两次 props 对象引用是否相同，不会对比对象里面的内容是否相同)，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">areEqual</span>(<span class="params">prevProps, nextProps</span>) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果把 nextProps 传入 render 方法的返回结果与</span></span><br><span class="line"><span class="comment">  将 prevProps 传入 render 方法的返回结果一致则返回 true，</span></span><br><span class="line"><span class="comment">  否则返回 false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">MyComponent</span>, areEqual);</span><br></pre></td></tr></table></figure>

<h3 id="组件性能优化"><a href="#组件性能优化" class="headerlink" title="组件性能优化"></a>组件性能优化</h3><p>React 组件是一个树形结构，且每个节点都是懒计算的（类似于 Thunk 的概念）。当一个节点不需要重新计算（重绘）时，他的子树都不会计算（重绘）。<strong>所以我们做性能优化的目标，就是在尽量离根节点近的位置，拦截不必要的节点重算，从而减少重绘的计算量。</strong></p>
<h5 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h5><p>阻止节点重绘主要通过 React.memo 方法生成特殊的组件节点。它接受两个传参：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">Component</span>, areEqual);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Component：组件</p>
</li>
<li><p>areEqual：比较函数<br>比较函数的入参有两个，arg0 为 前一次渲染的 props, arg1 为本次渲染的 props。如果返回 true，则该节点本次渲染将被标记为无需重新计算，从而使其所有子节点、孙子节点都无需计算。<br>areEqual 如果不传，默认使用</p>
</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">prevProps</span>, nextProps) =&gt; shallowEqual(<span class="name">prevProps</span>, nextProps)</span><br></pre></td></tr></table></figure>

<p>做为比较函数。</p>
<h5 id="如何定位优化点"><a href="#如何定位优化点" class="headerlink" title="如何定位优化点"></a>如何定位优化点</h5><p>使用前一章节提到 React DevTools 中的 Profiling 功能，record 发生卡顿的操作，从耗时长的组件逐个查看，找到那些跟此次操作无关的上层渲染节点，尝试使用 React.memo 包裹这些组件。</p>
<h5 id="不要为了优化而优化"><a href="#不要为了优化而优化" class="headerlink" title="不要为了优化而优化"></a>不要为了优化而优化</h5><p>在没有性能问题前，不用去纠结是否要用 Profiling、React.memo、useMemo、useCallback 去优化性能，这些不一定能带来性能提升，反而肯定会带来首屏的性能下降。大多数情况下，React 现有算法以能满足性能需求。</p>
<h5 id="对于一个组件，有三样东西会让她重绘"><a href="#对于一个组件，有三样东西会让她重绘" class="headerlink" title="对于一个组件，有三样东西会让她重绘"></a>对于一个组件，有三样东西会让她重绘</h5><ol>
<li>State 变更</li>
<li>依赖的 context 变更</li>
<li>父组件重绘</li>
</ol>
<p>所以用 React.memo 包裹之后，并不是说性能就会有多大的提高。如果组件中依赖的 context 中，有一部分并不是此组件需要的数据，但会经常变更，也会导致组件经常重绘。这时候我们可以增加一层组件，把依赖 context 中的数据，通过增加的一层父组件取出来，然后通过 props 传给真正渲染的组件，把 React.memo 加在真正渲染的组件上，来达到屏蔽 context 变更引起的重绘问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useMemo, useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">SomeContext</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./SomeContext&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">PickContextData</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ctx = <span class="title function_">useContext</span>(<span class="title class_">SomeContext</span>);</span><br><span class="line">  <span class="keyword">const</span> someDataFromContext = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ctx.<span class="property">data</span>;</span><br><span class="line">  &#125;, [ctx.<span class="property">data</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">RenderComponent</span> <span class="attr">data</span>=<span class="string">&#123;someDataFromContext&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">RenderComponent</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 略</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>更通用点，可以封装出 react-redux 的 connect 函数，传入 selector 来取所需的 Context 数据。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Hooks</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React组件通信</title>
    <url>/2021/10/07/React%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><h5 id="爷孙组件通信"><a href="#爷孙组件通信" class="headerlink" title="爷孙组件通信"></a>爷孙组件通信</h5><p>爷孙组件通信主要有 3 种方式：</p>
<ol>
<li>将孙子组件的 props 封装在一个固定字段中</li>
<li>通过 children 透传</li>
<li>通过 context 传递</li>
</ol>
<p>假设有个三层组件，爷爷分别给儿子和孙子发红包</p>
<p>先看青铜解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Grandpa</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [someMoneyForMe] = <span class="title function_">useState</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">const</span> [someMoneyForDaddy] = <span class="title function_">useState</span>(<span class="number">101</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Daddy</span> <span class="attr">money</span>=<span class="string">&#123;someMoneyForDaddy&#125;</span> <span class="attr">moneyForSon</span>=<span class="string">&#123;someMoneyForMe&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Daddy</span>(<span class="params">props: &#123; money: number; moneyForSon: number &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; money, moneyForSon &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;daddy&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>This is Daddy, received $&#123;money&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Me</span> <span class="attr">money</span>=<span class="string">&#123;moneyForSon&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Me</span>(<span class="params">props: &#123; money: number &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; money &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>This is Me, received $&#123;money&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Daddy 组件会透传爷爷给孙子的组件给 Me。这种方案的缺点很明显，以后爷爷要给 Daddy 和 Me 发糖果的时候，Daddy 还得加字段。</p>
<p><strong>将孙子组件的 props 封装在一个固定字段中</strong></p>
<p>按照 1 的方案，我们可以固定给 Daddy 添加一个 sonProps 的字段，然后将 Grandpa 需要传给孙子的状态全部通过 sonProps 传递</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Grandpa</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [someMoneyForMe] = <span class="title function_">useState</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">const</span> [someMoneyForDaddy] = <span class="title function_">useState</span>(<span class="number">101</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Daddy</span> <span class="attr">money</span>=<span class="string">&#123;someMoneyForDaddy&#125;</span> <span class="attr">sonProps</span>=<span class="string">&#123;&#123;money:</span> <span class="attr">someMoneyForMe</span>&#125;&#125; /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Daddy</span>(<span class="params">props: &#123; money: number; sonProps: Parameters&lt;<span class="keyword">typeof</span> Me&gt;[<span class="number">0</span>]; &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; money, sonProps &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;daddy&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>This is Daddy, received $&#123;money&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Me</span> &#123;<span class="attr">...sonProps</span>&#125;/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Me</span>(<span class="params">props: &#123; money: number &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; money &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>This is Me, received $&#123;money&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样以后要给 Me 加字段，就不用改 Daddy 了。<strong>但要测试 Daddy 时还得 mock Me 组件的数据，Daddy 和 Son 耦合。</strong></p>
<p><strong>通过 children 透传</strong></p>
<p>children 类似于 vue 中的 slot，可以完成一些嵌套组件通信的功能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Grandpa</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [someMoneyForMe] = <span class="title function_">useState</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">const</span> [someMoneyForDaddy] = <span class="title function_">useState</span>(<span class="number">101</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Daddy</span> <span class="attr">money</span>=<span class="string">&#123;someMoneyForDaddy&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Me</span> <span class="attr">money</span>=<span class="string">&#123;someMoneyForMe&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Daddy</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Daddy</span>(<span class="params">props: &#123; money: number; children?: React.ChildNode &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; money, children &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;daddy&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>This is Daddy, received $&#123;money&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Me</span>(<span class="params">props: &#123; money: number &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; money &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>This is Me, received $&#123;money&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 Daddy 的嵌套部分用 children 替代后，解耦了子组件和孙子组件的依赖关系，Daddy 组件更加独立。</p>
<p>作为替代，也可以传递一个组件实例：</p>
<p><code><Daddy money=&#123;someMoneyForDaddy&#125; me=&#123;<Me money=&#123;someMoneyForMe&#125; /> </code></p>
<p><strong>三种方案的决策</strong></p>
<ol>
<li>第一种方案一般用于固定结构和跨组件有互相依赖的场景，多见于 UI 框架中的复合组件与原子组件的设计中</li>
<li>第二种常用在嵌套层级不深的业务代码中，比如表单场景。<strong>优点是顶层 Grandpa 的业务收敛度很高，一眼能看清 UI 结构及状态绑定关系，相当于拍平了 React 组件树</strong></li>
<li>第三种比较通用，适合复杂嵌套透传场景。缺点是范式代码较多，且会造成 react dev tools 层级过多；Context 无法在父组件看出依赖关系，必须到子组件文件中才能知道数据来源</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Hooks</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack</title>
    <url>/2022/04/14/Webpack/</url>
    <content><![CDATA[<h3 id="Webpack-是什么"><a href="#Webpack-是什么" class="headerlink" title="Webpack 是什么"></a>Webpack 是什么</h3><p>webpack 是一种<strong>前端资源构建工具</strong>，一个静态模块打包器(module bundler)。</p>
<p>在webpack 看来, 前端的所有资源文件(js&#x2F;json&#x2F;css&#x2F;img&#x2F;less&#x2F;…)都会作为模块处理。<br>它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。</p>
<h3 id="Webpack-五个核心概念"><a href="#Webpack-五个核心概念" class="headerlink" title="Webpack 五个核心概念"></a>Webpack 五个核心概念</h3><h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><p>入口(Entry)：指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图。</p>
<h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>输出(Output)：指示 webpack 打包后的资源 bundles 输出到哪里去，以及如何命名。</p>
<h4 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h4><p>Loader：让 webpack 能够去处理那些非 JS 的文件，比如样式文件、图片文件(webpack 自身只理解<br>JS)</p>
<h4 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h4><p>插件(Plugins)：可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，<br>一直到重新定义环境中的变量等。</p>
<span id="more"></span>

<h4 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h4><p>模式(Mode)：指示 webpack 使用相应模式的配置。</p>
<ol>
<li><p>development:  </p>
<p> 会将 DefinePlugin 中 <code>process.env.NODE_ENV</code> 的值设置为 development。</p>
<p>启用 </p>
<figure class="highlight plaintext"><figcaption><span>和 ```NamedModulesPlugin```。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   特点： 能让代码本地调试运行的环境。</span><br><span class="line"></span><br><span class="line">2. production</span><br><span class="line"></span><br><span class="line">   会将 DefinePlugin 中 ```process.env.NODE_ENV``` 的值设置为 production。</span><br><span class="line"></span><br><span class="line">   启用 </span><br><span class="line"></span><br><span class="line">   ```FlagDependencyUsagePlugin,```</span><br><span class="line"></span><br><span class="line">   ``` FlagIncludedChunksPlugin,``` </span><br><span class="line"></span><br><span class="line">   ``` ModuleConcatenationPlugin, ``` </span><br><span class="line"></span><br><span class="line">   ```NoEmitOnErrorsPlugin, ```</span><br><span class="line"></span><br><span class="line">    ```OccurrenceOrderPlugin, ```</span><br><span class="line"></span><br><span class="line">   ```SideEffectsFlagPlugin 和 TerserPlugin```。</span><br><span class="line"></span><br><span class="line">   特点： 能让代码优化上线运行的环境。</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">### 编译打包应用</span><br><span class="line"></span><br><span class="line">创建 src 下的 js 等文件后，不需要配置 webpack.config.js 文件，在命令行就可以编译打包。</span><br><span class="line"></span><br><span class="line">指令：</span><br><span class="line"></span><br><span class="line">- 开发环境：</span><br><span class="line">```shell</span><br><span class="line">webpack ./src/index.js -o ./build/built.js --mode=development</span><br></pre></td></tr></table></figure></li>
</ol>
<p>  webpack会以 .&#x2F;src&#x2F;index.js 为入口文件开始打包，打包后输出到 .&#x2F;build&#x2F;built.js 整体打包环境，是开发环境</p>
<ul>
<li>生产环境：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">webpack ./src/index.js -o ./build/built.js --mode=production</span><br></pre></td></tr></table></figure>
webpack会以 .&#x2F;src&#x2F;index.js 为入口文件开始打包，打包后输出到 .&#x2F;build&#x2F;built.js 整体打包环境，是生产环境</li>
</ul>
<p>结论：</p>
<ol>
<li>webpack 本身能处理 js&#x2F;json 资源，不能处理 css&#x2F;img 等其他资源</li>
<li>生产环境和开发环境将 ES6 模块化编译成浏览器能识别的模块化，但是不能处理 ES6 的基本语法转化为 ES5（需要借助 loader）</li>
<li>生产环境比开发环境多一个压缩 js 代码</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// resolve用来拼接绝对路径的方法</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// webpack配置</span></span><br><span class="line">  <span class="comment">// 入口起点</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;built.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 输出路径</span></span><br><span class="line">    <span class="comment">// __dirname nodejs的变量，代表当前文件的目录绝对路径</span></span><br><span class="line">    <span class="attr">path</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// loader的配置</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 详细loader配置</span></span><br><span class="line">      <span class="comment">// 不同文件必须配置不同loader处理</span></span><br><span class="line">      &#123; </span><br><span class="line">        <span class="comment">// 匹配哪些文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// 使用哪些loader进行处理</span></span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="comment">// use数组中loader执行顺序：从右到左，从下到上 依次执行</span></span><br><span class="line">          <span class="comment">// 创建style标签，将js中的样式资源插入进行，添加到head中生效</span></span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// 将css文件变成commonjs模块加载js中，里面内容是样式字符串</span></span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// 将less文件编译成css文件</span></span><br><span class="line">          <span class="comment">// 需要下载 less-loader和less</span></span><br><span class="line">           <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// plugins的配置</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 详细plugins的配置</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 开发模式</span></span><br><span class="line">  <span class="comment">// mode: &#x27;production&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>打包工具</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>打包工具</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript入门</title>
    <url>/2021/10/14/Typescript%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="TypeScript简介"><a href="#TypeScript简介" class="headerlink" title="TypeScript简介"></a>TypeScript简介</h3><ol>
<li>TypeScript是JavaScript的超集。</li>
<li>它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。</li>
<li>TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。</li>
<li>TS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。</li>
<li>相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。</li>
</ol>
<h3 id="TypeScript-开发环境搭建"><a href="#TypeScript-开发环境搭建" class="headerlink" title="TypeScript 开发环境搭建"></a>TypeScript 开发环境搭建</h3><ol>
<li><p>下载Node.js</p>
<ul>
<li>64位：<a href="https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi">https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi</a></li>
<li>32位：<a href="https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi">https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi</a></li>
</ul>
</li>
<li><p>安装Node.js</p>
</li>
<li><p>使用npm全局安装typescript</p>
<ul>
<li>进入命令行</li>
<li>输入：npm i -g typescript</li>
</ul>
</li>
<li><p>创建一个ts文件</p>
</li>
<li><p>使用tsc对ts文件进行编译</p>
<ul>
<li><p>进入命令行</p>
</li>
<li><p>进入ts文件所在目录</p>
</li>
<li><p>执行命令：tsc xxx.ts</p>
</li>
</ul>
</li>
</ol>
 <span id="more"></span>    

<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><h5 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h5><ul>
<li><p>类型声明是TS非常重要的一个特点</p>
</li>
<li><p>通过类型声明可以指定TS中变量（参数、形参）的类型</p>
</li>
<li><p>指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错</p>
</li>
<li><p>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值</p>
</li>
<li><p>语法：</p>
<ul>
<li><pre><code class="typescript">let 变量: 类型;

let 变量: 类型 = 值;

function fn(参数: 类型, 参数: 类型): 类型&#123;
    ...
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 自动类型判断</span><br><span class="line"></span><br><span class="line">- TS拥有自动的类型判断机制</span><br><span class="line">- 当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型</span><br><span class="line">- 所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 类型</span><br><span class="line"></span><br><span class="line">|  类型   |       例子        |              描述              |</span><br><span class="line">| :-----: | :---------------: | :----------------------------: |</span><br><span class="line">| number  |    1, -33, 2.5    |            任意数字            |</span><br><span class="line">| string  | &#x27;hi&#x27;, &quot;hi&quot;, `hi`  |           任意字符串           |</span><br><span class="line">| boolean |    true、false    |       布尔值true或false        |</span><br><span class="line">| 字面量  |      其本身       |  限制变量的值就是该字面量的值  |</span><br><span class="line">|   any   |         *         |            任意类型            |</span><br><span class="line">| unknown |         *         |         类型安全的any          |</span><br><span class="line">|  void   | 空值（undefined） |     没有值（或undefined）      |</span><br><span class="line">|  never  |      没有值       |          不能是任何值          |</span><br><span class="line">| object  |  &#123;name:&#x27;孙悟空&#x27;&#125;  |          任意的JS对象          |</span><br><span class="line">|  array  |      [1,2,3]      |           任意JS数组           |</span><br><span class="line">|  tuple  |       [4,5]       | 元素，TS新增类型，固定长度数组 |</span><br><span class="line">|  enum   |    enum&#123;A, B&#125;     |       枚举，TS中新增类型       |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### **enum 枚举类型**</span><br><span class="line"></span><br><span class="line">- ```typescript</span><br><span class="line">  enum Color &#123;</span><br><span class="line">    Red = 0,</span><br><span class="line">    Green,</span><br><span class="line">    Blue,</span><br><span class="line">  &#125;</span><br><span class="line">  // 使用</span><br><span class="line">  const red = Color.Red;</span><br><span class="line">  const green = Color.Green;</span><br><span class="line">  </span><br><span class="line">  // 编译成js后，枚举类型实际上是一个双向键值对对象（可以通过键获取值也可以通过值获取键）</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  var Color;</span><br><span class="line">  (function (Color) &#123;</span><br><span class="line">      Color[Color[&quot;Red&quot;] = 0] = &quot;Red&quot;;</span><br><span class="line">      Color[Color[&quot;Green&quot;] = 1] = &quot;Green&quot;;</span><br><span class="line">      Color[Color[&quot;Blue&quot;] = 2] = &quot;Blue&quot;;</span><br><span class="line">  &#125;)(Color || (Color = &#123;&#125;));</span><br><span class="line">  // 使用</span><br><span class="line">  const red = Color.Red;</span><br><span class="line">  const green = Color.Green;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>定义常量枚举（只能通过键获取值）</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> red = <span class="title class_">Color</span>.<span class="property">Red</span>;</span><br><span class="line"><span class="keyword">const</span> green = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译成js</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> red = <span class="number">0</span> <span class="comment">/* Red */</span>;</span><br><span class="line"><span class="keyword">const</span> green = <span class="number">1</span> <span class="comment">/* Green */</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="定义函数类型"><a href="#定义函数类型" class="headerlink" title="定义函数类型"></a>定义函数类型</h5><ul>
<li><pre><code class="typescript">// 箭头函数可以以这种形式定义
const add: (a: number, b: number) =&gt; number = (a, b) =&gt; &#123;
    return a + b;
&#125;;

// 也可以这种形式
interface Iadd &#123;
    (x: number, y: number): number;
&#125;
const add: Iadd = (a, b) =&gt; &#123;
    return a + b;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 类型别名</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;..\Picture\image-20220225230844666.png&quot; alt=&quot;image-20220225230844666&quot; style=&quot;zoom:23%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 类型断言</span><br><span class="line"></span><br><span class="line">- 有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：</span><br><span class="line"></span><br><span class="line">  - 第一种</span><br><span class="line"></span><br><span class="line">    - ```typescript</span><br><span class="line">      let someValue: unknown = &quot;this is a string&quot;;</span><br><span class="line">      let strLength: number = (someValue as string).length;</span><br></pre></td></tr></table></figure>

- 第二种

  - ```typescript
    let someValue: unknown = &quot;this is a string&quot;;
    let strLength: number = (&lt;string&gt;someValue).length;
    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 类型保卫与类型守护</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;..\assets\image-20220225231806225.png&quot; alt=&quot;image-20220225231806225&quot; style=&quot;zoom:25%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;..\assets\image-20220225232035688.png&quot; alt=&quot;image-20220225232035688&quot; style=&quot;zoom:25%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;..\assets\image-20220225232336109.png&quot; alt=&quot;image-20220225232336109&quot; style=&quot;zoom:25%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">##### d.ts文件/declare</span><br><span class="line"></span><br><span class="line">+ 安装第三方模块（例如lodash）时</span><br><span class="line"></span><br><span class="line">![image-20220225193949940](..\assets\image-20220225193949940.png)</span><br><span class="line"></span><br><span class="line">原因是lodash是使用js编写的，没有类型声明，如下，camelCase函数没有类型声明</span><br><span class="line"></span><br><span class="line">```typescript</span><br><span class="line">import &#123; camelCase &#125; from &#x27;lodash&#x27;;</span><br><span class="line">const res = camelCase(&#x27;hello guy&#x27;)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>这时候可以使用<strong>declare</strong>（其实就是一个成员在定义的时候没有声明，比如node装第三方模块，大部分都是js写的，这时候使用declare做一个单独的声明）对函数声明</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; camelCase &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">camelCase</span>(<span class="params"><span class="attr">input</span>: <span class="built_in">string</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="title function_">camelCase</span>(<span class="string">&#x27;hello guy&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>其他解决方案：</strong>安装d.ts文件（专门用来做类型声明的文件，应该为开发依赖）</p>
<h3 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h3><ul>
<li><p>自动编译文件</p>
<ul>
<li><p>编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。</p>
</li>
<li><p>示例：</p>
<ul>
<li>powershell<br>tsc xxx.ts -w</li>
</ul>
</li>
</ul>
</li>
<li><p>自动编译整个项目</p>
<ul>
<li><p>如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。</p>
</li>
<li><p>但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json</p>
</li>
<li><p>tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译</p>
</li>
<li><p>配置选项：</p>
<ul>
<li><p>include</p>
<ul>
<li><p>定义希望被编译文件所在的目录</p>
</li>
<li><p>默认值：[“**&#x2F;*“]</p>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="json">&quot;include&quot;:[&quot;src/**/*&quot;, &quot;tests/**/*&quot;]
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 上述示例中，所有src目录和tests目录下的文件都会被编译</span><br><span class="line"></span><br><span class="line">- exclude</span><br><span class="line"></span><br><span class="line">  - 定义需要排除在外的目录</span><br><span class="line"></span><br><span class="line">  - 默认值：[&quot;node_modules&quot;, &quot;bower_components&quot;, &quot;jspm_packages&quot;]</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;exclude&quot;: [&quot;./src/hello/**/*&quot;]</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>上述示例中，src下hello目录下的文件都不会被编译</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>extends</p>
<ul>
<li><p>定义被继承的配置文件</p>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="json">&quot;extends&quot;: &quot;./configs/base&quot;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息</span><br><span class="line"></span><br><span class="line">- files</span><br><span class="line"></span><br><span class="line">  - 指定被编译文件的列表，只有需要编译的文件少时才会用到</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;files&quot;: [</span><br><span class="line">          &quot;core.ts&quot;,</span><br><span class="line">          &quot;sys.ts&quot;,</span><br><span class="line">          &quot;types.ts&quot;,</span><br><span class="line">          &quot;scanner.ts&quot;,</span><br><span class="line">          &quot;parser.ts&quot;,</span><br><span class="line">          &quot;utilities.ts&quot;,</span><br><span class="line">          &quot;binder.ts&quot;,</span><br><span class="line">          &quot;checker.ts&quot;,</span><br><span class="line">          &quot;tsc.ts&quot;</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>列表中的文件都会被TS编译器所编译</p>
</li>
</ul>
</li>
<li><p>compilerOptions</p>
<ul>
<li><p>编译选项是配置文件中非常重要也比较复杂的配置选项</p>
</li>
<li><p>在compilerOptions中包含多个子选项，用来完成对编译的配置</p>
<ul>
<li><p>项目选项</p>
<ul>
<li><p>target</p>
<ul>
<li><p>设置ts代码编译的目标版本</p>
</li>
<li><p>可选值：</p>
<ul>
<li>ES3（默认）、ES5、ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES2017、ES2018、ES2019、ES2020、ESNext</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="json">&quot;compilerOptions&quot;: &#123;
    &quot;target&quot;: &quot;ES6&quot;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码</span><br><span class="line"></span><br><span class="line">- lib</span><br><span class="line"></span><br><span class="line">  - 指定代码运行时所包含的库（宿主环境）</span><br><span class="line"></span><br><span class="line">  - 可选值：</span><br><span class="line"></span><br><span class="line">    - ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;compilerOptions&quot;: &#123;</span><br><span class="line">          &quot;target&quot;: &quot;ES6&quot;,</span><br><span class="line">          &quot;lib&quot;: [&quot;ES6&quot;, &quot;DOM&quot;],</span><br><span class="line">          &quot;outDir&quot;: &quot;dist&quot;,</span><br><span class="line">          &quot;outFile&quot;: &quot;dist/aa.js&quot;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>module</p>
<ul>
<li><p>设置编译后代码使用的模块化系统</p>
</li>
<li><p>可选值：</p>
<ul>
<li>CommonJS、UMD、AMD、System、ES2020、ESNext、None</li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="typescript">&quot;compilerOptions&quot;: &#123;
    &quot;module&quot;: &quot;CommonJS&quot;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- outDir</span><br><span class="line"></span><br><span class="line">  - 编译后文件的所在目录</span><br><span class="line"></span><br><span class="line">  - 默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;compilerOptions&quot;: &#123;</span><br><span class="line">          &quot;outDir&quot;: &quot;dist&quot;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>设置后编译后的js文件将会生成到dist目录</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>outFile</p>
<ul>
<li><p>将所有的文件编译为一个js文件</p>
</li>
<li><p>默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中</p>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="json">&quot;compilerOptions&quot;: &#123;
    &quot;outFile&quot;: &quot;dist/app.js&quot;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- rootDir</span><br><span class="line"></span><br><span class="line">  - 指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录</span><br><span class="line"></span><br><span class="line">  - 示例：</span><br><span class="line"></span><br><span class="line">    - ```json</span><br><span class="line">      &quot;compilerOptions&quot;: &#123;</span><br><span class="line">          &quot;rootDir&quot;: &quot;./src&quot;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>allowJs</p>
<ul>
<li>是否对js文件编译</li>
</ul>
</li>
<li><p>checkJs</p>
<ul>
<li><p>是否对js文件进行检查</p>
</li>
<li><p>示例：</p>
<ul>
<li><pre><code class="json">&quot;compilerOptions&quot;: &#123;
    &quot;allowJs&quot;: true,
    &quot;checkJs&quot;: true
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">            - removeComments</span><br><span class="line"></span><br><span class="line">              - 是否删除注释</span><br><span class="line">              - 默认值：false</span><br><span class="line"></span><br><span class="line">            - noEmit</span><br><span class="line"></span><br><span class="line">              - 不对代码进行编译</span><br><span class="line">              - 默认值：false</span><br><span class="line"></span><br><span class="line">            - sourceMap</span><br><span class="line"></span><br><span class="line">              - 是否生成sourceMap</span><br><span class="line">              - 默认值：false</span><br><span class="line"></span><br><span class="line">              </span><br><span class="line"></span><br><span class="line">          - 严格检查</span><br><span class="line"></span><br><span class="line">            - strict</span><br><span class="line">              - 启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查</span><br><span class="line">            - alwaysStrict</span><br><span class="line">              - 总是以严格模式对代码进行编译</span><br><span class="line">            - noImplicitAny</span><br><span class="line">              - 禁止隐式的any类型</span><br><span class="line">            - noImplicitThis</span><br><span class="line">              - 禁止类型不明确的this</span><br><span class="line">            - strictBindCallApply</span><br><span class="line">              - 严格检查bind、call和apply的参数列表</span><br><span class="line">            - strictFunctionTypes</span><br><span class="line">              - 严格检查函数的类型</span><br><span class="line">            - strictNullChecks</span><br><span class="line">              - 严格的空值检查</span><br><span class="line">            - strictPropertyInitialization</span><br><span class="line">              - 严格检查属性是否初始化</span><br><span class="line"></span><br><span class="line">          - 额外检查</span><br><span class="line"></span><br><span class="line">            - noFallthroughCasesInSwitch</span><br><span class="line">              - 检查switch语句包含正确的break</span><br><span class="line">            - noImplicitReturns</span><br><span class="line">              - 检查函数没有隐式的返回值</span><br><span class="line">            - noUnusedLocals</span><br><span class="line">              - 检查未使用的局部变量</span><br><span class="line">            - noUnusedParameters</span><br><span class="line">              - 检查未使用的参数</span><br><span class="line"></span><br><span class="line">          - 高级</span><br><span class="line"></span><br><span class="line">            - allowUnreachableCode</span><br><span class="line">              - 检查不可达代码</span><br><span class="line">              - 可选值：</span><br><span class="line">                - true，忽略不可达代码</span><br><span class="line">                - false，不可达代码将引起错误</span><br><span class="line">            - noEmitOnError</span><br><span class="line">              - 有错误的情况下不进行编译</span><br><span class="line">              - 默认值：false</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line"></span><br><span class="line">### webpack</span><br><span class="line"></span><br><span class="line">- 通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。</span><br><span class="line"></span><br><span class="line">- 步骤：</span><br><span class="line"></span><br><span class="line">  1. 初始化项目</span><br><span class="line"></span><br><span class="line">     - 进入项目根目录，执行命令 ``` npm init -y```</span><br><span class="line">       - 主要作用：创建package.json文件</span><br><span class="line"></span><br><span class="line">  2. 下载构建工具</span><br><span class="line"></span><br><span class="line">     - npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin</span><br><span class="line">       - 共安装了7个包</span><br><span class="line">         - webpack</span><br><span class="line">           - 构建工具webpack</span><br><span class="line">         - webpack-cli</span><br><span class="line">           - webpack的命令行工具</span><br><span class="line">         - webpack-dev-server</span><br><span class="line">           - webpack的开发服务器</span><br><span class="line">         - typescript</span><br><span class="line">           - ts编译器</span><br><span class="line">         - ts-loader</span><br><span class="line">           - ts加载器，用于在webpack中编译ts文件</span><br><span class="line">         - html-webpack-plugin</span><br><span class="line">           - webpack中html插件，用来自动创建html文件</span><br><span class="line">         - clean-webpack-plugin</span><br><span class="line">           - webpack中的清除插件，每次构建都会先清除目录</span><br><span class="line"></span><br><span class="line">  3. 根目录下创建webpack的配置文件webpack.config.js</span><br><span class="line"></span><br><span class="line">     - ```javascript</span><br><span class="line">       const path = require(&quot;path&quot;);</span><br><span class="line">       const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);</span><br><span class="line">       const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;);</span><br><span class="line">       </span><br><span class="line">       module.exports = &#123;</span><br><span class="line">           optimization:&#123;</span><br><span class="line">               minimize: false // 关闭代码压缩，可选</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           entry: &quot;./src/index.ts&quot;,</span><br><span class="line">           </span><br><span class="line">           devtool: &quot;inline-source-map&quot;,</span><br><span class="line">           </span><br><span class="line">           devServer: &#123;</span><br><span class="line">               contentBase: &#x27;./dist&#x27;</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           output: &#123;</span><br><span class="line">               path: path.resolve(__dirname, &quot;dist&quot;),</span><br><span class="line">               filename: &quot;bundle.js&quot;,</span><br><span class="line">               environment: &#123;</span><br><span class="line">                   arrowFunction: false // 关闭webpack的箭头函数，可选</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           resolve: &#123;</span><br><span class="line">               extensions: [&quot;.ts&quot;, &quot;.js&quot;]</span><br><span class="line">           &#125;,</span><br><span class="line">           </span><br><span class="line">           module: &#123;</span><br><span class="line">               rules: [</span><br><span class="line">                   &#123;</span><br><span class="line">                       test: /\.ts$/,</span><br><span class="line">                       use: &#123;</span><br><span class="line">                          loader: &quot;ts-loader&quot;     </span><br><span class="line">                       &#125;,</span><br><span class="line">                       exclude: /node_modules/</span><br><span class="line">                   &#125;</span><br><span class="line">               ]</span><br><span class="line">           &#125;,</span><br><span class="line">       </span><br><span class="line">           plugins: [</span><br><span class="line">               new CleanWebpackPlugin(),</span><br><span class="line">               new HtmlWebpackPlugin(&#123;</span><br><span class="line">                   title:&#x27;TS测试&#x27;</span><br><span class="line">               &#125;),</span><br><span class="line">           ]</span><br><span class="line">       </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li><p>根目录下创建tsconfig.json，配置可以根据自己需要</p>
<ul>
<li><pre><code class="json">&#123;
    &quot;compilerOptions&quot;: &#123;
        &quot;target&quot;: &quot;ES2015&quot;,
        &quot;module&quot;: &quot;ES2015&quot;,
        &quot;strict&quot;: true
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5. 修改package.json添加如下配置</span><br><span class="line"></span><br><span class="line">   - ```json</span><br><span class="line">     &#123;</span><br><span class="line">       ...略...</span><br><span class="line">       &quot;scripts&quot;: &#123;</span><br><span class="line">         &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">         &quot;build&quot;: &quot;webpack&quot;,</span><br><span class="line">         &quot;start&quot;: &quot;webpack serve --open chrome.exe&quot;</span><br><span class="line">       &#125;,</span><br><span class="line">       ...略...</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>在src下创建ts文件，并在并命令行执行<code>npm run build</code>对代码进行编译，或者执行<code>npm start</code>来启动开发服务器</p>
</li>
</ol>
</li>
</ul>
<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><ul>
<li><p>经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合babel来对代码进行转换以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中。</p>
<ol>
<li><p>安装依赖包：</p>
<ul>
<li><code>npm i -D @babel/core @babel/preset-env babel-loader core-js</code></li>
<li>共安装了4个包，分别是：<ul>
<li>@babel&#x2F;core<ul>
<li>babel的核心工具</li>
</ul>
</li>
<li>@babel&#x2F;preset-env<ul>
<li>babel的预定义环境</li>
</ul>
</li>
<li>@babel-loader<ul>
<li>babel在webpack中的加载器</li>
</ul>
</li>
<li>core-js<ul>
<li>core-js用来使老版本的浏览器支持新版ES语法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>修改webpack.config.js配置文件</p>
<ul>
<li><pre><code class="javascript">...略...
module: &#123;
    rules: [
        &#123;
            test: /\.ts$/,
            use: [
                &#123;
                    loader: &quot;babel-loader&quot;,
                    options:&#123;
                        presets: [
                            [
                                &quot;@babel/preset-env&quot;,
                                &#123;
                                    &quot;targets&quot;:&#123;
                                        &quot;chrome&quot;: &quot;58&quot;,
                                        &quot;ie&quot;: &quot;11&quot;
                                    &#125;,
                                    &quot;corejs&quot;:&quot;3&quot;,
                                    &quot;useBuiltIns&quot;: &quot;usage&quot;
                                &#125;
                            ]
                        ]
                    &#125;
                &#125;,
                &#123;
                    loader: &quot;ts-loader&quot;,

                &#125;
            ],
            exclude: /node_modules/
        &#125;
    ]
&#125;
...略...
</code></pre>
</li>
<li><p>如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux</title>
    <url>/2021/10/11/Redux/</url>
    <content><![CDATA[<ul>
<li>Redux的设计思想</li>
</ul>
<p>（1）Web 应用是一个状态机，视图与状态是一一对应的。</p>
<p>（2）所有的状态，保存在一个对象里面。</p>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><ol>
<li><p>Action 就是 View 发出的通知，表示 State 应该要发生变化了。</p>
</li>
<li><p>Action 是一个对象，其中的<code>type</code>属性是必须的，表示 Action 的名称，Action 描述当前发生的事情。</p>
</li>
<li><p>改变 State 的唯一办法，就是使用 Action。</p>
</li>
</ol>
<p>可以定义一个函数来生成 Action，这个函数就叫 Action Creator，示例如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sendAction</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;send_type&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;action hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><ol>
<li><p>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</p>
</li>
<li><p>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</p>
</li>
</ol>
<p>Demo:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;init&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state = initState, action</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reducer:&#x27;</span>, state, action);</span><br><span class="line">    <span class="keyword">switch</span>(action.<span class="property">type</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;send_type&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, state, action);</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><h3 id="StoreApi"><a href="#StoreApi" class="headerlink" title="StoreApi:"></a>StoreApi:</h3><ul>
<li><p><code>store.subscribe()</code>: 添加一个变化监听器。每当 dispatch action 的时候就会执行，state 树中的一部分可能已经变化。你可以在回调函数里调用<code>getState()</code>来拿到当前 state。</p>
</li>
<li><p><code>store.dispatch()</code>是 View 发出 Action 的唯一方法，将使用当前 <code>getState()</code>的结果和传入的 <code>action</code> 以同步方式的调用 store 的 reduce 函数。它的返回值会被作为下一个 state。从现在开始，这就成为了 <code>getState()</code>的返回值，同时变化监听器(change listener)会被触发。</p>
<blockquote>
</blockquote>
</li>
<li><p>流程：</p>
<p>组件 – <code>store.dispatch(action)</code> – 触发reducer的执行 – 根据type区分返回的state – 返回值给store – 更新state – <code>store.subscribe(listener)</code>中listener回调函数执行。</p>
</li>
</ul>
<p><img src="/../assets/image-20210309183756689.png" alt="image-20210309183756689"></p>
<h2 id="React-redux"><a href="#React-redux" class="headerlink" title="React-redux"></a>React-redux</h2><p><img src="/../assets/image-20210309200347890.png" alt="image-20210309200347890"></p>
<h2 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h2><h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><p><code>connect</code>方法接受两个参数：<code>mapStateT.oProps</code>和<code>mapDispatchToProps</code>。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将<code>state</code>映射到 UI 组件的参数（<code>props</code>），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。</p>
<ul>
<li><h3 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps"></a><code>mapStateToProps</code></h3><p><code>mapStateToProps</code>是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）<code>state</code>对象到（UI 组件的）<code>props</code>对象的映射关系。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mapStateToProps</span> = (<span class="params">state</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">todos</span>: <span class="title function_">getVisibleTodos</span>(state.<span class="property">todos</span>, state.<span class="property">visibilityFilter</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mapStateToProps</code>会订阅 Store，每当<code>state</code>更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p>
<p><code>mapStateToProps</code>的第一个参数总是<code>state</code>对象，还可以使用第二个参数，代表容器组件的<code>props</code>对象。</p>
<p><code>connect</code>方法可以省略<code>mapStateToProps</code>参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新。</p>
</li>
<li><h3 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a><code>mapDispatchToProps</code></h3><p><code>mapDispatchToProps</code>是<code>connect</code>函数的第二个参数，用来建立 UI 组件的参数到<code>store.dispatch</code>方法的映射</p>
<p>如果<code>mapDispatchToProps</code>是一个函数，会得到<code>dispatch</code>和<code>ownProps</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mapDispatchToProps</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  dispatch,</span></span><br><span class="line"><span class="params">  ownProps</span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">onClick</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">dispatch</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>,</span><br><span class="line">        <span class="attr">filter</span>: ownProps.<span class="property">filter</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>mapDispatchToProps</code>是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出(dispatch).</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123;</span><br><span class="line">  <span class="attr">onClick</span>: <span class="function">(<span class="params">filter</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>,</span><br><span class="line">    <span class="attr">filter</span>: filter</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="计数器Demo："><a href="#计数器Demo：" class="headerlink" title="计数器Demo："></a>计数器Demo：</h2><p>两个组件，按钮ComA和文本ComB，点击按钮+1，用react-redux实现通信的过程</p>
</li>
</ul>
<p><img src="/../assets/image-20210310173423401.png" alt="image-20210310173423401"></p>
]]></content>
      <categories>
        <category>状态管理</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>require() 源码解读</title>
    <url>/2021/08/21/require%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>序 / INTRO</title>
    <url>/2024/09/30/intro/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>书单 / BookList</title>
    <url>/2024/09/26/%E4%B9%A6%E5%8D%95/</url>
    <content><![CDATA[<h4 id="专业向"><a href="#专业向" class="headerlink" title="专业向"></a>专业向</h4><h5 id="计算机（2）"><a href="#计算机（2）" class="headerlink" title="计算机（2）"></a>计算机（2）</h5><p><a href="https://markdown.com.cn/">你所不知道的JavaScript</a><br><a href="https://markdown.com.cn/">深入浅出NodeJS</a><br><a href="https://markdown.com.cn/">Webpack实战：入门、进阶与调优</a><br><a href="https://markdown.com.cn/">TypeScript图形渲染实战</a></p>
<h5 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h5><hr>
<h4 id="非专业向"><a href="#非专业向" class="headerlink" title="非专业向"></a>非专业向</h4><h5 id="社科文学类（5）"><a href="#社科文学类（5）" class="headerlink" title="社科文学类（5）"></a>社科文学类（5）</h5><p><a href="https://markdown.com.cn/">山月记</a><br><a href="https://markdown.com.cn/">宋词群星闪耀时</a><br><a href="https://markdown.com.cn/">我在西南联大的日子</a><br><a href="https://markdown.com.cn/">当呼吸化为空气</a><br><a href="https://markdown.com.cn/">被讨厌的勇气</a></p>
<h5 id="杂文散文（1）"><a href="#杂文散文（1）" class="headerlink" title="杂文散文（1）"></a>杂文散文（1）</h5><p><a href="https://markdown.com.cn/">生命是孤独的旅程</a></p>
<h5 id="小说（4）"><a href="#小说（4）" class="headerlink" title="小说（4）"></a>小说（4）</h5><p><a href="https://markdown.com.cn/">羊毛战记</a><br><a href="https://markdown.com.cn/">三国演义</a><br><a href="https://markdown.com.cn/">冰与火之歌</a><br><a href="https://markdown.com.cn/">野性的呼唤</a><br><a href="https://markdown.com.cn/">龙族</a></p>
<h5 id="传记（1）"><a href="#传记（1）" class="headerlink" title="传记（1）"></a>传记（1）</h5><p><a href="https://markdown.com.cn/">苏东坡全传</a></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/2021/10/08/%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h4><p>函数式编程具有五个鲜明的特点。</p>
<p><strong>1. 函数是”第一等公民”</strong></p>
<p>指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p>
<p>举例来说，下面代码中的print变量就是一个函数，可以作为另一个函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">　　<span class="keyword">var</span> print = <span class="keyword">function</span>(<span class="params">i</span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(i);&#125;;</span><br><span class="line"></span><br><span class="line">　　[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">forEach</span>(print);</span><br></pre></td></tr></table></figure>

<p><strong>2. 只用”表达式”，不用”语句”</strong></p>
<p>“表达式”（expression）是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</p>
<p>原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I&#x2F;O）。”语句”属于对系统的读写操作，所以就被排斥在外。</p>
<p>当然，实际应用中，不做I&#x2F;O是不可能的。因此，编程过程中，函数式编程只要求把I&#x2F;O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。</p>
<span id="more"></span>

<p><strong>3. 没有”副作用”</strong></p>
<p>所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。</p>
<p>函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p>
<p><strong>4. 不修改状态</strong></p>
<p>上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。</p>
<p>在其他类型的语言中，变量往往用来保存”状态”（state）。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。下面的代码是一个将字符串逆序排列的函数，它演示了不同的参数如何决定了运算所处的”状态”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function reverse(string) &#123;</span><br><span class="line">　　if(string.length == 0) &#123;</span><br><span class="line">　　　　return string;</span><br><span class="line">　　&#125; else &#123;</span><br><span class="line">　　　　return reverse(string.substring(1, string.length)) + string.substring(0, 1);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于使用了递归，函数式语言的运行速度比较慢，这是它长期不能在业界推广的主要原因。</p>
<p><strong>5. 引用透明</strong></p>
<p>引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或”状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。</p>
<p>有了前面的第三点和第四点，这点是很显然的。其他类型的语言，函数的返回值往往与系统状态有关，不同的状态之下，返回值是不一样的。这就叫”引用不透明”，很不利于观察和理解程序的行为。</p>
<h4 id="函数式编程的意义"><a href="#函数式编程的意义" class="headerlink" title="函数式编程的意义"></a>函数式编程的意义</h4><p><strong>1. 代码简洁，开发快速</strong></p>
<p>函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。</p>
<p><strong>2. 更方便的代码管理</strong></p>
<p>函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。</p>
]]></content>
      <categories>
        <category>Chore</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Functional Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>如何利用css var做一个dark mode方案</title>
    <url>/2022/03/01/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8css%20var%E5%81%9A%E4%B8%80%E4%B8%AAdark%20mode%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ol>
<li>希望利用 css 变量实现 dark 和 light 模式的切换</li>
<li>原有的工程都是 less 形式定义的 css，并且还有 less 的函数，比如 fade 等，不想手动改 less 的函数，希望该插件能支持解析 less 函数</li>
<li>需要支持局部不切换模式，比如某个区域是固定的 light 模式</li>
</ol>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="第一步：less-变量转换成-css-变量"><a href="#第一步：less-变量转换成-css-变量" class="headerlink" title="第一步：less 变量转换成 css 变量"></a>第一步：less 变量转换成 css 变量</h2><p>这一步比较简单，less 已经提供了字段用于转换，只需要添加一个配置项就可以，就是<code>globalVars</code>属性。</p>
<p>可以查看<a href="https://link.juejin.cn/?target=https://codebase.byted.org/repo/lark/dark-mode-css-var/-/blob/example/config/webpack.dm-cssvar.config.js">example 代码</a>参考</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;less-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">globalVars</span>: <span class="title class_">LessGlobalCSSVars</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>LessGlobalCSSVars</code>大概长这个样子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;bg-body&quot;</span>: <span class="string">&quot;var(--bg-body)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;static-white&quot;</span>: <span class="string">&quot;var(--static-white)&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>less 会将<code>LessGlobalCSSVars</code>的映射关系追加到 less 文件前，在进行变量查找的时候就会替换成相应的 css 变量</p>
<p>比如，下面的 less 文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    <span class="attr">color</span>: @bg-body;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>less 实际解析的文件内容是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bg-<span class="attr">body</span>: <span class="string">&quot;var(--bg-body)&quot;</span>;</span><br><span class="line"><span class="keyword">static</span>-<span class="attr">white</span>: <span class="string">&quot;var(--static-white)&quot;</span></span><br><span class="line">div &#123;</span><br><span class="line">    <span class="attr">color</span>: @bg-body;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>最后上面的文件就会被编译成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div &#123; <span class="attr">color</span>: <span class="title function_">var</span>(--bg-body);&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="第二步：less-函数如何解析？【less-插件】"><a href="#第二步：less-函数如何解析？【less-插件】" class="headerlink" title="第二步：less 函数如何解析？【less 插件】"></a>第二步：less 函数如何解析？【less 插件】</h2><p>但是还有一个问题是 less 函数应该如何解析呢？比如<code>fade(``@bg-body, 20%``)</code>，如果不经过任何处理，这个函数会抛出异常，因为<code>var(--bg-body)</code>并不是 less 能够解析的节点类型，会提示<code>var(--bg-body)</code>不能被转换成<code>Color</code>类型（less 的一个节点类型），这是 less 的语法树解析，需要将 fade 函数的第一个参数解析成 Color 节点类型，否则就会抛异常。所以，我们需要对 less 函数进行改写，具体通过 less 插件的方式实现。修改 less-loader 的配置如下，增加一个插件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;less-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">globalVars</span>: <span class="title class_">LessGlobalCSSVars</span>,</span><br><span class="line">      <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LessSkipVarsPlugin</span> ()</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>less 的所有函数会被注册到<code>[functions](https://github.com/less/less.js/blob/master/packages/less/src/less/functions/index.js &quot;functions&quot;)</code>中，插件暴露了该<code>functions</code>，因此可以通过修改响应的 less 函数，实现函数的覆盖。该插件的实现<a href="https://link.juejin.cn/?target=https://codebase.byted.org/repo/lark/dark-mode-css-var/-/blob/example/config/webpack.dm-cssvar.config.js">源代码</a>如下，functions 对象是函数名到函数体的映射，所以我们将需要重写的函数重置成我们自定义的即可。而函数的计算结果通过<code>calc</code>和<code>var</code>两个函数以及 css 变量进行表示，在页面中即可根据 css 变量进行实时计算！</p>
<p>下面只摘出来了我们支持的其中两个函数——fade 和 darken，fade 利用 rgba 的函数表示，而 darken 利用的是 hsl 的函数表示，主要是用 rgba 的表示法无法用 css 支持的函数表示出来，所以我们用了 hsl 函数。这里可以看到我们需要一些特殊的 css 变量，比如<code>--bg-body-SA</code>、<code>--bg-body-raw</code>、<code>--bg-HS</code>、 <code>--bg-body-L</code>.所以我们需要利用原始的色值（<code>bg-body</code>）进行转换</p>
<p>(下面代码做了省略，主要是示意，具体代码可以看源代码)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LessSkipVarsPlugin</span> &#123;</span><br><span class="line">    <span class="title function_">install</span>(<span class="params">less, pluginManager, functions</span>) &#123;</span><br><span class="line">        functions.<span class="title function_">add</span>(<span class="string">&#x27;fade&#x27;</span>, <span class="keyword">function</span> (<span class="params">color, percent</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (color.<span class="property">type</span> === <span class="string">&#x27;Call&#x27;</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (color.<span class="property">name</span> === <span class="string">&#x27;var&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> key = color.<span class="property">args</span>[<span class="number">0</span>].<span class="property">value</span>.<span class="title function_">substring</span>(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">`rgba(var(--<span class="subst">$&#123;key&#125;</span>-raw), calc(var(--<span class="subst">$&#123;key&#125;</span>-SA) * <span class="subst">$&#123;parseLessNumber(percent)&#125;</span>))`</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">`rgba(<span class="subst">$&#123;red&#125;</span>,<span class="subst">$&#123;green&#125;</span>,<span class="subst">$&#123;blue&#125;</span>,<span class="subst">$&#123;alpha * parseLessNumber(percent)&#125;</span>)`</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        functions.<span class="title function_">add</span>(<span class="string">&#x27;darken&#x27;</span>, <span class="keyword">function</span> (<span class="params">color, amount, method</span>) &#123;</span><br><span class="line">            .......</span><br><span class="line">            <span class="keyword">if</span> (color.<span class="property">type</span> !== <span class="string">&#x27;Color&#x27;</span>)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`fade function parameter type error: except Color, get <span class="subst">$&#123;color.type&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">const</span> hsl = (<span class="keyword">new</span> <span class="title class_">Color</span>(color.<span class="property">rgb</span>, color.<span class="property">alpha</span>)).<span class="title function_">toHSL</span>();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> method !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; method.<span class="property">value</span> === <span class="string">&#x27;relative&#x27;</span>) &#123;</span><br><span class="line">                hsl.<span class="property">l</span> = hsl.<span class="property">l</span> * (<span class="number">1</span> - <span class="title function_">parseLessNumber</span>(amount));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hsl.<span class="property">l</span> = hsl.<span class="property">l</span> - <span class="title function_">parseLessNumber</span>(amount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">`hsl(<span class="subst">$&#123;hsl.h&#125;</span>,<span class="subst">$&#123;hsl.s&#125;</span>,<span class="subst">$&#123;hsl.l&#125;</span>)`</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="第三步：局部-light-模式如何支持？【postcss-插件】"><a href="#第三步：局部-light-模式如何支持？【postcss-插件】" class="headerlink" title="第三步：局部 light 模式如何支持？【postcss 插件】"></a>第三步：局部 light 模式如何支持？【postcss 插件】</h2><p>点击<a href="https://link.juejin.cn/?target=https://codebase.byted.org/repo/lark/dark-mode-css-var/-/blob/src/css-loader/plugins/postcss-color.js%23L50">这里</a>可以快速定位到源代码。可以在 dom 节点上添加 classname 前缀，用来标注该 dom 下的样式都使用静态的亮色模式，不随主题切换。这里需要做的主要分为 3 步：</p>
<ol>
<li><h3 id="第-1-步：【添加-dom-前缀-classname】"><a href="#第-1-步：【添加-dom-前缀-classname】" class="headerlink" title="第 1 步：【添加 dom 前缀 classname】"></a>第 1 步：【添加 dom 前缀 classname】</h3></li>
</ol>
<p>在相应的 dom 节点添加 classname 前缀，比如 static-light；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来的dom结构</span></span><br><span class="line">&lt;div className=<span class="string">&quot;test&quot;</span>&gt;aaa&lt;/div&gt;</span><br><span class="line"><span class="comment">// 新的dom结构</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;static-light&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;test&quot;</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li><h3 id="第-2-步：【追加前缀样式】"><a href="#第-2-步：【追加前缀样式】" class="headerlink" title="第 2 步：【追加前缀样式】"></a>第 2 步：【追加前缀样式】</h3><ol>
<li>生成样式时，通过 postcss 为所有的样式添加 static-light 前缀；</li>
</ol>
</li>
</ol>
<p>这一步实际上是在 css-loader 的处理过程中加入了一个 postcss 插件，对每条规则<a href="https://link.juejin.cn/?target=https://www.postcss.com.cn/api/%23rule">rule</a>额外生成一条静态样式。</p>
<p>举个例子,我定义了如下的 less 样式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">test</span> &#123;</span><br><span class="line">    background-<span class="attr">color</span>: @<span class="keyword">static</span>-white;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>经过该 postcss 插件之后，生成的产物会变成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">test</span> &#123;</span><br><span class="line">    background-<span class="attr">color</span>: <span class="title function_">var</span>(--<span class="keyword">static</span>-white);</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">static</span>-light .<span class="property">test</span> &#123;</span><br><span class="line">    background-<span class="attr">color</span>: <span class="title function_">var</span>(--<span class="keyword">static</span>-white);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>所以要怎样才能追加生成这样的 css 呢？</p>
<p>可以看到 css-loader 的<a href="https://link.juejin.cn/?target=https://github.com/webpack-contrib/css-loader/blob/master/src/index.js%23L163">源码</a>中，节点都经过了 postcss 插件的处理，我们只需要在插件列表中，加上我们的插件即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = <span class="keyword">await</span> <span class="title function_">postcss</span>([...plugins, <span class="keyword">new</span> <span class="title function_">colorPlugin</span>(&#123;</span><br><span class="line">  <span class="attr">staticEx</span>: &#123;<span class="attr">prefix</span>:<span class="string">&#x27;.static-light&#x27;</span>&#125;,</span><br><span class="line">&#125;)]).<span class="title function_">process</span>(content, &#123;...&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>所以接下来可以实现我们的 postcss 插件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postcss = <span class="built_in">require</span>(<span class="string">&#x27;postcss&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = postcss.<span class="title function_">plugin</span>(<span class="string">&#x27;postcss-color-and-function&#x27;</span>, <span class="keyword">function</span> (<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; staticEx &#125; = options;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">processNode</span>(<span class="params">node, type</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> staticNode;</span><br><span class="line">        <span class="keyword">switch</span> (node.<span class="property">type</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;rule&#x27;</span>:</span><br><span class="line">                staticNode =  node.<span class="title function_">clone</span>();</span><br><span class="line">                staticNode.<span class="property">selectors</span> = staticNode.<span class="property">selectors</span>.<span class="title function_">map</span>(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;options.staticEx.prefix&#125;</span> <span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> staticNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">css</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> last = [];</span><br><span class="line">        css.<span class="title function_">each</span>(<span class="function">(<span class="params">node, type</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> staticNode = <span class="title function_">processNode</span>(node, type);</span><br><span class="line">            <span class="keyword">if</span> (staticNode) &#123;</span><br><span class="line">                last.<span class="title function_">push</span>(staticNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        css.<span class="property">nodes</span> = css.<span class="property">nodes</span>.<span class="title function_">concat</span>(last);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>主要的实现思路是：</p>
<ul>
<li>通过当前节点克隆一个一样的节点，在最后返回的时候拼接该节点，这样可以生成两份样式；</li>
<li>对于克隆的那份节点，追加选择器，</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">staticNode.<span class="property">selectors</span> = staticNode.<span class="property">selectors</span>.<span class="title function_">map</span>(<span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;options.staticEx.prefix&#125;</span> <span class="subst">$&#123;i&#125;</span>`</span></span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这样就可以实现追加节点和局部 css 变量定义了。</p>
<blockquote>
<p>注:css-loader 会校验参数，所以如果需要修改传入的参数格式，还需要修改<a href="https://link.juejin.cn/?target=https://github.com/webpack-contrib/css-loader/blob/master/src/options.json%23L197">options.json</a>和<a href="https://link.juejin.cn/?target=https://github.com/webpack-contrib/css-loader/blob/master/src/utils.js%23L628">normalizeOptions</a>。</p>
</blockquote>
<ol>
<li><h3 id="第-3-步：插入一套制定-classname（这里是-static-light）的-css-var-变量。"><a href="#第-3-步：插入一套制定-classname（这里是-static-light）的-css-var-变量。" class="headerlink" title="第 3 步：插入一套制定 classname（这里是 static-light）的 css var 变量。"></a>第 3 步：插入一套制定 classname（这里是 static-light）的 css var 变量。</h3></li>
</ol>
<p>这里我们借助 webpack 的插件来实现，详细内容看下一部分</p>
<h2 id="第四步：追加全局-css-变量定义【webpack-插件】"><a href="#第四步：追加全局-css-变量定义【webpack-插件】" class="headerlink" title="第四步：追加全局 css 变量定义【webpack 插件】"></a>第四步：追加全局 css 变量定义【webpack 插件】</h2><p>我们可以定义一下 css 变量，就可以生效了，添加@media (prefers-color-scheme: dark)可以在系统模式变化的时候切换 css 变量，就可以实现样式的切换。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line"> <span class="attr">--bg-body</span>: <span class="string">&quot;#1f1f1f&quot;</span>;</span><br><span class="line"> <span class="attr">--static-white</span>: <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme</span>: dark) &#123;</span><br><span class="line">    <span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">     <span class="attr">--bg-body</span>: <span class="string">&quot;#2f2f2f&quot;</span>;</span><br><span class="line">     <span class="attr">--static-white</span>: <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>上面一小节中，我们还需要追加局部 light 样式对应的 css 变量，需要在上述变量的基础上追加下面的一段代码。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line"> <span class="attr">--bg-body</span>: <span class="string">&quot;#1f1f1f&quot;</span>;</span><br><span class="line"> <span class="attr">--static-white</span>: <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme</span>: dark) &#123;</span><br><span class="line">    <span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">     <span class="attr">--bg-body</span>: <span class="string">&quot;#2f2f2f&quot;</span>;</span><br><span class="line">     <span class="attr">--static-white</span>: <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.static-light</span> &#123;</span><br><span class="line"> <span class="attr">--bg-body</span>: <span class="string">&quot;#1f1f1f&quot;</span>;</span><br><span class="line"> <span class="attr">--static-white</span>: <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这样我们手动追加变量就会变得复杂，并且容易出错，所以我们可以利用 webpack 插件进行追加，webpack 提供了各种钩子，我们可以利用这些生命周期钩子在合适的时机执行相应的逻辑。</p>
<ol>
<li><h3 id="第-1-步：【生成-css-文件】"><a href="#第-1-步：【生成-css-文件】" class="headerlink" title="第 1 步：【生成 css 文件】"></a>第 1 步：【生成 css 文件】</h3><ol>
<li>我们需要保证生成 css 文件只会执行一次，并且保证生成文件在插入 link 标签之前，HtmlWebpackPlugin 插件提供的生命周期钩子函数<a href="https://link.juejin.cn/?target=https://github.com/jantimon/html-webpack-plugin%23alterassettags-hook">alterAssetTags</a>，返回当前所有的资源列表，用户可以在此追加一些资源链接，所以我们可以在此生命周期钩子处，触发生成文件。</li>
</ol>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">compiler.<span class="property">hooks</span>.<span class="property">compilation</span>.<span class="title function_">tap</span>(<span class="string">&#x27;LarkThemePlugin&#x27;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">HtmlWebpackPlugin</span>.<span class="title function_">getHooks</span>(compilation).<span class="property">alterAssetTags</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;LarkThemePlugin&#x27;</span>, <span class="function">(<span class="params">data, cb</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> source = xxx;</span><br><span class="line">        compilation.<span class="property">assets</span>[<span class="string">&#x27;theme.css&#x27;</span>] = &#123; <span class="attr">source</span>: <span class="function">() =&gt;</span> source, <span class="attr">size</span>: <span class="function">() =&gt;</span> <span class="title class_">Buffer</span>.<span class="title function_">byteLength</span>(source, <span class="string">&#x27;utf-8&#x27;</span>)&#125;;</span><br><span class="line">      <span class="title function_">cb</span>(<span class="literal">null</span>,data);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li><h3 id="第-2-步：生成-link-标签引用："><a href="#第-2-步：生成-link-标签引用：" class="headerlink" title="第 2 步：生成 link 标签引用："></a>第 2 步：生成 link 标签引用：</h3><ol>
<li>上一步生成了 css 资源文件，我们需要在 html 中追加一个 link 标签，引用该 css 资源，在实际应用中，我们往往会有很多资源标签插入到 html 中，而我们又希望该标签可以插入到所有资源文件之前进行加载</li>
</ol>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">compiler.<span class="property">hooks</span>.<span class="property">compilation</span>.<span class="title function_">tap</span>(<span class="string">&#x27;LarkThemePlugin&#x27;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">HtmlWebpackPlugin</span>.<span class="title function_">getHooks</span>(compilation).<span class="property">alterAssetTags</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;LarkThemePlugin&#x27;</span>, <span class="function">(<span class="params">data, cb</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">assetTags</span>: &#123; styles &#125;&#125; = data;</span><br><span class="line">      styles.<span class="title function_">unshift</span>(&#123;</span><br><span class="line">        <span class="attr">tagName</span>: <span class="string">&#x27;link&#x27;</span>,</span><br><span class="line">        <span class="attr">voidTag</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">attributes</span>: &#123;</span><br><span class="line">          <span class="attr">href</span>: <span class="string">&#x27;theme.css&#x27;</span>,</span><br><span class="line">          <span class="attr">rel</span>: <span class="string">&#x27;stylesheet&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="title function_">cb</span>(<span class="literal">null</span>,data);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>完整的 webpack 插件代码在下方：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; getRootCSSVarMap &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../util&#x27;</span>);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InjectThemeWebpackPlugin</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">&#123; lessVarsSet, darkTokens, lightTokens &#125;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">darkTokens</span> = darkTokens;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">lightTokens</span> = lightTokens;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成css变量的css样式</span></span><br><span class="line">    <span class="title function_">generateResult</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">generateCss</span> = (<span class="params">cssObj</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> css = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> cssObj) &#123;</span><br><span class="line">            <span class="keyword">const</span> value = cssObj[key];</span><br><span class="line">            css += <span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>;`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`:root&#123;<span class="subst">$&#123;css&#125;</span>&#125;`</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> darkCSSObj = <span class="title function_">getRootCSSVarMap</span>(<span class="variable language_">this</span>.<span class="property">darkTokens</span>, <span class="string">&#x27;DARK&#x27;</span>);</span><br><span class="line">      <span class="keyword">const</span> lightCSSObj = <span class="title function_">getRootCSSVarMap</span>(<span class="variable language_">this</span>.<span class="property">lightTokens</span>, <span class="string">&#x27;LIGHT&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;generateCss(lightCSSObj)&#125;</span>\n@media (prefers-color-scheme: dark) &#123;<span class="subst">$&#123;generateCss(darkCSSObj)&#125;</span>&#125;`</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">      <span class="comment">// 追加link标签</span></span><br><span class="line">      compiler.<span class="property">hooks</span>.<span class="property">compilation</span>.<span class="title function_">tap</span>(<span class="string">&#x27;LarkThemePlugin&#x27;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">HtmlWebpackPlugin</span>.<span class="title function_">getHooks</span>(compilation).<span class="property">alterAssetTags</span>.<span class="title function_">tapAsync</span>(<span class="string">&#x27;LarkThemePlugin&#x27;</span>, <span class="function">(<span class="params">data, cb</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> source = <span class="variable language_">this</span>.<span class="title function_">generateResult</span>();</span><br><span class="line">          compilation.<span class="property">assets</span>[<span class="string">&#x27;theme.css&#x27;</span>] = &#123; <span class="attr">source</span>: <span class="function">() =&gt;</span> source, <span class="attr">size</span>: <span class="function">() =&gt;</span> <span class="title class_">Buffer</span>.<span class="title function_">byteLength</span>(source, <span class="string">&#x27;utf-8&#x27;</span>)&#125;;</span><br><span class="line">          <span class="keyword">const</span> &#123; <span class="attr">assetTags</span>: &#123; styles &#125;&#125; = data;</span><br><span class="line">          styles.<span class="title function_">unshift</span>(&#123;</span><br><span class="line">            <span class="attr">tagName</span>: <span class="string">&#x27;link&#x27;</span>,</span><br><span class="line">            <span class="attr">voidTag</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">attributes</span>: &#123;</span><br><span class="line">              <span class="attr">href</span>: <span class="string">&#x27;theme.css&#x27;</span>,</span><br><span class="line">              <span class="attr">rel</span>: <span class="string">&#x27;stylesheet&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="title function_">cb</span>(<span class="literal">null</span>,data);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">InjectThemeWebpackPlugin</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：这里需要注意，需要保证<code>html-webpack-plugin</code>插件一直是一个，不然会出现无法追加上 link 标签的情况</p>
</blockquote>
]]></content>
      <categories>
        <category>Chore</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>成为老师</title>
    <url>/2024/09/26/%E6%88%90%E4%B8%BA%E8%80%81%E5%B8%88/</url>
    <content><![CDATA[<p>每决定人类命运的正是那一秒钟<br>回想多年前的每一个决定<br>我现在也正站在人生的十字路口</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器架构和事件循环</title>
    <url>/2021/10/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h3 id="chrome浏览器架构"><a href="#chrome浏览器架构" class="headerlink" title="chrome浏览器架构"></a>chrome浏览器架构</h3><p>Chrome 采用多进程架构，其顶层存在一个 Browser process 用以协调浏览器的其它进程。</p>
<ul>
<li>Browser Process：</li>
</ul>
<ol>
<li><p>负责包括地址栏，书签栏，前进后退按钮等部分的工作；</p>
</li>
<li><p>负责处理浏览器的一些不可见的底层操作，比如网络请求和文件访问；</p>
</li>
</ol>
<ul>
<li>Renderer Process：</li>
</ul>
<ol>
<li>负责一个 tab 内关于网页呈现的所有事情</li>
</ol>
<ul>
<li>Plugin Process：</li>
</ul>
<ol>
<li>负责控制一个网页用到的所有插件，如 flash</li>
</ol>
<ul>
<li>GPU Process</li>
</ul>
<ol>
<li>负责处理 GPU 相关的任务</li>
</ol>
<p><img src="/../assets/image-20210930012419754.png" alt="image-20210930012419754"></p>
<p>由于一个tab标签页都有一个独立的渲染进程，所以一个tab异常崩溃后，其他tab不会受到影响。</p>
<p>一个渲染进程包括</p>
<ul>
<li>JS引擎线程</li>
<li>HTTP请求线程</li>
<li>定时触发线程</li>
<li>事件触发线程</li>
<li>GUI线程</li>
</ul>
<h3 id="浏览器JS异步执行原理"><a href="#浏览器JS异步执行原理" class="headerlink" title="浏览器JS异步执行原理"></a>浏览器JS异步执行原理</h3><p>执行JS代码的线程只有一个，是浏览器提供的JS引擎线程，浏览器中还有</p>
<p><img src="/../image/image-20210930012033902.png" alt="image-20210930012033902"></p>
<span id="more"></span>

<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p><img src="/../image/image-20210930190158487.png" alt="image-20210930190158487"></p>
<p>js引擎解析代码时，遇到同步任务-&gt;放入执行栈直接执行，遇到异步任务（比如ajax），交给网络线程处理，完成后将对应回调放入异步任务队列，<strong>当执行栈清空时，循环检测异步任务队列，将异步队列中的回调放入执行栈中执行。</strong></p>
<h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><p><strong>Dom渲染会在微任务结束后，宏任务执行前</strong></p>
<h4 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h4><table>
<thead>
<tr>
<th>#</th>
<th>浏览器</th>
<th>Node</th>
</tr>
</thead>
<tbody><tr>
<td><code>I/O</code></td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><code>setTimeout</code></td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><code>setInterval</code></td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><code>setImmediate</code></td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><code>requestAnimationFrame</code></td>
<td>✅</td>
<td>❌</td>
</tr>
</tbody></table>
<h4 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h4><table>
<thead>
<tr>
<th>#</th>
<th>浏览器</th>
<th>Node</th>
</tr>
</thead>
<tbody><tr>
<td><code>process.nextTick</code></td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><code>MutationObserver</code></td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td><code>Promise.then catch finally</code></td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody></table>
<h3 id="事件循环加入宏任务微任务"><a href="#事件循环加入宏任务微任务" class="headerlink" title="事件循环加入宏任务微任务"></a>事件循环加入宏任务微任务</h3><ol>
<li>Call Stack调用栈清空</li>
<li><strong>清空</strong>当前微任务队列</li>
<li>尝试DOM渲染</li>
<li>执行event loop </li>
<li>取出任务队列里的一个宏任务，入栈执行</li>
<li>返回1</li>
</ol>
<p>对于以下demo</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">r</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">r</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 1 4 2 5 3 6</span></span><br></pre></td></tr></table></figure>

<p><code>Promise.prototype.then()</code> 会隐式返回一个新 Promise</p>
<p>如果 Promise 的状态是 pending，那么 <code>then</code> 会在该 Promise 上注册一个回调，当其状态发生变化时，对应的回调将作为一个微任务被推入微任务队列</p>
<p>如果 Promise 的状态已经是 fulfilled 或 rejected，那么 <code>then()</code> 会立即创建一个微任务，将传入的对应的回调推入微任务队列</p>
<p>对于以下demo：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise in timeout&#x27;</span>);</span><br><span class="line">            <span class="title function_">resolve</span>();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise after timeout&#x27;</span>);</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise4&#x27;</span>);</span><br><span class="line">        <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;7777&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise5&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;99999&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise3&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// promise after timeout</span></span><br><span class="line"><span class="comment">// end</span></span><br><span class="line"><span class="comment">// promise3</span></span><br><span class="line"><span class="comment">// promise in timeout</span></span><br><span class="line"><span class="comment">// promise4</span></span><br><span class="line"><span class="comment">// 7777</span></span><br><span class="line"><span class="comment">// promise5</span></span><br><span class="line"><span class="comment">// 99999</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Browser</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
</search>
